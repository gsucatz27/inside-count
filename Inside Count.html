<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inside Count - Universe Mode Companion</title>
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0f172a">
    <link rel="apple-touch-icon" href="https://cdn-icons-png.flaticon.com/512/1532/1532953.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
<script src="https://unpkg.com/dexie/dist/dexie.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        body { background-color: #0f172a; color: #e2e8f0; font-family: 'Segoe UI', sans-serif; }
        .nav-btn.active { background-color: #dc2626; color: white; box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3); }
        .hidden-view { display: none !important; }
        
        /* Animations */
        @keyframes pulse-red { 0% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(220, 38, 38, 0); } 100% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0); } }
        .live-indicator { animation: pulse-red 2s infinite; }
        
        /* Calendar */
        .calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 1px; background: #334155; border: 1px solid #334155; }
        .calendar-day-header { background: #1e293b; color: #94a3b8; font-weight: bold; text-align: center; padding: 10px; font-size: 0.8rem; text-transform: uppercase; }
        .calendar-day { background: #0f172a; min-height: 120px; padding: 8px; transition: background 0.2s; cursor: pointer; }
        .calendar-day:hover { background: #1e293b; }
        .calendar-day.empty { background: #0f172a; opacity: 0.5; pointer-events: none; }
        .calendar-day.today { background: #1e293b; border: 2px solid #ef4444; }
        .show-pill { font-size: 0.75rem; margin-bottom: 4px; padding: 4px 8px; border-radius: 4px; font-weight: bold; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: block; }
        
        .pill-planned { background: #334155; color: #e2e8f0; border-left: 3px solid #60a5fa; }
        .pill-completed { background: #064e3b; color: #a7f3d0; border-left: 3px solid #34d399; }
        .pill-special { border-left-color: #f59e0b; background: #451a03; }

        /* Roster Dragging & Layout */
        .wrestler-row.dragging { opacity: 0.5; background: #334155; }
        .wrestler-row.over { border-top: 2px solid #3b82f6; }
        .division-container.over { border: 2px dashed #3b82f6; background: #1e293b; }
        .roster-filter-btn { text-align: left; padding: 10px 15px; border-radius: 8px; transition: all 0.2s; color: #94a3b8; font-weight: 600; font-size: 0.9rem; border-left: 4px solid transparent; display: flex; align-items: center; gap: 10px; }
        .roster-filter-btn:hover { background: #1e293b; color: white; }
        .roster-filter-btn.active { background: #1e293b; color: white; box-shadow: 0 4px 6px rgba(0,0,0, 0.2); border-left-color: #ef4444; }
        .roster-logo-sm { height: 20px; width: 20px; object-fit: contain; }
        
        .ranking-card { transition: transform 0.2s; }
        .ranking-card:hover { transform: translateX(5px); background-color: #1e293b; }

        /* Match Card Styling */
        .match-card { transition: all 0.2s; position: relative; }
        .match-card:hover { border-color: #475569; }
        .match-card.dragging { opacity: 0.5; border: 2px dashed #cbd5e1; }
        
        /* Championship Styles */
        .match-card.championship { 
            border-color: #eab308; /* Gold Border */
            background: linear-gradient(135deg, #3f2e0e 0%, #1e293b 40%); 
            box-shadow: 0 4px 10px rgba(234, 179, 8, 0.2); 
        }
        
        /* Completed State */
        .match-card.completed {
            border-color: #22c55e !important;
            background: #064e3b;
            opacity: 0.8;
        }

        .creative-note-box { background: #0f172a; border-left: 3px solid; padding: 10px; border-radius: 0 4px 4px 0; }
        .note-push { border-color: #22c55e; } 
        .note-heat { border-color: #ef4444; } 
        .note-spots { border-color: #eab308; } 
        .note-history { border-color: #3b82f6; }

       /* --- UPDATED MAGAZINE STYLES --- */

/* 1. The Background Container (The "Desk" or "World") */
.magazine-bg-layer {
    min-height: 100%;
    padding: 40px;
    background-size: cover;
    background-position: center;
    background-attachment: fixed;
    display: flex;
    justify-content: center;
}

/* 2. The Paper Sheet (The "Page") */
.magazine-page {
    background: white;
    max-width: 850px;
    width: 100%;
    box-shadow: 0 20px 50px rgba(0,0,0,0.5);
    padding: 0; /* Header goes edge-to-edge */
    position: relative;
    min-height: 800px;
    color: #1e293b; /* Default text color */
}

/* 3. Common Header Styling */
.mag-header { 
    background: #111; 
    color: #fff; 
    padding: 30px; 
    text-align: center; 
    border-bottom: 5px solid #dc2626; 
    border-top: 5px solid #dc2626;
}
.mag-headline { 
    font-family: 'Impact', 'Arial Black', sans-serif; 
    font-size: 3rem; 
    text-transform: uppercase; 
    letter-spacing: 2px;
    line-height: 1; 
}
.mag-subhead { 
    font-family: 'Georgia', serif; 
    font-style: italic; 
    color: #dc2626; 
    font-weight: bold; 
    margin-top: 5px; 
}

/* 4. Content Body */
.mag-content { padding: 40px; }

/* 5. Section Styling */
.report-h2 { 
    font-family: 'Arial Black', sans-serif; 
    font-size: 1.25rem; 
    text-transform: uppercase; 
    border-bottom: 3px solid #000; 
    margin-top: 25px; 
    margin-bottom: 10px; 
    padding-bottom: 5px;
}

/* --- ERA SPECIFIC THEMES --- */

/* TERRITORIES: Old, yellowed paper on a wooden desk */
.era-territories.magazine-bg-layer { background-image: url('Territories Magazine.jpg'); }
.era-territories .magazine-page {
    background-color: #fdf6e3; /* Yellowed paper */
    font-family: 'Courier New', monospace;
    box-shadow: 0 10px 20px rgba(0,0,0,0.3);
}
.era-territories .mag-header { background: transparent; border: none; color: #3b2f2f; border-bottom: 2px double #3b2f2f; }
.era-territories .mag-headline { font-family: 'Courier New', monospace; text-decoration: underline; }

/* GOLDEN ERA: Neon background, black glossy page */
.era-golden.magazine-bg-layer { background-image: url('Golden Era Magazine.jpg'); }
.era-golden .magazine-page {
    background: #0f172a; /* Dark page */
    color: #ffffff !important; /* FORCE WHITE TEXT */
    border: 2px solid #00ffff;
    box-shadow: 0 0 30px #d946ef;
}
.era-golden .mag-header { background: linear-gradient(90deg, #d946ef, #3b82f6); border: none; }
.era-golden .report-h2 { color: #facc15; border-bottom-color: #d946ef; }

/* NEW GENERATION: Gritty Concrete / Industrial Look */
.era-new_generation.magazine-bg-layer { 
    background-image: url('grey-concrete-.jpg'); 
    background-size: cover; 
    background-position: center;
}
.era-new_generation .magazine-page {
    background: #f8fafc; /* Cool white paper */
    border: 4px solid #334155; /* Slate border */
    font-family: 'Arial', sans-serif;
    color: #0f172a;
    box-shadow: 10px 10px 0px #0f172a; /* Hard shadow for 90s graphic style */
}
.era-new_generation .mag-header {
    background: linear-gradient(135deg, #0f172a, #334155); /* Dark Slate / Navy */
    color: #facc15; /* Neon Yellow Text */
    border-bottom: 4px solid #ec4899; /* Hot Pink Accent */
    text-shadow: 2px 2px 0px #ec4899;
}
.era-new_generation .mag-headline {
    font-family: 'Arial Black', sans-serif;
    transform: skewX(-10deg); /* The "Fast" 90s look */
}
.era-new_generation .report-h2 {
    color: #0f172a;
    border-bottom: 3px solid #facc15; /* Yellow underline */
    text-transform: uppercase;
    background: transparent;
    display: block;
}


/* ATTITUDE ERA: Grunge background, white torn page */
.era-attitude.magazine-bg-layer { background-image: url('attitude era magazine.png'); }
.era-attitude .magazine-page {
    background: #f1f5f9;
    transform: rotate(-1deg); /* Slight tilt for chaos */
    border: 1px solid #000;
}
.era-attitude .mag-header { 
    background-image: url('https://www.transparenttextures.com/patterns/concrete-wall.png'); 
    background-color: #1a1a1a;
}
.era-attitude .report-h2 { font-style: italic; transform: skewX(-10deg); background: black; color: white; padding-left: 10px; display: inline-block; }

/* RUTHLESS AGGRESSION: Industrial background, metallic page */
.era-ruthless.magazine-bg-layer { background-image: url('ruthless aggression era magazine.jpg'); }
.era-ruthless .magazine-page {
    background: #e2e8f0;
    border-left: 15px solid #991b1b;
}
.era-ruthless .report-h2 { color: #991b1b; border-bottom: 4px solid #94a3b8; }

/* MODERN ERAS: Clean, HD, Magazine Spread */
.era-pg.magazine-bg-layer { background-image: url('pg era magazine.jpg'); }
.era-reality.magazine-bg-layer { background-image: url('reality era magazine.jpg'); }
.era-current.magazine-bg-layer { background-image: url('current era magazine.jpg'); }
.era-current .magazine-page { border-top: 10px solid #ef4444; }

/* Safety fix for old archives */
#archive-viewer {
    color: #1e293b; /* Force Dark Text by default */
}
/* Ensure the wrapper overrides it if needed */
.magazine-bg-layer {
    color: #e2e8f0; /* Reset to light for the outer area if needed */
}
.magazine-page {
    color: #1e293b !important; /* Force Dark Text on the page */
}

/* --- MAGAZINE FEATURE IMAGE STYLE --- */
.mag-feature-image {
    display: block;
    max-width: 95%;      /* Ensures it fits on the page with slight padding */
    height: auto;        /* Maintains aspect ratio */
    margin: 25px auto;   /* Centers it vertically and horizontally */
    border: 1px solid #ddd; /* Subtle gray border */
    padding: 5px;        /* Creates a white "photo frame" gap */
    background: white;
    box-shadow: 3px 3px 10px rgba(0,0,0,0.2); /* subtle lift effect */
    transform: rotate(-0.5deg); /* Tiny tilt for realism */
}

/* Optional: Tweak border color based on era */
.era-golden .mag-feature-image { border-color: #00ffff; }
.era-attitude .mag-feature-image { border-color: #000; transform: rotate(-2deg); }
.era-ruthless .mag-feature-image { border-left: 5px solid #991b1b; }

/* --- RATINGS TABLE STYLE --- */
.ratings-table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    font-size: 0.85rem;
    background: rgba(255,255,255,0.5); /* Slight box containment */
    border-radius: 8px;
    overflow: hidden;
}
.ratings-table th {
    text-align: left;
    padding: 12px 8px;
    border-bottom: 2px solid #334155;
    text-transform: uppercase;
    font-weight: 900;
    color: #475569;
    font-size: 0.7rem;
    letter-spacing: 0.05em;
}
.ratings-table td {
    padding: 10px 8px;
    border-bottom: 1px solid #cbd5e1;
    color: #1e293b;
    vertical-align: middle;
}
.ratings-table tr:last-child td { border-bottom: none; }
.ratings-table tr:hover { background-color: rgba(0,0,0,0.02); }

/* Trend Indicators */
.trend-up { color: #16a34a; font-weight: bold; }   /* Green Arrow */
.trend-down { color: #dc2626; font-weight: bold; } /* Red Arrow */
.trend-flat { color: #64748b; font-weight: bold; } /* Slate Dash */

/* Era Specific Tweaks */
.era-attitude .ratings-table { background: #fff; border: 2px solid #000; transform: rotate(1deg); }
.era-golden .ratings-table { background: #000; color: #fff; border: 1px solid #00ffff; }
.era-golden .ratings-table td { color: #fff; border-bottom: 1px solid #333; }

/* POWER RANKINGS STYLES */
.rank-trend-up { color: #22c55e; font-weight: bold; }   /* Green Up */
.rank-trend-down { color: #ef4444; font-weight: bold; } /* Red Down */
.rank-trend-flat { color: #64748b; } /* Grey Flat */

.power-score-bar {
    height: 4px;
    background: #334155;
    border-radius: 2px;
    margin-top: 4px;
    overflow: hidden;
}
.power-score-fill {
    height: 100%;
    background: linear-gradient(90deg, #3b82f6, #8b5cf6);
    transition: width 0.5s ease;
}
.score-badge {
    font-size: 0.7rem;
    font-weight: 800;
    padding: 2px 6px;
    border-radius: 4px;
    background: #1e293b;
    border: 1px solid #334155;
    color: #cbd5e1;
}

/* RANKING OVERHAUL STYLES */
.rankings-hero-container {
    position: relative;
    width: 100%;
    min-height: 400px; /* Forces it to be tall enough */
    overflow: hidden;
    border-bottom: 6px solid #ef4444; 
    display: flex;
    align-items: flex-end; 
    padding: 0;
    margin-bottom: 0; 
    box-shadow: 0 10px 40px rgba(0,0,0,0.6);
    background-color: #0f172a; 
}

/* ADD THIS: The Background Image Layer */
.rankings-hero-bg {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    background-size: cover;
    background-position: center 20%; 
    z-index: 1; 
    transition: background-image 0.5s ease-in-out;
}

/* ADD THIS: The Gradient Overlay (Makes text readable) */
.rankings-hero-overlay {
    position: absolute;
    inset: 0;
    background: linear-gradient(to right, 
        rgba(15, 23, 42, 0.95) 0%, 
        rgba(15, 23, 42, 0.6) 50%, 
        transparent 100%
    );
    z-index: 2; 
}

.rankings-hero-overlay {
    background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0) 100%);
    position: absolute; inset: 0;
}
/* REPLACE THIS: The Content (Text & Buttons) */
.rankings-hero-content {
    position: relative;
    z-index: 10; 
    padding: 40px 50px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
}

.rankings-hero-title-big {
    font-family: 'Impact', sans-serif;
    font-size: 5rem;
    line-height: 0.9;
    color: white;
    text-transform: uppercase;
    font-style: italic;
    text-shadow: 4px 4px 0px #ef4444; 
    margin-bottom: 10px;
}

.rankings-grid {
    display: grid;
    grid-template-columns: 1fr 1fr; /* Two Columns */
    gap: 20px;
    max-width: 1400px;
    margin: 0 auto;
}

/* CARDS */
.rank-card-top10 {
    background: rgba(15, 23, 42, 0.9); /* Dark Slate 900 */
    border-left: 6px solid #ef4444; /* Red stripe default */
    margin-bottom: 10px;
    padding: 10px;
    display: flex;
    height: 78px;
    align-items: center;
    gap: 15px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    transition: transform 0.2s;
    backdrop-filter: blur(5px);
}

.rank-row-top { 
    display: flex; 
    align-items: center; 
    gap: 5px; /* <--- CHANGE THIS NUMBER to move the content away from the number */
}

.rank-card-top10 .flex-1 > div {
    justify-content: flex-start !important; /* Stops them from spreading to edges */
    gap: 40px; /* <--- Controls the distance between Name and Belt */
}

/* The Top Row: Rank | Name | Belt | Score */
.rank-row-top {
    display: flex;
    align-items: center;
    width: 100%;
}

/* The Name & Belt Container */
.rank-identity-box {
    flex: 1; /* Takes up all available space */
    display: flex;
    align-items: center;
    gap: 10px; /* Space between Name and Belt */
    min-width: 0; /* Allows text truncation if absolutely needed */
}

/* The Name Itself */
.rank-card-top10 h4 {
    font-family: 'Arial Black', sans-serif;
    font-size: 1.1rem;
    text-transform: uppercase;
    color: #ffffff;
    font-style: italic;
    white-space: nowrap; /* Keeps name on one line */
    margin: 0;
}

/* The Narrative Blurb - Now Full Width Underneath */
.rank-blurb {
    font-size: 0.75rem;
    color: #94a3b8;
    font-style: italic;
    line-height: 1.25;
    border-top: 1px solid #334155;
    padding-top: 5px;
    width: 100%;
    /* Ensure it wraps text properly */
    white-space: normal; 
    overflow: visible;
}

.rank-card-top10:hover { transform: scale(1.02); background: rgba(30, 41, 59, 0.95); }

.rank-card-mid {
    background: rgba(30, 41, 59, 0.8); /* Slate 800 */
    border-left: 4px solid #64748b;
    margin-bottom: 8px;
    padding: 8px;
    display: flex;
    height: 78px;
    align-items: center;
    gap: 10px;
}

/* SPECIFIC NUMBERS */
.rank-number-big { font-family: 'Impact', sans-serif; font-size: 2.5rem; color: #fff; line-height: 1; width: 50px; text-align: center; }
.rank-number-mid { font-family: 'Impact', sans-serif; font-size: 2.5rem; color: #cbd5e1; width: 40px; text-align: center; }


/* --- WRESTLER NAME FONTS --- */

/* LEFT COLUMN (Top 10) */
.rank-card-top10 h4 {
    font-family: 'Arial Black', sans-serif; /* Change Font Here */
    font-size: 1.25rem !important;           /* Size (Use !important to override defaults) */
    text-transform: uppercase;              /* Make it ALL CAPS */
    letter-spacing: 1px;                    /* Space between letters */
    color: #ffffff;                         /* Text Color */
    font-style: italic;                     /* Optional: Slant it */
}

/* RIGHT COLUMN (11-20) */
.rank-card-mid .font-bold {
    font-family: 'Arial', sans-serif;       /* Change Font Here */
    font-size: 1.25rem !important;          /* Smaller size for the list */
    text-transform: uppercase;
    color: #e2e8f0;                         /* Slightly dimmer white */
}

/* NARRATIVE BLURB */
.rank-blurb {
    font-size: 0.75rem;
    color: #94a3b8;
    font-style: italic;
    line-height: 1.2;
    margin-top: 4px;
    border-top: 1px solid #334155;
    padding-top: 4px;
}

/* --- NEW RANKINGS CENTERFOLD LAYOUT --- */

/* The Main 3-Column Grid */
.rankings-centerfold-grid {
    display: grid;
    grid-template-columns: 1fr 1.2fr 1fr; /* Left List | Big Image | Right List */
    gap: 20px;
    height: calc(100vh - 100px); /* Fill screen minus header */
    min-height: 800px;
    padding: 20px 40px;
    align-items: stretch;
}

.ranking-list-col {
    overflow: hidden;  /* <--- This stops the scroll */
    padding-right: 0;   /* Removed padding since there is no scrollbar */
    /* You can delete the scrollbar lines below as they are no longer needed */
}

.ranking-list-col {
    overflow: hidden;
    display: flex;             /* NEW: Turn on Flexbox */
    flex-direction: column;    /* NEW: Stack items vertically */
    justify-content: flex-start; /* NEW: Spread them out evenly */
    height: 100%;              /* NEW: Fill the container height */
}


/* Center Hero Panel */
.rankings-hero-panel {
    position: relative;
    border: 4px solid #fff;
    box-shadow: 0 0 50px rgba(0,0,0,0.8);
    overflow: hidden;
    background: #000;
    display: flex;
    flex-direction: column;
    justify-content: flex-end; 
}

.rankings-hero-img {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: top center;
    z-index: 1;
    transition: transform 0.5s;
}
.rankings-hero-panel:hover .rankings-hero-img { transform: scale(1.05); }

/* Overlay Text */
.rankings-hero-overlay {
    position: relative;
    z-index: 10;
    background: linear-gradient(to top, #000 0%, transparent 100%);
    padding: 40px 20px;
    text-align: center;
}

.hero-title-big {
    font-family: 'Impact', sans-serif;
    font-size: 5rem;
    line-height: 0.85;
    color: white;
    text-transform: uppercase;
    font-style: italic;
    text-shadow: 0 5px 15px rgba(0,0,0,0.8);
}
.hero-subtitle {
    color: #ef4444;
    font-weight: 900;
    font-size: 1.5rem;
    text-transform: uppercase;
    letter-spacing: 4px;
    margin-bottom: 10px;
    text-shadow: 2px 2px 0px #000;
}

/* Bottom Scrolling Section */
.rankings-bottom-scroll {
    padding: 20px 40px 60px 40px;
    background: rgba(0,0,0,0.5);
    border-top: 1px solid #334155;
}

/* SCRIPT / SCREENPLAY STYLING */
.script-container {
    background-color: #1e293b; /* Dark Slate */
    border-left: 4px solid #f59e0b; /* Amber accent */
    font-family: 'Courier New', Courier, monospace;
    padding: 20px;
    margin-top: 15px;
    border-radius: 6px;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
    color: #e2e8f0;
    font-size: 14px;
    line-height: 1.6;
}
.script-header {
    font-weight: bold;
    text-transform: uppercase;
    border-bottom: 1px solid #475569;
    padding-bottom: 10px;
    margin-bottom: 20px;
    color: #f59e0b; /* Amber */
    letter-spacing: 1px;
}
.script-action {
    font-style: italic;
    color: #94a3b8; /* Light Slate */
    margin-bottom: 15px;
}
.script-character {
    font-weight: bold;
    text-align: center;
    margin-top: 15px;
    color: #ffffff;
    text-transform: uppercase;
}
.script-dialogue {
    text-align: center;
    max-width: 80%;
    margin: 0 auto 15px auto;
    color: #cbd5e1;
}
.script-parenthetical {
    text-align: center;
    font-style: italic;
    font-size: 12px;
    color: #94a3b8;
    margin-bottom: 4px;
}

    </style>
</head>
<body class="h-screen flex flex-col md:flex-row overflow-hidden">

    <aside class="w-full md:w-64 bg-slate-900 border-r border-slate-700 flex flex-col z-20">
        <div class="p-6 border-b border-slate-700">
            <h1 class="text-2xl font-black tracking-tighter text-white italic">INSIDE<span class="text-red-500">COUNT</span></h1>
            <p class="text-xs text-slate-400 mt-1">AI Universe Companion</p>
        </div>
        <nav class="flex-1 p-4 space-y-2">
            <button onclick="switchMainView('dashboard', this)" class="nav-btn active w-full text-left px-4 py-3 text-slate-400 hover:bg-slate-800 hover:text-white rounded-lg transition font-bold relative">
                <i class="fa-solid fa-microphone-lines mr-3 w-5"></i> Show Planner
                <span id="sidebar-live-dot" class="hidden absolute right-3 top-4 w-2 h-2 bg-red-600 rounded-full live-indicator"></span>
            </button>
            <button onclick="switchMainView('calendar', this)" class="nav-btn w-full text-left px-4 py-3 text-slate-400 hover:bg-slate-800 hover:text-white rounded-lg transition font-bold">
                <i class="fa-solid fa-calendar-days mr-3 w-5"></i> Calendar
            </button>
            <button onclick="switchMainView('roster', this)" class="nav-btn w-full text-left px-4 py-3 text-slate-400 hover:bg-slate-800 hover:text-white rounded-lg transition font-bold">
                <i class="fa-solid fa-users mr-3 w-5"></i> Roster
            </button>
<button onclick="switchMainView('rivalries', this)" class="nav-btn w-full text-left px-4 py-3 text-slate-400 hover:bg-slate-800 hover:text-white rounded-lg transition font-bold">
    <i class="fa-solid fa-handshake-slash mr-3 w-5"></i> Rivalries
</button>
            <button onclick="switchMainView('rankings', this)" class="nav-btn w-full text-left px-4 py-3 text-slate-400 hover:bg-slate-800 hover:text-white rounded-lg transition font-bold">
                <i class="fa-solid fa-chart-line mr-3 w-5"></i> Power Rankings
            </button>
            <button onclick="switchMainView('dirtsheet', this)" class="nav-btn w-full text-left px-4 py-3 text-slate-400 hover:bg-slate-800 hover:text-white rounded-lg transition font-bold">
                <i class="fa-solid fa-book-open mr-3 w-5"></i> Archive
            </button>
            <div class="pt-4 mt-4 border-t border-slate-800">
                <button onclick="switchMainView('settings', this)" class="nav-btn w-full text-left px-4 py-3 text-slate-400 hover:bg-slate-800 hover:text-white rounded-lg transition font-bold">
                    <i class="fa-solid fa-gear mr-3 w-5"></i> Settings
                </button>
            </div>
            <div class="mt-auto border-t border-slate-800 pt-4">
                 <button onclick="window.location.href='index.html'" class="w-full text-left px-4 py-3 text-slate-500 hover:text-red-400 transition text-sm">
                    <i class="fa-solid fa-right-from-bracket mr-3"></i> Exit to Menu
                </button>
            </div>
        </nav>
        <div class="p-4 bg-slate-800 m-4 rounded-lg border border-slate-600">
            <div class="text-xs font-bold text-slate-400 uppercase mb-1">Active Universe</div>
            <div id="display-universe-name" class="font-bold text-white text-sm truncate">Loading...</div>
            <div id="display-era-name" class="text-xs text-yellow-500">Loading...</div>
        </div>
    </aside>

    <main class="flex-1 flex flex-col h-full overflow-hidden relative">
        <header id="main-header" class="bg-slate-800 border-b border-slate-700 p-6 flex justify-between items-center shadow-md relative overflow-hidden transition-colors duration-500">
            <div id="header-bg-overlay" class="absolute inset-0 opacity-20 pointer-events-none"></div>
            
            <div class="relative z-10">
                <div class="flex items-center gap-4">
                    <span id="status-badge" class="bg-blue-600 text-white text-xs font-bold px-2 py-1 rounded">PLANNING</span>
                    <button id="btn-prev-show" onclick="navigateShow(-1)" class="w-8 h-8 flex items-center justify-center bg-slate-700 hover:bg-slate-600 text-slate-300 hover:text-white rounded-full transition hidden"><i class="fa-solid fa-chevron-left"></i></button>
                    
                    <div class="flex items-center gap-3">
                        <img id="header-show-logo" src="" class="hidden h-12 w-auto object-contain drop-shadow-lg">
                        <h2 id="header-show-name" class="text-3xl font-black text-white tracking-wide drop-shadow-md">NO SHOW SELECTED</h2>
                    </div>

                    <button id="btn-next-show" onclick="navigateShow(1)" class="w-8 h-8 flex items-center justify-center bg-slate-700 hover:bg-slate-600 text-slate-300 hover:text-white rounded-full transition hidden"><i class="fa-solid fa-chevron-right"></i></button>
                </div>
                <div class="flex items-center gap-2 mt-1">
                     <p id="header-date-info" class="text-slate-400 text-sm">Select a show from the Calendar to begin.</p>
                </div>
                <div id="header-roster-pool" class="text-xs text-blue-400 mt-1 hidden font-mono"></div>
            </div>
            
            <div id="dashboard-controls" class="relative z-10 flex gap-3 hidden">
                <div id="planner-actions">
                    <button onclick="startLiveShow()" class="px-6 py-2 bg-red-600 hover:bg-red-500 text-white rounded font-bold transition flex items-center gap-2 shadow-lg shadow-red-900/20"><i class="fa-solid fa-play"></i> Start Live Show</button>
                </div>
                <div id="live-actions" class="hidden flex gap-2">
                    <button onclick="exitLiveShow()" class="px-3 py-2 bg-slate-700 hover:bg-slate-600 text-white rounded font-bold transition text-xs"><i class="fa-solid fa-arrow-left"></i></button>
                    <button onclick="simulateShow()" class="px-4 py-2 bg-purple-600 hover:bg-purple-500 text-white rounded font-bold transition flex items-center gap-2 text-xs shadow-lg shadow-purple-900/20"><i class="fa-solid fa-robot"></i> Simulate Rest</button>
                    <button onclick="finishShowSimple()" class="px-4 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded font-bold transition flex items-center gap-2 text-xs"><i class="fa-solid fa-flag-checkered"></i> Finish (No Report)</button>
                    <button onclick="finishShow()" class="px-4 py-2 bg-green-600 hover:bg-green-500 text-white rounded font-bold transition flex items-center gap-2 text-xs"><i class="fa-solid fa-print"></i> Generate Report</button>
                </div>
                <div id="completed-actions" class="hidden flex gap-3">
                    <div class="text-green-400 font-bold flex items-center mr-4"><i class="fa-solid fa-check-circle mr-2"></i> COMPLETED</div>
                    <button onclick="viewReport(activeShow.reportId)" id="btn-view-report" class="hidden px-6 py-2 bg-slate-700 hover:bg-slate-600 text-white rounded font-bold transition"><i class="fa-solid fa-book-open mr-2"></i> Read Report</button>
                </div>
            </div>
        </header>

        <div id="view-dashboard" class="main-view hidden-view flex-1 overflow-hidden relative flex flex-col">
            <div id="subview-planner" class="flex-1 overflow-y-auto p-6 flex gap-6">
                <div class="w-1/3 flex flex-col gap-4">
                    <div id="planner-tools-container" class="bg-slate-800 rounded-xl p-5 border border-slate-700 shadow-lg">
                        <h3 class="text-lg font-bold text-white mb-3">AI Booker</h3>
                        <textarea id="booker-prompt" class="w-full bg-slate-900 border border-slate-700 rounded-lg p-3 text-sm text-white focus:border-red-500 h-32 mb-3 resize-none" placeholder="Instructions: E.g., 'Book a 5-match card ending with a cliffhanger. Use the current roster.'"></textarea>
                        <button onclick="aiBookShow()" class="w-full py-3 bg-cyan-600 hover:bg-cyan-500 text-white font-bold rounded-lg transition shadow-lg shadow-cyan-900/50"><i class="fa-solid fa-wand-magic-sparkles mr-2"></i> Auto-Book Card</button>
                        <div id="ai-loading" class="hidden text-center text-xs text-cyan-400 mt-2 animate-pulse font-bold">Consulting Creative Team...</div>
                    </div>
                    
                    <div class="bg-slate-800/50 rounded-xl p-5 border border-slate-700/50">
                        <h4 class="text-xs font-bold text-slate-500 uppercase mb-2">Creative Notes</h4>
                        <p class="text-xs text-slate-400">Expand match cards on the right to see booking instructions. These are just plans; actual results are logged during the Live Show.</p>
                    </div>

                    <div id="broadcast-team-sidebar" class="bg-slate-800/30 rounded-xl p-5 border border-slate-700/30 hidden">
                        <h4 class="text-xs font-bold text-slate-500 uppercase mb-3 flex items-center gap-2"><i class="fa-solid fa-headset"></i> Broadcast Team</h4>
                        <div id="broadcast-team-list" class="space-y-3"></div>
                    </div>
                </div>

                <div class="flex-1">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold text-white">Match Card</h3>
                        <span class="text-xs text-slate-500">Drag to reorder. Click to edit plans.</span>
                    </div>
                    <div id="planner-container" class="space-y-3 pb-20"></div>
                    <button id="btn-add-manual-segment" onclick="openSegmentModal()" class="w-full py-4 mt-4 border-2 border-dashed border-slate-700 hover:border-slate-500 text-slate-500 hover:text-slate-300 rounded-lg font-bold transition uppercase tracking-wider"><i class="fa-solid fa-plus mr-2"></i> Add Manual Segment</button>
                </div>
            </div>

            <div id="subview-live" class="hidden flex-1 overflow-y-auto p-6 bg-black/20">
                <div class="max-w-4xl mx-auto">
                    <div class="flex justify-between items-end mb-6">
                        <div class="flex flex-col">
                            <h2 class="text-2xl font-bold text-white flex items-center gap-2"><span class="w-3 h-3 bg-red-600 rounded-full live-indicator"></span> On Air: Gorilla Position</h2>
                            <div id="show-completion-status" class="text-xs font-bold mt-1 text-slate-500">Waiting for results...</div>
                        </div>
                        <div id="live-commentary-display" class="text-xs text-slate-400 text-right"></div>
                    </div>
                    <div class="w-full bg-slate-800 rounded-full h-2.5 mb-6">
                        <div id="show-progress-bar" class="bg-blue-600 h-2.5 rounded-full transition-all duration-500" style="width: 0%"></div>
                    </div>
                    <div id="live-feed" class="space-y-6 pb-20"></div>
                </div>
            </div>
        </div>

        <div id="view-calendar" class="main-view flex-1 overflow-y-auto p-8"><div class="max-w-6xl mx-auto"><div class="flex justify-between items-center mb-6"><div class="flex items-center gap-4"><button onclick="changeMonth(-1)" class="text-slate-400 hover:text-white"><i class="fa-solid fa-chevron-left fa-lg"></i></button><h2 class="text-3xl font-bold text-white" id="calendar-month-display">MAY 2024</h2><button onclick="changeMonth(1)" class="text-slate-400 hover:text-white"><i class="fa-solid fa-chevron-right fa-lg"></i></button><button onclick="document.getElementById('nav-date-modal').classList.remove('hidden')" class="text-xs bg-slate-700 px-3 py-1 rounded text-slate-300 hover:text-white ml-2">Jump to Date</button></div><button onclick="openShowModal(null)" class="bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded font-bold"><i class="fa-solid fa-plus mr-2"></i> Add Show</button></div><div class="calendar-grid rounded-t-xl border-b-0"><div class="calendar-day-header">Mon</div><div class="calendar-day-header">Tue</div><div class="calendar-day-header">Wed</div><div class="calendar-day-header">Thu</div><div class="calendar-day-header">Fri</div><div class="calendar-day-header">Sat</div><div class="calendar-day-header">Sun</div><button onclick="extendSpecificYear()" class="bg-indigo-600 hover:bg-indigo-500 text-white px-4 py-2 rounded shadow-md text-sm font-bold flex items-center gap-2">
    <i class="fa-solid fa-clock-rotate-left"></i> Extend Timeline
</button></div><div id="calendar-body" class="calendar-grid rounded-b-xl"></div></div></div>
        
        <div id="view-roster" class="main-view hidden-view flex-1 overflow-hidden flex"><div class="w-64 bg-slate-800 border-r border-slate-700 p-4 flex flex-col"><h3 class="text-xs font-bold text-slate-500 uppercase mb-3 px-2">Show Filters</h3><div id="roster-filters" class="space-y-1 flex-1 overflow-y-auto"></div><div class="pt-4 border-t border-slate-700"><button onclick="openUploadModal('roster')" class="w-full bg-slate-700 hover:bg-slate-600 text-white px-4 py-2 rounded font-bold mb-2 text-sm"><i class="fa-solid fa-camera mr-2"></i> Upload Image</button></div></div><div class="flex-1 overflow-y-auto p-8 bg-slate-900"><div class="max-w-6xl mx-auto"><div class="flex justify-between items-center mb-6"><div class="flex items-center gap-3"><img id="roster-page-logo" class="h-10 hidden"><h2 id="roster-view-title" class="text-3xl font-bold text-white">All Roster</h2></div><div class="flex bg-slate-700 rounded p-1 mx-4">
    <button onclick="setRosterViewMode('official')" id="btn-view-official" class="px-3 py-1 rounded text-xs font-bold bg-blue-600 text-white shadow">Manual</button>
    <button onclick="setRosterViewMode('system')" id="btn-view-system" class="px-3 py-1 rounded text-xs font-bold text-slate-400 hover:text-white">System Tracker</button>
</div>

<button onclick="openRosterSyncModal()" class="ml-2 bg-slate-700 hover:bg-slate-600 text-slate-300 hover:text-white px-3 py-2 rounded font-bold text-sm transition flex items-center" title="Synchronize Roster">
    <i class="fa-solid fa-rotate"></i>
    <span class="ml-2">Sync Roster</span>
</button>

<button onclick="openManualAddModal()" class="bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded font-bold"><i class="fa-solid fa-plus mr-2"></i> Add Wrestler</button></div><div id="roster-upload-status" class="hidden bg-slate-800 p-4 rounded mb-4 border border-blue-500 text-blue-400 animate-pulse"><i class="fa-solid fa-robot mr-2"></i> AI is scanning image...</div><div id="roster-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"></div></div></div></div>

<div id="view-rivalries" class="main-view hidden-view flex-1 overflow-hidden flex">
    <div class="w-72 bg-slate-800 border-r border-slate-700 p-4 flex flex-col">
        <h3 class="text-xs font-bold text-slate-500 uppercase mb-3 px-2">Active Storylines</h3>
        <div id="rivalry-list" class="space-y-2 flex-1 overflow-y-auto"></div>
        <button onclick="createNewRivalry()" class="w-full bg-blue-600 hover:bg-blue-500 text-white px-4 py-3 rounded font-bold mt-4 shadow-lg shadow-blue-900/50">
            <i class="fa-solid fa-plus mr-2"></i> Start Rivalry
        </button>
    </div>

    <div class="flex-1 bg-slate-900 overflow-y-auto p-8">
        <div id="rivalry-editor" class="hidden max-w-6xl mx-auto">
            
            <div class="flex justify-between items-start mb-6 border-b border-slate-700 pb-6">
                <div class="w-1/2">
                    <label class="text-xs font-bold text-slate-500 uppercase">Rivalry Name</label>
                    <input id="riv-name" type="text" placeholder="e.g. nWo vs WCW" class="w-full bg-transparent text-3xl font-black text-white focus:outline-none border-none placeholder-slate-700 p-0" onchange="saveCurrentRivalry()">
                </div>
                
                <div class="w-1/4 px-4">
                    <label class="text-xs font-bold text-slate-500 uppercase">Host Show</label>
                    <select id="riv-host" class="w-full bg-slate-800 border border-slate-600 text-white p-2 rounded text-sm focus:border-blue-500" onchange="saveCurrentRivalry()">
                        </select>
                </div>

                <div class="w-1/4 text-right">
                    <button onclick="deleteCurrentRivalry()" class="text-red-500 hover:text-white text-xs font-bold uppercase mt-4"><i class="fa-solid fa-trash mr-1"></i> End Storyline</button>
                </div>
            </div>

            <div class="grid grid-cols-3 gap-6 mb-8 bg-slate-800/50 p-6 rounded-xl border border-slate-700">
                <div>
                    <label class="block text-xs font-bold text-slate-500 uppercase mb-2">Start Date</label>
                    <input id="riv-start" type="date" class="w-full bg-slate-900 border border-slate-600 text-white p-2 rounded text-sm" onchange="saveCurrentRivalry(); populateBlowoffDropdown();">
                </div>
                <div>
                    <label class="block text-xs font-bold text-slate-500 uppercase mb-2">Blow-off Show (End Date)</label>
                    <select id="riv-blowoff" class="w-full bg-slate-900 border border-slate-600 text-white p-2 rounded text-sm" onchange="saveCurrentRivalry()">
                        <option value="">- Select Target Show -</option>
                    </select>
                </div>
                <div>
                    <label class="block text-xs font-bold text-purple-400 uppercase mb-2">The Endgame (AI Goal)</label>
                    <input id="riv-goal" type="text" placeholder="e.g. Sting beats Hogan for Title" class="w-full bg-slate-900 border border-slate-600 text-white p-2 rounded text-sm" onchange="saveCurrentRivalry()">
                </div>
            </div>

            <h3 class="text-sm font-bold text-slate-400 uppercase mb-4 text-center">— Faction Warfare (Add up to 5 per side) —</h3>
            
            <div class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-4 gap-4">
                <div class="bg-slate-800 border-t-4 border-blue-500 rounded-b-xl p-4 min-h-[300px]">
                    <div class="flex justify-between mb-3"><span class="font-bold text-white">Side A</span> <span class="text-xs text-slate-500">Protagonists</span></div>
                    <div id="riv-side-0" class="space-y-2"></div>
                    <button onclick="addRivalryMember(0)" class="w-full mt-3 py-2 border border-dashed border-slate-600 text-slate-500 hover:text-white hover:border-slate-400 rounded text-xs">+ Add Wrestler</button>
                </div>

                <div class="bg-slate-800 border-t-4 border-red-500 rounded-b-xl p-4 min-h-[300px]">
                    <div class="flex justify-between mb-3"><span class="font-bold text-white">Side B</span> <span class="text-xs text-slate-500">Antagonists</span></div>
                    <div id="riv-side-1" class="space-y-2"></div>
                    <button onclick="addRivalryMember(1)" class="w-full mt-3 py-2 border border-dashed border-slate-600 text-slate-500 hover:text-white hover:border-slate-400 rounded text-xs">+ Add Wrestler</button>
                </div>

                <div class="bg-slate-800 border-t-4 border-yellow-500 rounded-b-xl p-4 min-h-[300px]">
                    <div class="flex justify-between mb-3"><span class="font-bold text-white">Side C</span> <span class="text-xs text-slate-500">Third Party</span></div>
                    <div id="riv-side-2" class="space-y-2"></div>
                    <button onclick="addRivalryMember(2)" class="w-full mt-3 py-2 border border-dashed border-slate-600 text-slate-500 hover:text-white hover:border-slate-400 rounded text-xs">+ Add Wrestler</button>
                </div>

                <div class="bg-slate-800 border-t-4 border-green-500 rounded-b-xl p-4 min-h-[300px]">
                    <div class="flex justify-between mb-3"><span class="font-bold text-white">Side D</span> <span class="text-xs text-slate-500">Fourth Party</span></div>
                    <div id="riv-side-3" class="space-y-2"></div>
                    <button onclick="addRivalryMember(3)" class="w-full mt-3 py-2 border border-dashed border-slate-600 text-slate-500 hover:text-white hover:border-slate-400 rounded text-xs">+ Add Wrestler</button>
                </div>
            </div>

        </div>
        
        <div id="rivalry-empty" class="text-center mt-20">
            <i class="fa-solid fa-handshake-slash text-6xl text-slate-700 mb-4"></i>
            <h2 class="text-2xl font-bold text-slate-500">No Rivalry Selected</h2>
            <p class="text-slate-600">Select a storyline from the left or start a new one.</p>
        </div>
    </div>
</div>
      
<div id="view-rankings" class="main-view hidden-view flex-1 overflow-y-auto relative bg-slate-900">
    
    <div id="rankings-bg-layer" class="absolute inset-0 z-0 opacity-20 pointer-events-none bg-cover bg-center"></div>

    <div class="rankings-centerfold-grid relative z-10">
        
        <div class="ranking-list-col">
            <h3 class="text-2xl font-black text-white italic uppercase mb-4 border-b-4 border-red-600 inline-block">The Top 10</h3>
            <div id="ranking-col-1" class="space-y-2 pb-10">
                </div>
        </div>

        <div class="rankings-hero-panel group">
            <img id="ranking-hero-img" src="" class="rankings-hero-img">
            
            <div class="absolute top-4 right-4 z-50 flex flex-col gap-2 opacity-0 group-hover:opacity-100 transition duration-300">
                 <button onclick="document.getElementById('rankings-upload-input').click()" class="bg-black/50 hover:bg-black text-white border border-white/30 backdrop-blur-md px-3 py-2 rounded font-bold text-xs uppercase shadow-xl"><i class="fa-solid fa-camera"></i> Change Image</button>
                 <input type="file" id="rankings-upload-input" class="hidden" accept="image/*" onchange="uploadRankingHero()">
                 
                 <button onclick="generateRankingBlurbs()" class="bg-blue-600 hover:bg-blue-500 text-white px-3 py-2 rounded font-bold text-xs uppercase shadow-xl"><i class="fa-solid fa-pen-nib"></i> AI Analysis</button>
                 <button onclick="document.getElementById('ranking-sidebar').classList.toggle('hidden')" class="bg-slate-700 hover:bg-slate-600 text-white px-3 py-2 rounded font-bold text-xs uppercase shadow-xl"><i class="fa-solid fa-sliders"></i> Filters</button>
            </div>

            <div class="rankings-hero-overlay">
                <div class="hero-subtitle" id="ranking-hero-subtitle">GLOBAL STANDINGS</div>
                <div class="hero-title-big">POWER<br>RANKINGS</div>
                
                <div class="flex justify-center mt-4">
                     <span id="ranking-mode-badge" class="bg-purple-600 text-white text-[10px] font-bold px-3 py-1 rounded-full border border-purple-400 uppercase tracking-wider shadow-lg">System Tracker Active</span>
                </div>
            </div>
        </div>

        <div class="ranking-list-col">
            <h3 class="text-2xl font-black text-slate-400 italic uppercase mb-4 border-b-4 border-slate-600 inline-block">The Chase (11-20)</h3>
            <div id="ranking-col-2" class="space-y-2 pb-10">
                </div>
        </div>

    </div>

    <div class="rankings-bottom-scroll relative z-10">
        <h4 class="text-sm font-bold text-slate-500 uppercase mb-4">Complete Roster Standings</h4>
        <div id="ranking-col-3" class="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-5 gap-4">
            </div>
    </div>
    
    <div id="ranking-sidebar" class="hidden fixed top-0 right-0 h-full w-72 bg-slate-900/95 border-l border-slate-700 p-6 shadow-2xl z-50 backdrop-blur-xl">
         <div class="flex justify-between items-center mb-6">
            <h3 class="font-bold text-white uppercase">Filters</h3>
            <button onclick="document.getElementById('ranking-sidebar').classList.add('hidden')" class="text-slate-400 hover:text-white"><i class="fa-solid fa-xmark"></i></button>
         </div>
         <div id="ranking-filters" class="space-y-2 mb-6"></div>
         <div class="border-t border-slate-700 pt-6">
             <div class="flex flex-col gap-2">
                <label class="flex items-center gap-2 cursor-pointer bg-slate-800 p-3 rounded border border-slate-600">
                    <input type="radio" name="rank-mode" value="manual" onchange="toggleRankingMode()" class="text-blue-600">
                    <span class="text-xs font-bold text-white uppercase">Manual Control</span>
                </label>
                <label class="flex items-center gap-2 cursor-pointer bg-slate-800 p-3 rounded border border-slate-600">
                    <input type="radio" name="rank-mode" value="ai" checked onchange="toggleRankingMode()" class="text-purple-600">
                    <span class="text-xs font-bold text-purple-400 uppercase">System Tracker</span>
                </label>
            </div>
         </div>
    </div>

</div>



        <div id="view-dirtsheet" class="main-view hidden-view flex-1 overflow-hidden flex"><div class="w-64 bg-slate-800 border-r border-slate-700 p-4 overflow-y-auto"><h2 class="text-xl font-bold text-white mb-4">Back Issues</h2><div id="archive-list" class="space-y-2"></div></div><div class="flex-1 bg-slate-200 overflow-y-auto p-8"><div id="archive-viewer" class="max-w-4xl mx-auto bg-white shadow-2xl min-h-screen magazine-container rounded"><div class="p-20 text-center text-slate-400">Select an issue.</div></div><div id="archive-controls" class="hidden absolute top-4 right-8"><button onclick="document.getElementById('archive-image-upload').click()" class="bg-purple-600 hover:bg-purple-500 text-white px-3 py-1 rounded text-xs mr-2 shadow-lg">Upload Cover</button><input id="archive-image-upload" type="file" class="hidden" accept="image/*" onchange="addArchiveImage()"></div></div></div>
       <div id="view-settings" class="main-view hidden-view flex-1 p-6">
            <div class="max-w-md mx-auto bg-slate-800 p-6 rounded text-white border border-slate-700 space-y-6">
                
                <div>
                    <h3 class="font-bold mb-4 text-xl">System Credentials</h3>
                    <label class="text-xs font-bold text-slate-500 uppercase">OpenAI API Key</label>
                    <input id="api-key-input" type="password" class="w-full bg-slate-900 p-3 border border-slate-600 rounded mb-4 text-white">
                    <button onclick="localStorage.setItem('openai_key', document.getElementById('api-key-input').value); alert('Saved')" class="bg-blue-600 w-full py-2 rounded font-bold hover:bg-blue-500">Save Credentials</button>
                </div>

                <div class="pt-6 border-t border-slate-700">
                    <h3 class="font-bold mb-4 text-xl">Gameplay Settings</h3>
                    
                    <div class="flex items-center justify-between mb-4">
                        <div>
                            <div class="font-bold text-white">Roster Cap (Hard Mode)</div>
                            <div class="text-xs text-slate-400">Prevent hiring if roster exceeds limit.</div>
                        </div>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="setting-cap-toggle" class="sr-only peer" onchange="saveGameplaySettings()">
                            <div class="w-11 h-6 bg-slate-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-red-600"></div>
                        </label>
                    </div>

                    <div id="cap-limit-container" class="mb-4 transition-opacity duration-300">
                        <label class="text-xs font-bold text-slate-500 uppercase">Max Roster Size</label>
                        <div class="flex gap-2">
                            <input id="setting-cap-limit" type="number" class="w-full bg-slate-900 p-3 border border-slate-600 rounded text-white" value="50" onchange="saveGameplaySettings()">
                            <div class="flex items-center justify-center bg-slate-700 px-4 rounded font-mono text-sm font-bold text-slate-300" id="current-roster-count">
                                0 / 50
                            </div>
                        </div>
                    </div> </div> <div class="pt-6 border-t border-slate-700">
    <h3 class="font-bold mb-4 text-xl">Data Management</h3>
    <button onclick="exportSaveToFile()" class="w-full bg-green-700 hover:bg-green-600 text-white font-bold py-3 rounded transition shadow-lg">
        <i class="fa-solid fa-download mr-2"></i> Download Backup (JSON)
    </button>
    <p class="text-xs text-slate-400 mt-2">
        This creates a portable copy of your universe (including all images) that you can store on your computer.
    </p>
</div>

  </div> </div> </main>

    <div id="segment-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50">
    <div class="bg-slate-900 border border-slate-700 p-6 rounded-xl w-full max-w-md">
        <h3 class="text-xl font-bold text-white mb-4">Add Segment</h3>
        
        <div class="mb-3">
            <label class="block text-xs font-bold text-slate-500 uppercase mb-1">Category</label>
            <select id="modal-type" onchange="toggleSegmentOptions()" class="w-full bg-slate-800 border-slate-600 text-white p-3 rounded"><option value="match">Match</option><option value="promo">Promo / Segment</option><option value="highlight">Highlight Package</option></select>
        </div>
        
        <div id="match-options" class="mb-3">
            <label class="block text-xs font-bold text-slate-500 uppercase mb-1">Match Format</label>
           <select id="modal-match-type" onchange="updateCompetitorSelectors()" class="w-full bg-slate-800 border-slate-600 text-white p-3 rounded">
  <option value="One on One">One on One</option>
  <option value="Tag Team">Tag Team</option>
  <option value="Triple Threat">Triple Threat</option>
  <option value="Fatal 4-Way">Fatal 4-Way</option>
  <option value="Five-Way">Five-Way</option>
  <option value="Six-Man">Six-Man</option>
  <option value="8-Man">8-Man</option>
  <option value="10-Man">10-Man</option>
  <option value="Battle Royal">Battle Royal</option>
  <option value="Royal Rumble 30">Royal Rumble 30</option>
  <option value="Royal Rumble 60">Royal Rumble 60</option>
</select>

            <div class="mt-2">
	<label class="block text-xs font-bold text-slate-500 uppercase mb-1">Stipulation (Optional)</label>
	    <input id="modal-stipulation" type="text" placeholder="e.g. Ladder Match, Title on the Line" class="w-full bg-slate-800 border-slate-600 text-white p-2 rounded">
	</div>
            <div class="mt-2"><label class="block text-xs font-bold text-yellow-500 uppercase mb-1">Championship on the Line?</label><select id="modal-title-select" class="w-full bg-slate-800 border-slate-600 text-white p-2 rounded"><option value="">- None -</option></select></div>

<div class="mt-2">
        <label class="block text-xs font-bold text-slate-500 uppercase mb-1">Special Guest Referee</label>
        <select id="modal-referee" class="w-full bg-slate-800 border-slate-600 text-white p-2 rounded">
            <option value="">- Standard Official -</option>
        </select>
    </div>
    <div class="mt-2">
        <label class="block text-xs font-bold text-slate-500 uppercase mb-1">Managers / Valets</label>
        <div id="manager-container" class="space-y-2"></div>
        <button type="button" onclick="addManagerSlot()" class="w-full mt-2 py-2 border border-dashed border-slate-600 text-slate-500 text-xs hover:text-white hover:border-purple-500 rounded transition">
            <i class="fa-solid fa-plus mr-1"></i> Add Manager
        </button>
    </div>

        </div>
        
        <div id="promo-options" class="mb-3 hidden">
            <label class="block text-xs font-bold text-slate-500 uppercase mb-1">Segment Type</label>
            <select id="modal-promo-type" class="w-full bg-slate-800 border-slate-600 text-white p-3 rounded"><option value="In-Ring Interview">In-Ring Interview</option><option value="Backstage Interview">Backstage Interview</option><option value="Authority Address">Authority Address</option><option value="Contract Signing">Contract Signing</option><option value="Beatdown">Beatdown / Brawl</option></select>
        </div>

        <div id="competitor-container" class="mb-3 grid grid-cols-2 gap-2"></div>
        
        <button id="btn-add-promo-person" type="button" onclick="addCompetitorSlot(this.dataset.targetContainer || 'competitor-container')" class="hidden w-full py-2 border border-dashed border-slate-600 text-slate-400 text-xs mb-3 hover:text-white hover:border-slate-400 rounded transition">
            <i class="fa-solid fa-plus mr-2"></i> Add Participant
        </button>
        
        <div class="mb-3"><label class="block text-xs font-bold text-slate-500 uppercase mb-1">Headline</label><input id="modal-title" type="text" placeholder="e.g. Main Event" class="w-full bg-slate-800 border-slate-600 text-white p-3 rounded"></div>
        
        <div class="flex gap-2 pt-2">
            <button onclick="document.getElementById('segment-modal').classList.add('hidden')" class="flex-1 bg-slate-700 text-white py-3 rounded hover:bg-slate-600">Cancel</button>
            <button onclick="addManualSegment()" class="flex-1 bg-red-600 text-white py-3 rounded font-bold hover:bg-red-500">Add to Card</button>
        </div>
    </div>
</div>
    
    <div id="edit-segment-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50">
    <div class="bg-slate-900 border border-slate-700 p-6 rounded-xl w-full max-w-lg shadow-2xl overflow-y-auto max-h-[90vh]">
        <h3 class="text-xl font-bold text-white mb-4">Edit Segment</h3>
        <input type="hidden" id="edit-seg-index">
        
        <div class="mb-4 pb-4 border-b border-slate-700">
            <p class="text-xs text-slate-400 mb-2 uppercase font-bold tracking-widest">Match / Segment Setup</p>
            
            <div class="grid grid-cols-2 gap-3 mb-3">
                <div>
                    <label class="block text-xs font-bold text-slate-500 uppercase mb-1">Type</label>
                    <select id="edit-type" onchange="toggleEditSegmentOptions()" class="w-full bg-slate-800 border-slate-600 text-white p-2 rounded">
                        <option value="match">Match</option>
                        <option value="promo">Promo</option>
                        <option value="highlight">Highlight</option>
                    </select>
                </div>
                <div id="edit-match-type-container">
                    <label class="block text-xs font-bold text-slate-500 uppercase mb-1">Match Type</label>
                    <select id="edit-match-type" onchange="updateEditCompetitorSelectors()" class="w-full bg-slate-800 border-slate-600 text-white p-2 rounded">
  <option value="One on One">One on One</option>
  <option value="Tag Team">Tag Team</option>
  <option value="Triple Threat">Triple Threat</option>
  <option value="Fatal 4-Way">Fatal 4-Way</option>
  <option value="Five-Way">Five-Way</option>
  <option value="Six-Man">Six-Man</option>
  <option value="8-Man">8-Man</option>
  <option value="10-Man">10-Man</option>
  <option value="Battle Royal">Battle Royal</option>
  <option value="Royal Rumble 30">Royal Rumble 30</option>
  <option value="Royal Rumble 60">Royal Rumble 60</option>
</select>

                </div>
                <div id="edit-promo-type-container" class="hidden">
                    <label class="block text-xs font-bold text-slate-500 uppercase mb-1">Promo Type</label>
                    <select id="edit-promo-type" class="w-full bg-slate-800 border-slate-600 text-white p-2 rounded">
                        <option value="In-Ring Interview">In-Ring Interview</option>
                        <option value="Backstage Interview">Backstage Interview</option>
                        <option value="Beatdown">Beatdown</option>
                        <option value="Vignette">Vignette</option>
                    </select>
                </div>
            </div>

            <div id="edit-competitor-container" class="mb-3 grid grid-cols-2 gap-2"></div>
            
            <button id="btn-edit-add-promo-person" type="button" onclick="addCompetitorSlot(this.dataset.targetContainer || 'edit-competitor-container')" class="hidden w-full py-2 border border-dashed border-slate-600 text-slate-400 text-xs mb-3 hover:text-white hover:border-slate-400 rounded transition">
                <i class="fa-solid fa-plus mr-2"></i> Add Participant
            </button>
            <div class="mb-3"><label class="block text-xs font-bold text-slate-500 uppercase mb-1">Stipulation / Subtitle</label><input id="edit-stipulation" type="text" class="w-full bg-slate-800 border-slate-600 text-white p-2 rounded"></div>
            <div id="edit-title-container" class="mb-3"><label class="block text-xs font-bold text-yellow-500 uppercase mb-1">Championship on the Line?</label><select id="edit-title-select" class="w-full bg-slate-800 border-slate-600 text-white p-2 rounded"><option value="">- None -</option></select></div>
            <div class="mb-3"><label class="block text-xs font-bold text-slate-500 uppercase mb-1">Headline (Participants)</label><input id="edit-headline" type="text" class="w-full bg-slate-800 border-slate-600 text-white p-2 rounded"></div>
        </div>

<div id="edit-ref-mgr-section" class="mt-3 pt-3 border-t border-slate-700">
    
    <div class="mb-3">
        <label class="block text-xs font-bold text-slate-500 uppercase mb-1">Special Guest Referee</label>
        <select id="edit-referee" class="w-full bg-slate-800 border-slate-600 text-white p-2 rounded">
            <option value="">- Standard Official -</option>
        </select>
    </div>

    <div class="mb-3">
        <label class="block text-xs font-bold text-slate-500 uppercase mb-1">Managers / Valets</label>
        <div id="edit-manager-container" class="space-y-2 mb-2"></div>
        
        <button type="button" onclick="addEditManagerSlot()" class="w-full py-2 border border-dashed border-slate-600 text-slate-500 text-xs hover:text-white hover:border-purple-500 rounded transition">
            <i class="fa-solid fa-plus mr-1"></i> Add Manager
        </button>
    </div>
</div>

        <div id="edit-booking-controls"><p class="text-xs text-slate-400 mb-2 uppercase font-bold tracking-widest">Booking Plans</p><div class="grid grid-cols-2 gap-4 mb-3"><div><label class="block text-xs font-bold text-slate-500 uppercase mb-1">Planned Winner</label><input id="edit-winner" type="text" class="w-full bg-slate-800 border-slate-600 text-white p-2 rounded"></div><div><label class="block text-xs font-bold text-slate-500 uppercase mb-1">Planned Finish</label><select id="edit-finish" class="w-full bg-slate-800 border-slate-600 text-white p-2 rounded"><option value="">- Select -</option><option value="Pinfall">Pinfall</option><option value="Submission">Submission</option><option value="DQ">DQ</option><option value="Count Out">Count Out</option></select></div></div></div>
        
        <div class="space-y-4 mt-4 border-t border-slate-700 pt-4">
            <div><label class="block text-xs font-bold text-green-500 uppercase mb-1"><i class="fa-solid fa-rocket mr-1"></i> Creative Push</label><textarea id="edit-creative-push" class="w-full bg-slate-800 border-slate-600 text-white p-2 rounded h-20 text-xs"></textarea></div>
            <div><label class="block text-xs font-bold text-yellow-500 uppercase mb-1"><i class="fa-solid fa-fire mr-1"></i> Key Spots</label><textarea id="edit-spots" class="w-full bg-slate-800 border-slate-600 text-white p-2 rounded h-20 text-xs"></textarea></div>
            <div><label class="block text-xs font-bold text-blue-400 uppercase mb-1"><i class="fa-solid fa-book mr-1"></i> Deep Context</label><textarea id="edit-notes" class="w-full bg-slate-800 border-slate-600 text-white p-2 rounded h-16 text-xs"></textarea></div>
            <div><label class="block text-xs font-bold text-red-500 uppercase mb-1"><i class="fa-solid fa-user-secret mr-1"></i> Backstage Notes</label><textarea id="edit-backstage" class="w-full bg-slate-800 border-slate-600 text-white p-2 rounded h-16 text-xs"></textarea></div>
        </div>

        <div class="flex gap-2 mt-4">
            <button onclick="document.getElementById('edit-segment-modal').classList.add('hidden')" class="flex-1 bg-slate-700 text-white py-2 rounded">Cancel</button>
            <button onclick="saveSegmentDetails()" class="flex-1 bg-blue-600 text-white py-2 rounded font-bold">Save Changes</button>
        </div>
    </div>
</div>

    <div id="show-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50"> 
        <div class="bg-slate-900 border border-slate-700 p-6 rounded-xl w-full max-w-md h-[90vh] overflow-y-auto"> 
            <h3 class="text-xl font-bold text-white mb-4" id="show-modal-title">Schedule Show</h3> 
            <input type="hidden" id="edit-show-id"> 
            <label class="text-xs font-bold text-slate-500">Date</label> <input id="show-date" type="date" class="w-full bg-slate-800 border-slate-600 text-white p-3 rounded mb-3"> 
            <label class="text-xs font-bold text-slate-500">Show Name</label> <input id="show-name" type="text" placeholder="e.g. Raw" class="w-full bg-slate-800 border-slate-600 text-white p-3 rounded mb-3"> 
            <label class="text-xs font-bold text-slate-500">Arena</label> <input id="show-arena" type="text" placeholder="Location" class="w-full bg-slate-800 border-slate-600 text-white p-3 rounded mb-3"> 
            
            <div class="grid grid-cols-2 gap-3 mb-4">
                <div><label class="text-xs font-bold text-slate-500">Show Logo</label><div class="flex gap-2 mt-1"><input type="file" id="show-logo-upload" class="w-full text-xs text-slate-400" accept="image/*"><button onclick="clearShowLogo()" class="text-xs text-red-500 hover:text-red-300" title="Remove Logo"><i class="fa-solid fa-trash"></i></button></div></div>
                <div><label class="text-xs font-bold text-slate-500">Theme Color</label><input type="color" id="show-color-picker" class="w-full h-8 bg-slate-800 border border-slate-600 rounded mt-1 p-1"></div>
            </div>
            <div class="mb-4 pt-4 border-t border-slate-700"><label class="block text-slate-400 text-xs font-bold uppercase mb-2">Broadcast Team</label><div class="space-y-3"><div><label class="text-[10px] text-slate-500 font-bold uppercase">Play-by-Play</label><div class="grid grid-cols-2 gap-2"><input id="comm-pbp-name" type="text" placeholder="Name" class="w-full bg-slate-800 border-slate-600 text-white p-2 rounded text-xs"><input id="comm-pbp-style" type="text" placeholder="Style" class="w-full bg-slate-800 border-slate-600 text-white p-2 rounded text-xs"></div></div><div><label class="text-[10px] text-slate-500 font-bold uppercase">Color Commentator</label><div class="grid grid-cols-2 gap-2"><input id="comm-color-name" type="text" placeholder="Name" class="w-full bg-slate-800 border-slate-600 text-white p-2 rounded text-xs"><input id="comm-color-style" type="text" placeholder="Style" class="w-full bg-slate-800 border-slate-600 text-white p-2 rounded text-xs"></div></div><div><label class="text-[10px] text-slate-500 font-bold uppercase">Interviewer</label><div class="grid grid-cols-2 gap-2"><input id="comm-int-name" type="text" placeholder="Name" class="w-full bg-slate-800 border-slate-600 text-white p-2 rounded text-xs"><input id="comm-int-style" type="text" placeholder="Style" class="w-full bg-slate-800 border-slate-600 text-white p-2 rounded text-xs"></div></div></div></div>

<div class="mb-4"><label class="text-slate-400 text-xs font-bold uppercase">Show Type</label><select id="show-recurrence" onchange="toggleRecurrenceFields(this.value)" class="w-full bg-slate-800 border-slate-600 text-white p-3 rounded mt-1"><option value="special">One Time (Special Event)</option><option value="weekly">Weekly (Repeat Weekly)</option></select></div> 

            <div id="annual-option-container" class="hidden mb-3 p-3 bg-slate-800 rounded border border-slate-600">
                <label class="flex items-center gap-2 cursor-pointer">
                    <input type="checkbox" id="show-is-annual" class="rounded bg-slate-700 border-slate-600 text-blue-600 w-4 h-4">
                    <span class="text-xs font-bold text-slate-300 uppercase">Repeat Annually (Schedule for Next Year)</span>
                </label>
            </div>

            <div id="brand-select-container" class="hidden mb-4 p-3 bg-slate-800 rounded border border-slate-600">
                <label class="text-slate-400 text-xs font-bold uppercase block mb-2">Hosting Brands (Roster Access)</label>
                <div id="brand-checkboxes" class="space-y-2 max-h-24 overflow-y-auto"></div>
            </div> 
            
            <div class="flex gap-2">
                <button onclick="document.getElementById('show-modal').classList.add('hidden')" class="flex-1 bg-slate-700 text-white py-3 rounded">Cancel</button>
                <button onclick="saveShowToCalendar()" class="flex-1 bg-blue-600 text-white py-3 rounded font-bold">Save</button>
            </div>
</div></div>
    <div id="upload-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50"> <div class="bg-slate-900 border border-slate-700 p-6 rounded-xl w-full max-w-md"> <h3 class="text-xl font-bold text-white mb-4">Scan Image</h3> <input type="hidden" id="upload-context"> <div id="upload-roster-options" class="hidden"> <div class="mb-4"> <label class="text-slate-400 text-xs font-bold uppercase">Target Division</label> <select id="upload-division" class="w-full bg-slate-800 border-slate-600 text-white p-3 rounded mt-1"></select> </div> <div class="mb-4"> <label class="text-slate-400 text-xs font-bold uppercase">Action</label> <select id="upload-action" class="w-full bg-slate-800 border-slate-600 text-white p-3 rounded mt-1"> <option value="append">Add to existing list</option> <option value="overwrite">Overwrite list</option> </select> </div> </div> <div class="mb-4"> <label class="text-slate-400 text-xs font-bold uppercase">Image File</label> <input type="file" id="upload-file" class="w-full text-slate-400 mt-1" accept="image/*"> </div> <div class="flex gap-2"> <button onclick="document.getElementById('upload-modal').classList.add('hidden')" class="flex-1 bg-slate-700 text-white py-3 rounded">Cancel</button> <button onclick="processUpload()" class="flex-1 bg-green-600 text-white py-3 rounded font-bold">Scan & Import</button> </div> </div> </div>
    <div id="manual-roster-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50"> <div class="bg-slate-900 border border-slate-700 p-6 rounded-xl w-full max-w-md"> <h3 class="text-xl font-bold text-white mb-4">Add Wrestler</h3> <input id="manual-name" type="text" placeholder="Wrestler Name" class="w-full bg-slate-800 border-slate-600 text-white p-3 rounded mb-3"> <label class="text-slate-400 text-xs font-bold uppercase">Assign To Show</label> <select id="manual-show" class="w-full bg-slate-800 border-slate-600 text-white p-3 rounded mb-3"></select> <label class="text-slate-400 text-xs font-bold uppercase">Division</label> <select id="manual-division" class="w-full bg-slate-800 border-slate-600 text-white p-3 rounded mb-4"> <option value="0">Slot 1</option><option value="1">Slot 2</option><option value="2">Slot 3</option> <option value="3">Slot 4</option><option value="4">Slot 5</option><option value="5">Slot 6</option><option value="6">Slot 7</option> </select> <div class="flex gap-2"><button onclick="document.getElementById('manual-roster-modal').classList.add('hidden')" class="flex-1 bg-slate-700 text-white py-3 rounded">Cancel</button><button onclick="saveManualRoster()" class="flex-1 bg-blue-600 text-white py-3 rounded font-bold">Add</button></div> </div> </div>
    <div id="day-detail-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50">
    <div class="bg-slate-900 border border-slate-700 p-6 rounded-xl w-full max-w-md shadow-2xl">
        
        <div class="flex justify-between items-center mb-4 border-b border-slate-700 pb-3">
            <h3 id="day-detail-date" class="text-xl font-bold text-white">Date</h3>
            <button onclick="document.getElementById('day-detail-modal').classList.add('hidden')" class="text-slate-400 hover:text-white px-2">
                <i class="fa-solid fa-xmark fa-lg"></i>
            </button>
        </div>

        <div id="day-sim-warning" class="hidden mb-4 p-3 rounded border border-yellow-700/50 bg-yellow-900/20 text-yellow-200 text-xs leading-relaxed shadow-inner"></div>

        <div id="sim-btn-container" class="mb-4">
            <button id="btn-sim-through-date"
        onclick="simulateAllShowsThroughDate(document.getElementById('day-detail-modal').dataset.date)"
        class="w-full bg-gradient-to-r from-red-700 to-red-600 hover:from-red-600 hover:to-red-500 text-white text-xs font-bold py-3 rounded shadow-lg flex items-center justify-center gap-2 border border-red-500/30 transition transform hover:scale-[1.02]">
    <i class="fa-solid fa-forward-fast"></i> Simulate Shows To This Date
</button>
        </div>

        <div id="day-show-list" class="space-y-2 mb-4 max-h-[300px] overflow-y-auto pr-1"></div>

        <button onclick="openShowModalFromDetail()" class="w-full border border-dashed border-slate-600 text-slate-400 py-3 rounded text-sm hover:text-white hover:border-slate-400 hover:bg-slate-800 transition flex items-center justify-center gap-2">
            <i class="fa-solid fa-plus"></i> Add Show to this Date
        </button>

    </div>
</div>
    <div id="delete-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50"> 
    <div class="bg-slate-900 border border-slate-700 p-6 rounded-xl w-full max-w-sm"> 
        <h3 class="text-xl font-bold text-white mb-4">Delete Show</h3> 
        <p class="text-slate-400 mb-6">How do you want to remove this series?</p> 
        <div class="space-y-2"> 
            <button onclick="confirmDelete('single')" class="w-full bg-slate-700 text-white py-3 rounded hover:bg-slate-600">Delete Just This Date</button> 
            <button onclick="confirmDelete('future')" class="w-full bg-orange-700 text-white py-3 rounded hover:bg-orange-600 font-bold">Delete From Here Forward</button> 
            <button onclick="confirmDelete('all')" class="w-full bg-red-600 text-white py-3 rounded hover:bg-red-500 font-bold">Delete Entire Series</button> 
            <button onclick="document.getElementById('delete-modal').classList.add('hidden')" class="w-full text-slate-500 text-sm py-2">Cancel</button> 
        </div> 
    </div> 
</div>

<div id="extend-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50">
    <div class="bg-slate-900 border border-slate-700 p-6 rounded-xl w-full max-w-lg max-h-[90vh] flex flex-col">
        <div class="mb-4 border-b border-slate-700 pb-2">
            <h3 class="text-xl font-bold text-white">Extend Timeline</h3>
            <p class="text-xs text-slate-400">Generate schedule for the following year.</p>
        </div>
        
        <div class="grid grid-cols-2 gap-4 mb-4">
            <div>
                <label class="block text-xs font-bold text-slate-500 uppercase mb-1">Source Year</label>
                <input id="extend-source-year" type="number" class="w-full bg-slate-800 border border-slate-600 text-white p-2 rounded" readonly>
            </div>
            <div>
                <label class="block text-xs font-bold text-green-500 uppercase mb-1">Target Year</label>
                <input id="extend-target-year" type="number" class="w-full bg-slate-800 border border-green-600 text-white p-2 rounded font-bold" readonly>
            </div>
        </div>

        <div class="flex-1 overflow-y-auto mb-4 bg-slate-800 p-3 rounded border border-slate-700">
            <div class="flex justify-between items-center mb-2 pb-2 border-b border-slate-600">
                <span class="text-xs font-bold text-slate-400 uppercase">Select Shows to Clone</span>
                <button onclick="toggleExtendCheckboxes(true)" class="text-xs text-blue-400 hover:text-white">Select All</button>
            </div>
            <div id="extend-show-list" class="space-y-2">
                </div>
        </div>

        <div class="flex gap-2">
            <button onclick="document.getElementById('extend-modal').classList.add('hidden')" class="flex-1 bg-slate-700 text-white py-3 rounded">Cancel</button>
            <button onclick="processExtension()" class="flex-1 bg-green-600 hover:bg-green-500 text-white py-3 rounded font-bold shadow-lg">Generate Schedule</button>
        </div>
    </div>
</div>
    <div id="report-modal" class="hidden fixed inset-0 bg-black/90 flex items-center justify-center z-50"> <div class="bg-slate-800 border border-slate-600 rounded-xl w-full max-w-4xl h-5/6 flex flex-col overflow-hidden"> <div class="bg-slate-900 p-4 border-b border-slate-600 flex justify-between items-center"><h3 class="text-xl font-bold text-white">Generating Report...</h3><button onclick="document.getElementById('report-modal').classList.add('hidden')" class="text-slate-400 hover:text-white"><i class="fa-solid fa-xmark"></i></button></div> <div class="flex-1 bg-slate-200 overflow-y-auto p-8 relative"> <div id="report-loading" class="absolute inset-0 flex flex-col items-center justify-center bg-slate-100 z-10">
    <i class="fa-solid fa-circle-notch fa-spin text-4xl text-red-600 mb-4"></i>
    <p class="text-slate-600 font-bold">Printing...</p>
    <p id="report-countdown" class="text-xs text-slate-400 mt-2 font-mono">Estimated wait: 2m 00s</p>
</div> <div id="report-preview-body" class="magazine-container shadow-lg min-h-full"></div> </div> <div class="bg-slate-900 p-4 flex justify-end gap-3"><button onclick="document.getElementById('poster-upload').click()" class="px-4 py-2 bg-purple-700 hover:bg-purple-600 text-white font-bold rounded"><i class="fa-solid fa-image mr-2"></i> Add Poster</button><input type="file" id="poster-upload" class="hidden" accept="image/*" onchange="addPosterToReport()"><button onclick="publishAndArchive()" id="btn-publish" class="px-6 py-2 bg-green-600 text-white font-bold rounded" disabled>Publish & Advance</button></div> </div> </div>
    <div id="nav-date-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50"> <div class="bg-slate-900 border border-slate-700 p-6 rounded-xl w-full max-w-sm"> <h3 class="text-xl font-bold text-white mb-4">Jump to Date</h3> <div class="space-y-3"> <select id="jump-month" class="w-full bg-slate-800 border-slate-600 text-white p-3 rounded"> <option value="1">January</option><option value="2">February</option><option value="3">March</option><option value="4">April</option><option value="5">May</option><option value="6">June</option><option value="7">July</option><option value="8">August</option><option value="9">September</option><option value="10">October</option><option value="11">November</option><option value="12">December</option> </select> <input id="jump-year" type="number" placeholder="Year" class="w-full bg-slate-800 border-slate-600 text-white p-3 rounded"> <button onclick="jumpToDate()" class="w-full bg-blue-600 py-2 text-white font-bold rounded hover:bg-blue-500">Go</button> <button onclick="document.getElementById('nav-date-modal').classList.add('hidden')" class="w-full text-slate-500 text-sm mt-2">Cancel</button> </div> </div> </div>

<div id="rivalry-pick-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50">
    <div class="bg-slate-900 border border-slate-700 p-6 rounded-xl w-full max-w-sm">
        <h3 class="text-white font-bold mb-4">Add to Faction</h3>
        <select id="riv-wrestler-select" class="w-full bg-slate-800 border-slate-600 text-white p-3 rounded mb-4"></select>
        <div class="flex gap-2">
            <button onclick="document.getElementById('rivalry-pick-modal').classList.add('hidden')" class="flex-1 bg-slate-700 text-white py-2 rounded">Cancel</button>
            <button onclick="confirmRivalryMember()" class="flex-1 bg-blue-600 text-white py-2 rounded font-bold">Add</button>
        </div>
    </div>
</div>

    <script>
// 1. Initialize Dexie Database
const db = new Dexie("InsideCountDB");
db.version(1).stores({
    saves: "id, name, era" // Primary key is 'id', indexed for fast searching
});
       
 const ERA_CONFIG = { 
    territories: { 
        system: "You are booking in the Territories Era (1948–1982). LOGIC: Wrestling is presented as a legitimate sport. Kayfabe is strict. TV matches are mostly squash matches or time-limit draws. Big matches happen only at big arena shows. FINISHES: Faces win clean. Heels cheat or get DQ'd to save titles. 50/50 booking does not exist. PROMOS: Intense, unscripted, and protect the business." 
    }, 
    golden: { 
        system: "You are booking in the Golden Era (1982–1993). LOGIC: Wrestling is a cartoon come to life. Characters are larger than life (superheroes vs monsters). TV is for squash matches and angle advancement. PPVs are for the payoffs. FINISHES: Top stars almost NEVER lose on TV. Villains win via devious cheating. PROMOS: High energy, shouty, and catchphrase-heavy." 
    }, 
    new_generation: { 
        system: "You are booking in the New Generation Era (1993–1997). LOGIC: The steroids are gone, and smaller, athletic technicians take center stage. Characters are often occupational gimmicks (trash men, clowns, race drivers). The product is trying to be edgy but is still cartoons for kids. FINISHES: Technical wrestling is emphasized. The underdog babyface is the primary protagonist archetype." 
    },
    attitude: { 
        system: "You are booking in the Attitude Era (1997–2002). LOGIC: Crash TV. Short matches, constant brawls, and shock value. Storylines move at breakneck speed. Everyone is an anti-hero. FINISHES: Clean finishes are RARE on TV. Expect interference, ref bumps, and swerves in almost every main event. Titles change hands frequently. PROMOS: Edgy, controversial, and long." 
    }, 
    ruthless: { 
        system: "You are booking in the Ruthless Aggression Era (2002–2008). LOGIC: A hybrid of Attitude Era drama and athletic realism. The 'Smackdown Six' style of high workrate is emerging. Brand splits are rigid. New stars are being built through grit. FINISHES: Competitive matches with clean finishes becoming common again, but heels still cheat. PROMOS: Intense and aggressive." 
    }, 
    pg: { 
        system: "You are booking in the PG Era (2008–2014). LOGIC: Corporate, family-friendly entertainment. No blood, no swearing, no edge. The 'Super Cena' booking style prevails (the top face overcomes all odds). Guest hosts and comedy segments are frequent. FINISHES: Heels look weak/cowardly. Faces look strong. 50/50 booking is common to protect everyone." 
    }, 
    reality: { 
        system: "You are booking in the Reality Era (2014–2022). LOGIC: The 'Indie Invasion'. Fans are smart to the business. Workrate is king. Storylines often blur the lines between script and real-life contract issues. NXT style presentation influences the main roster. FINISHES: High false-count kickouts. Clean finishes are preferred for 5-star matches." 
    }, 
    current: { 
        system: "You are booking in the Current Era (2022–Present). LOGIC: 'Cinema' and Long-Term Storytelling. Arcs play out over months, not weeks. Factions are dominant. Championships are prestigious and reigns are long. Matches are treated as serious athletic contests with high production value. FINISHES: Protected finishes. Clean wins matter. Interference is usually plot-heavy, not random." 
    } 
};

        // --- GLOBAL VARIABLES ---
        let currentSave = null;
        let currentSaveId = null;
        let activeShow = null;
	let reportTimer = null; 
        let viewDate = new Date(); 
        let deleteTargetId = null;
        let draggedWrestlerId = null;
        let rosterFilter = 'all'; 
        let rankingFilter = 'global';
        let rankingMode = 'manual';
        let cardData = [];
        let generatedReportHTML = ""; 
        let logoRemoved = false; 
        let viewingArchiveId = null; 

       // --- UPDATED IMAGE READER (SMART TRANSPARENCY) ---
        function readImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const MAX_WIDTH = 600; 
                        
                        let width = img.width;
                        let height = img.height;

                        // 1. COMPRESSION STEP 1: RESIZING (KEPT)
                        if (width > MAX_WIDTH) {
                            height *= MAX_WIDTH / width;
                            width = MAX_WIDTH;
                        }

                        canvas.width = width;
                        canvas.height = height;
                        
                        const ctx = canvas.getContext('2d');
                        
                        // Clear canvas to ensure transparency works
                        ctx.clearRect(0, 0, width, height);
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        // 2. COMPRESSION STEP 2: FORMATTING (CONDITIONAL)
                        if (file.type === 'image/png') {
                            // PNG: No quality loss, preserves transparency
                            resolve(canvas.toDataURL('image/png'));
                        } else {
                            // OTHERS (JPG): Applies 0.7 compression (KEPT)
                            resolve(canvas.toDataURL('image/jpeg', 0.7));
                        }
                    };
                    img.onerror = (e) => reject(e);
                };
                reader.onerror = (error) => reject(error);
            });
        }

        // --- SAFE STRING ESCAPE ---
        function escapeStr(str) {
            if (str === null || str === undefined) return "";
            return String(str).replace(/'/g, "\\'").replace(/"/g, '&quot;');
        }

        window.onload = function() {
            const params = new URLSearchParams(window.location.search);
            currentSaveId = params.get('id');
            const key = localStorage.getItem('openai_key');
            if(key) document.getElementById('api-key-input').value = key;
            if(!currentSaveId) { window.location.href = 'index.html'; return; }
            loadSaveData();
        };

    async function loadSaveData() {
    // 1. Check IndexedDB for the save first
    currentSave = await db.saves.get(String(currentSaveId));
    
    // 2. Fallback: If not in DB, check old LocalStorage for migration
    if (!currentSave) {
        const oldSaves = JSON.parse(localStorage.getItem('insideCountSaves') || '[]');
        currentSave = oldSaves.find(s => String(s.id) === String(currentSaveId));
        
        if (currentSave) {
            console.log("Migrating save to IndexedDB...");
            await db.saves.put(currentSave); 
        }
    }
    
    if (!currentSave) {
        alert("Error: Save file not found.");
        window.location.href = 'index.html'; 
        return;
    }
    
    // Maintain your existing data initializations
    if(!currentSave.shows) currentSave.shows = [];
    if(!currentSave.history) currentSave.history = [];
    if(!currentSave.roster) currentSave.roster = [];
    if(!currentSave.showDivisions) currentSave.showDivisions = {};
    if(!currentSave.powerRankings) currentSave.powerRankings = { global: { manual: [], ai: [] } };
    if(!currentSave.seriesConfig) currentSave.seriesConfig = {};
    if(!currentSave.beltImages) currentSave.beltImages = {};
    if(!currentSave.settings) currentSave.settings = { capEnabled: false, capLimit: 50 };

    // --- FIX: Correctly call the initialization here ---
    initRatingsSystem(); 
    // --------------------------------------------------

    document.getElementById('display-universe-name').innerText = currentSave.name;
    document.getElementById('display-era-name').innerText = currentSave.era.toUpperCase();
    
  const oldestEditable = [...currentSave.shows]
    .sort((a, b) => new Date(a.date) - new Date(b.date))
    .find(s => s.status !== 'completed'); // Editable = not completed

if (oldestEditable) {
    const [y, m, d] = oldestEditable.date.split('-').map(Number);
    viewDate = new Date(y, m - 1, d);
}


    
    renderCalendar();
    renderArchiveList();

    // Initialize System Rankings for Dual-View Support
    currentSave.roster.forEach((w, i) => {
        if (w.systemDivision === undefined) w.systemDivision = w.division;
        if (w.systemRank === undefined) w.systemRank = (w.rank !== undefined) ? w.rank : i;
    });

    renderRoster();
}

       async function saveGame() {
    try {
        await db.saves.put(currentSave);
        console.log(`Game saved to IndexedDB at ${new Date().toLocaleTimeString()}`);
    } catch (e) {
        console.error("Database Error:", e);
        alert("Critical Save Error: " + e.message);
    }
}

// --- NEW: ROSTER CAP SETTINGS LOGIC ---
function loadSettingsUI() {
    if(!currentSave.settings) currentSave.settings = { capEnabled: false, capLimit: 50 };
    
    const settings = currentSave.settings;
    document.getElementById('setting-cap-toggle').checked = settings.capEnabled;
    document.getElementById('setting-cap-limit').value = settings.capLimit;
    
    // --- NEW: Per-Show Breakdown ---
    const uniqueShows = [...new Set(currentSave.shows.filter(s => s.type === 'weekly').map(s => s.name))];
    let breakdownHtml = `<div class="flex flex-col gap-1 w-full">`;
    
    // 1. Free Agents (Always Unlimited)
    const freeCount = currentSave.roster.filter(w => !w.shows).length;
    breakdownHtml += `<div class="flex justify-between text-[10px] text-slate-400 border-b border-slate-700 pb-1"><span>Free Agents</span> <span>${freeCount} (No Limit)</span></div>`;
    
    // 2. Weekly Shows
    uniqueShows.forEach(s => {
        const count = currentSave.roster.filter(w => w.shows === s).length;
        // Turn Red if over limit
        const colorClass = (settings.capEnabled && count >= settings.capLimit) ? 'text-red-500 font-bold' : 'text-slate-300';
        breakdownHtml += `<div class="flex justify-between text-xs ${colorClass}"><span>${s}</span> <span>${count} / ${settings.capLimit}</span></div>`;
    });
    breakdownHtml += `</div>`;

    // Inject into the counter element
    const counterEl = document.getElementById('current-roster-count');
    counterEl.className = "bg-slate-900 p-3 rounded border border-slate-700 mt-2 block h-auto"; // Remove 'flex center' classes
    counterEl.innerHTML = breakdownHtml;
    // -------------------------------
    
    const container = document.getElementById('cap-limit-container');
    if(settings.capEnabled) container.classList.remove('opacity-50', 'pointer-events-none');
    else container.classList.add('opacity-50', 'pointer-events-none');
}
function saveGameplaySettings() {
    const enabled = document.getElementById('setting-cap-toggle').checked;
    const limit = parseInt(document.getElementById('setting-cap-limit').value) || 50;
    
    currentSave.settings.capEnabled = enabled;
    currentSave.settings.capLimit = limit;
    
    saveGame();
    loadSettingsUI(); // Refresh UI to update opacity/counts
}

        // --- CALENDAR LOGIC ---
        function renderCalendar() { 
            const grid = document.getElementById('calendar-body'); 
            grid.innerHTML = ''; 
            const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]; 
            document.getElementById('calendar-month-display').innerText = `${monthNames[viewDate.getMonth()]} ${viewDate.getFullYear()}`; 
            
            const year = viewDate.getFullYear(); 
            const month = viewDate.getMonth(); 
            const firstDayIndex = new Date(year, month, 1).getDay(); 
            const emptySlots = (firstDayIndex + 6) % 7; 
            const daysInMonth = new Date(year, month + 1, 0).getDate(); 
            
            for(let i=0; i<emptySlots; i++) grid.innerHTML += `<div class="calendar-day empty"></div>`; 
            
            for(let d=1; d<=daysInMonth; d++) { 
                const dateStr = `${year}-${String(month+1).padStart(2, '0')}-${String(d).padStart(2, '0')}`; 
                const showsOnDate = currentSave.shows.filter(s => s.date === dateStr); 
                let pillsHTML = ''; 
                
                showsOnDate.forEach(s => { 
                    let statusClass = s.status === 'completed' ? 'pill-completed' : (s.type === 'special' ? 'pill-special' : 'pill-planned'); 
                    let hostInfo = ''; 
                    if(s.type === 'special' && s.participatingShows && s.participatingShows.length > 0) { 
                        hostInfo = `<span class="text-[9px] text-slate-400 block -mt-1">Hosting: ${s.participatingShows.join(', ')}</span>`; 
                    }
                    let style = s.color ? `style="border-left-color: ${s.color};"` : ''; 
                    pillsHTML += `<div class="show-pill ${statusClass}" ${style}>${s.name} ${hostInfo}</div>`; 
                }); 
                
                let todayClass = (new Date().toISOString().split('T')[0] === dateStr) ? 'today' : ''; 
                grid.innerHTML += `<div onclick="openDayDetail('${dateStr}')" class="calendar-day ${todayClass} group"><div class="flex justify-between items-start mb-1"><span class="text-slate-400 text-xs font-bold group-hover:text-white">${d}</span></div><div class="space-y-1">${pillsHTML}</div></div>`; 
            } 
        }

       function switchMainView(viewId, btnElement) { 
    // 1. Hide all views, Show target view
    document.querySelectorAll('.main-view').forEach(el => el.classList.add('hidden-view')); 
    document.getElementById('view-' + viewId).classList.remove('hidden-view'); 

    // 2. Handle Dashboard Controls (Only show on Planner)
    if(viewId === 'dashboard') { 
        if(!activeShow) { 
            alert("Select a show from the Calendar."); 
            switchMainView('calendar'); 
            return; 
        } 
        document.getElementById('dashboard-controls').classList.remove('hidden'); 
    } else { 
        document.getElementById('dashboard-controls').classList.add('hidden'); 
    } 

    // 3. Render View-Specific Data

    // --- ROSTER VIEW (With Persistence) ---
    if(viewId === 'roster') { 
        renderRosterSidebar(); 
        
        // Restore Saved Mode (Manual vs System)
        if(currentSave.settings && currentSave.settings.lastRosterMode) {
            rosterViewMode = currentSave.settings.lastRosterMode;
        }
        
        // Update the button colors to match the mode we just loaded
        updateRosterModeButtons(); 
        renderRoster(); 
    }
    
    // --- RANKINGS VIEW (With Persistence) ---
    if(viewId === 'rankings') { 
        // Restore last used Filter (Global vs Show)
        if(currentSave.settings && currentSave.settings.lastRankFilter) {
            rankingFilter = currentSave.settings.lastRankFilter;
        }
        // Restore last used Mode (Manual vs System)
        if(currentSave.settings && currentSave.settings.lastRankMode) {
            rankingMode = currentSave.settings.lastRankMode;
            
            // Update Radio Buttons to match
            const radios = document.getElementsByName('rank-mode');
            radios.forEach(r => {
                if(r.value === rankingMode) r.checked = true;
            });
            // Update the Badge to match
            toggleRankingMode(); 
        }
        
        renderRankingSidebar(); 
        renderRankings(); 
    }

    if(viewId === 'settings') { loadSettingsUI(); }
    
    // --- RIVALRIES VIEW ---
    if(viewId === 'rivalries') { renderRivalryList(); } 

    // 4. Update Sidebar Buttons (Highlight the active tab)
    document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active')); 
    if(btnElement) btnElement.classList.add('active'); 
}


        function changeMonth(delta) { viewDate.setMonth(viewDate.getMonth() + delta); renderCalendar(); }
        function jumpToDate() { const m = parseInt(document.getElementById('jump-month').value); const y = parseInt(document.getElementById('jump-year').value); if(m && y) { viewDate.setMonth(m - 1); viewDate.setFullYear(y); renderCalendar(); document.getElementById('nav-date-modal').classList.add('hidden'); } }
        
        function openDayDetail(dateStr) {
            const [y, m, d] = dateStr.split('-').map(Number);
            const dateObj = new Date(y, m - 1, d);
            document.getElementById('day-detail-date').innerText = dateObj.toDateString();
            document.getElementById('day-detail-modal').classList.remove('hidden');
            document.getElementById('day-detail-modal').dataset.date = dateStr;
const warningEl = document.getElementById('day-sim-warning');
const prior = getUnplayedShowsBefore(dateStr);

if (warningEl) {
  if (prior.length > 0) {
    const preview = prior.slice(0, 4).map(s => `${s.date} — ${s.name}`).join("<br>");
    warningEl.innerHTML =
      `<strong>⚠ Unplayed shows exist before this date.</strong><br>` +
      `Simulating through this date will also simulate earlier unplayed shows.<br><br>` +
      `${preview}${prior.length > 4 ? `<br>… (+${prior.length - 4} more)` : ""}`;
    warningEl.classList.remove('hidden');
  } else {
    warningEl.classList.add('hidden');
    warningEl.innerHTML = "";
  }
} 
            const container = document.getElementById('day-show-list');
            container.innerHTML = '';
            const shows = currentSave.shows.filter(s => s.date === dateStr);
            if(shows.length === 0) container.innerHTML = `<div class="text-slate-500 italic text-sm">No shows scheduled.</div>`;
            shows.forEach(s => {
                let icon = s.status === 'completed' ? 'fa-check text-green-500' : 'fa-clock text-slate-500';
                let btnLabel = s.status === 'completed' ? 'View Archive Data' : 'Manage Show';
                let safeId = escapeStr(s.id); 
                container.innerHTML += `<div class="bg-slate-800 p-3 rounded border border-slate-700 mb-2"><div class="flex justify-between items-center mb-2"><div class="font-bold text-white text-sm"><i class="${icon} mr-2"></i>${s.name} (${s.type})</div><div class="flex gap-2"><button onclick="editShow('${safeId}')" class="text-slate-400 hover:text-white"><i class="fa-solid fa-pencil"></i></button><button onclick="askDeleteShow('${safeId}')" class="text-slate-400 hover:text-red-500"><i class="fa-solid fa-trash"></i></button></div></div><button onclick="loadShow('${safeId}')" class="w-full bg-slate-700 hover:bg-slate-600 text-xs py-1 rounded border border-slate-600">${btnLabel}</button></div>`;
            });
        }
        function openShowModalFromDetail() { const dateStr = document.getElementById('day-detail-modal').dataset.date; if(dateStr) { openShowModal(dateStr); document.getElementById('day-detail-modal').classList.add('hidden'); } }

        function loadShow(showId) {
            activeShow = currentSave.shows.find(s => String(s.id) === String(showId));
            if(!activeShow) { alert("Error: Show not found."); return; }
            
            cardData = activeShow.segments || [];
            document.getElementById('day-detail-modal').classList.add('hidden');
            document.getElementById('header-show-name').innerText = activeShow.name.toUpperCase();
            const [y, m, d] = activeShow.date.split('-').map(Number);
            document.getElementById('header-date-info').innerText = new Date(y, m - 1, d).toDateString();
            
            const headerLogo = document.getElementById('header-show-logo');
            const headerOverlay = document.getElementById('header-bg-overlay');
            
            // --- FIX: CHECK CENTRAL SERIES CONFIG FOR LOGO ---
            let displayLogo = activeShow.logo;
            if (!displayLogo && activeShow.type === 'weekly' && currentSave.seriesConfig && currentSave.seriesConfig[activeShow.name] && currentSave.seriesConfig[activeShow.name].logo) {
                displayLogo = currentSave.seriesConfig[activeShow.name].logo;
            }

            if(displayLogo) { headerLogo.src = displayLogo; headerLogo.classList.remove('hidden'); } else { headerLogo.classList.add('hidden'); }
            if(activeShow.color) { headerOverlay.style.backgroundColor = activeShow.color; } else { headerOverlay.style.backgroundColor = 'transparent'; }

            const sortedShows = currentSave.shows.slice().sort((a,b) => new Date(a.date) - new Date(b.date));
            const currentIndex = sortedShows.findIndex(s => s.id === activeShow.id);
            const btnPrev = document.getElementById('btn-prev-show');
            const btnNext = document.getElementById('btn-next-show');
            if(currentIndex > 0) { btnPrev.classList.remove('hidden'); btnPrev.title = `Go to ${sortedShows[currentIndex - 1].name}`; } else { btnPrev.classList.add('hidden'); }
            if(currentIndex < sortedShows.length - 1) { btnNext.classList.remove('hidden'); btnNext.title = `Go to ${sortedShows[currentIndex + 1].name}`; } else { btnNext.classList.add('hidden'); }

            let rosterPoolNames = [];
            if(activeShow.type === 'special' && activeShow.participatingShows && activeShow.participatingShows.length > 0) {
                rosterPoolNames = activeShow.participatingShows;
                document.getElementById('header-roster-pool').innerText = "Roster Source: " + rosterPoolNames.join(', ');
            } else if (activeShow.type === 'weekly') {
                document.getElementById('header-roster-pool').innerText = "Roster Source: " + activeShow.name;
            } else {
                document.getElementById('header-roster-pool').innerText = "Using Open Roster";
            }

            const sidebar = document.getElementById('broadcast-team-sidebar');
            const list = document.getElementById('broadcast-team-list');
            const liveHeader = document.getElementById('live-commentary-display');
            let displayComms = activeShow.commentators;
            if (!displayComms && activeShow.type === 'weekly' && currentSave.seriesConfig && currentSave.seriesConfig[activeShow.name]) {
                displayComms = currentSave.seriesConfig[activeShow.name].commentators;
            }
            if (displayComms && (displayComms.pbp.name || displayComms.color.name || displayComms.interviewer.name)) {
                sidebar.classList.remove('hidden');
                let html = '';
                let liveText = [];
                if(displayComms.pbp.name) { html += `<div class="text-[10px] text-slate-400">PLAY-BY-PLAY</div><div class="text-xs text-white font-bold mb-1">${displayComms.pbp.name}</div>`; liveText.push(displayComms.pbp.name); }
                if(displayComms.color.name) { html += `<div class="text-[10px] text-slate-400">COLOR</div><div class="text-xs text-white font-bold mb-1">${displayComms.color.name}</div>`; liveText.push(displayComms.color.name); }
                if(displayComms.interviewer.name) html += `<div class="text-[10px] text-slate-400">INTERVIEWER</div><div class="text-xs text-white font-bold">${displayComms.interviewer.name}</div>`;
                list.innerHTML = html;
                liveHeader.innerText = "🎙 " + liveText.join(' & ');
            } else {
                sidebar.classList.add('hidden');
                liveHeader.innerText = "";
            }

            if (activeShow.status === 'completed') {
                document.getElementById('status-badge').innerText = "ARCHIVED";
                document.getElementById('status-badge').className = "bg-green-600 text-white text-xs font-bold px-2 py-1 rounded";
                document.getElementById('planner-actions').classList.add('hidden');
                document.getElementById('live-actions').classList.add('hidden');
                document.getElementById('completed-actions').classList.remove('hidden');
                document.getElementById('planner-tools-container').classList.add('hidden');
                document.getElementById('btn-add-manual-segment').classList.add('hidden');
                document.getElementById('btn-view-report').classList.remove('hidden');
            } else {
                document.getElementById('status-badge').innerText = "PLANNING";
                document.getElementById('status-badge').className = "bg-blue-600 text-white text-xs font-bold px-2 py-1 rounded";
                document.getElementById('planner-actions').classList.remove('hidden');
                document.getElementById('live-actions').classList.add('hidden');
                document.getElementById('completed-actions').classList.add('hidden');
                document.getElementById('planner-tools-container').classList.remove('hidden');
                document.getElementById('btn-add-manual-segment').classList.remove('hidden');
            }

            if(activeShow.status !== 'completed') exitLiveShow(); 
            renderPlanner(); 
            switchMainView('dashboard');
        }

        // --- HELPER: Get Titles for current show ---
        function getAvailableTitles() {
            if (!activeShow) return [];
            let showKey = activeShow.name;
            if (currentSave.showDivisions[showKey]) return currentSave.showDivisions[showKey];
            return ["Division 1", "Division 2", "Division 3", "Division 4", "Division 5", "Division 6", "Division 7"];
        }

function renderPlanner() {
    const container = document.getElementById('planner-container');
    container.innerHTML = '';
    
    const isReadOnly = (activeShow && activeShow.status === 'completed');
    
    if(cardData.length === 0) { 
        container.innerHTML = `<div class="text-slate-500 italic text-center p-10 border-2 border-dashed border-slate-800 rounded opacity-50">Card is empty. Add a segment.</div>`; 
        return; 
    }
    
    // --- 1. PRE-FETCH RIVALRY DATA ---
    const allRivalries = [...(currentSave.rivalries || []), ...(currentSave.archivedRivalries || [])];

    cardData.forEach((seg, index) => {
        // A. Rivalry Check
        let isRivalry = false;
        if (seg.participants && allRivalries.length > 0) {
            isRivalry = allRivalries.some(r => {
                const members = r.sides.flat();
                const overlap = seg.participants.filter(p => members.includes(p));
                return overlap.length >= 2;
            });
        }
        const rivalryIcon = isRivalry ? `<span class="ml-2 text-red-500 animate-pulse" title="Rivalry Match"><i class="fa-solid fa-handshake-slash"></i></span>` : '';

        // B. Colors & Icons
        let colorClass = seg.type === 'match' ? 'border-red-500' : 'border-blue-500';
        let iconClass = seg.type === 'match' ? 'fa-hand-fist text-red-500' : 'fa-microphone text-blue-500';
        let typeLabel = seg.type === 'match' ? (seg.match_type || 'MATCH') : 'SEGMENT';
        if(seg.stipulation) typeLabel += ` • ${seg.stipulation}`;
        
        // --- C. MAIN CONTENT (Wrestler Names) ---
        let mainContent = '';
        if(seg.participants && Array.isArray(seg.participants) && seg.participants.length > 0) {
            const formattedNames = seg.participants.map(p => {
                if (isReadOnly && seg.actual_winner === p) {
                    return `<span class="text-green-400 font-black drop-shadow-[0_0_5px_rgba(74,222,128,0.5)] border-b-2 border-green-500">${p}</span>`;
                }
                return `<span class="text-white">${p}</span>`;
            }).join(' <span class="text-slate-500 text-sm font-normal align-middle mx-1 opacity-60">vs.</span> ');

            mainContent = `<div class="text-xl md:text-2xl font-black uppercase leading-none tracking-tight drop-shadow-md my-1">${formattedNames}</div>`;
        } else {
            mainContent = `<div class="text-xl font-black text-white uppercase leading-none tracking-tight">${seg.title}</div>`;
        }
        
        // --- D. STAT BADGES (Collapsed View) ---
        let statsBadges = '';
        
        // 1. Star Rating (Quality) - "4.5 ★"
        if (seg.stars) {
            statsBadges += `<span class="bg-yellow-900/40 text-yellow-400 text-[10px] font-bold px-2 py-1 rounded border border-yellow-700/50 ml-2" title="Match Quality">★ ${seg.stars}</span>`;
        }
        
        // 2. Nielsen Rating (TV) - "📺 4.2"
        if (seg.rating && seg.rating !== "0.00") {
            statsBadges += `<span class="bg-slate-900 text-blue-300 text-[10px] font-mono px-2 py-1 rounded border border-slate-600 ml-2" title="TV Rating">📺 ${seg.rating}</span>`;
        }

let extraInfo = '';
        if (seg.managers) {
            extraInfo += `<span class="text-xs text-purple-400 font-bold ml-2 border-l border-slate-600 pl-2">w/ ${seg.managers}</span>`;
        }
        if (seg.special_referee) {
            extraInfo += `<span class="ml-2 bg-slate-950 text-white border border-slate-500 text-[9px] px-1 rounded uppercase tracking-wider shadow-sm">Ref: ${seg.special_referee}</span>`;
        }

        // E. Bottom Line
       let subContent = '';
        if(seg.participants && Array.isArray(seg.participants) && seg.participants.length > 0) {
             subContent = `<div class="text-sm font-bold text-slate-400 mt-1 tracking-wide flex items-center flex-wrap">${seg.title} ${rivalryIcon} ${statsBadges} ${extraInfo}</div>`;
        } else {
             subContent = `<div class="text-xs text-slate-500 mt-1 italic flex items-center">${seg.desc || ''} ${statsBadges} ${extraInfo}</div>`;
        }

        // F. Championship Logic
        let champClass = '';
        let beltIcon = '';
        if (seg.is_title_match) {
            champClass = 'championship';
            colorClass = 'border-yellow-500';
            iconClass = 'fa-trophy text-yellow-500';
            typeLabel = `🏆 ${seg.title_name || 'Championship'} • ${seg.match_type}`;
            
            let divisionIndex = -1;
            let showNameForBelt = activeShow.name; 
            if (currentSave.showDivisions[activeShow.name]) { divisionIndex = currentSave.showDivisions[activeShow.name].indexOf(seg.title_name); }
            if (divisionIndex === -1 && currentSave.showDivisions['Global']) { divisionIndex = currentSave.showDivisions['Global'].indexOf(seg.title_name); showNameForBelt = 'Global'; }
            
            if (divisionIndex !== -1) {
                const beltKey = `${showNameForBelt}-${divisionIndex}`;
                if (currentSave.beltImages[beltKey]) {
                    beltIcon = `<img src="${currentSave.beltImages[beltKey]}" class="h-12 w-auto object-contain absolute right-10 top-1/2 -translate-y-1/2 opacity-90 drop-shadow-lg pointer-events-none">`;
                }
            }
        }

        // --- G. EXPANDED DETAILS ---
        let detailsHTML = '';
        
        // 1. Result Block (Winner)
        if (isReadOnly && seg.actual_winner) { 
            detailsHTML += `<div class="mt-4 mb-3 p-3 bg-green-900/20 border border-green-600/50 rounded flex justify-between items-center">
                <div class="text-xs text-white"><strong class="text-green-400">WINNER:</strong> ${seg.actual_winner} ${seg.finish_type ? `via ${seg.finish_type}` : ''}</div>
                <div class="text-xs text-yellow-400 font-bold">${seg.stars ? `${seg.stars} ★` : ''}</div>
            </div>`; 
        }

        // 2. Open The Grid
        detailsHTML += `<div class="mt-4 pt-4 border-t border-slate-700 grid grid-cols-1 md:grid-cols-2 gap-4 text-xs">`;
        
        // 3. Nielsen Rating Box (ALWAYS SHOW IF EXISTS)
        if (seg.rating) {
            detailsHTML += `<div class="col-span-2 bg-slate-950 p-3 rounded border border-blue-900/50 flex items-center justify-between shadow-inner">
                <span class="font-bold text-blue-400 uppercase tracking-widest"><i class="fa-solid fa-chart-line mr-2"></i>Nielsen Rating</span>
                <span class="font-mono text-white text-lg font-black">${seg.rating}</span>
            </div>`;
        }

        // 4. Planning Tools (Creative Push / Spots) - HIDE IF ARCHIVED (ReadOnly)
        if (!isReadOnly) {
            if (seg.creative_push || seg.booked_winner) {
                let pushText = seg.booked_winner ? `Booked Winner: ${seg.booked_winner} (${seg.booked_finish || 'Any'})` : (seg.creative_push || 'No winner set');
                detailsHTML += `<div class="creative-note-box note-push"><div class="font-bold text-green-400 mb-1 uppercase tracking-wider">🚀 Creative Push</div>${pushText}</div>`;
            }
            if (seg.spots) {
                detailsHTML += `<div class="creative-note-box note-spots"><div class="font-bold text-yellow-400 mb-1 uppercase tracking-wider">🔥 Key Spots</div>${seg.spots}</div>`;
            }
        }

        // 5. Context & Notes (Always Show)
        if (seg.context_deep) {
            detailsHTML += `<div class="creative-note-box note-history col-span-2">
                <div class="font-bold text-blue-400 mb-1 uppercase tracking-wider"><i class="fa-solid fa-book mr-1"></i> Deep Context</div>
                <div class="text-slate-300 leading-relaxed">${seg.context_deep}</div>
            </div>`;
        }
        if (seg.backstage) {
            detailsHTML += `<div class="creative-note-box note-heat col-span-2">
                <div class="font-bold text-red-400 mb-1 uppercase tracking-wider"><i class="fa-solid fa-user-secret mr-1"></i> Backstage Notes</div>
                <div class="text-slate-300 leading-relaxed">${seg.backstage}</div>
            </div>`;
        }

// --- NEW: AI COMMENTARY DISPLAY (ARCHIVE VISIBLE) ---
        if (seg.ai_script) {
             let scriptContent = seg.ai_script;
             // Strip container tags if they exist to avoid double padding, or keep them if you prefer
             // scriptContent = scriptContent.replace(/<div class="script-container">/g, '').replace(/<\/div>$/, '');
             
             detailsHTML += `<div class="creative-note-box border-purple-500 bg-purple-900/10 col-span-2">
                <div class="font-bold text-purple-400 mb-1 uppercase tracking-wider"><i class="fa-solid fa-microphone-lines mr-1"></i> Commentary Transcript</div>
                <div class="text-slate-300 leading-relaxed text-sm font-mono overflow-x-auto">${scriptContent}</div>
            </div>`;
        }
        // ----------------------------------------------------


        detailsHTML += `</div>`; // Close Grid

        // Fallback
        if (!seg.creative_push && !seg.context_deep && !seg.backstage && !seg.rating && !isReadOnly) { 
            detailsHTML += `<div class="mt-4 pt-4 border-t border-slate-700 text-slate-400 text-sm italic">${seg.desc || 'No detailed notes.'}</div>`; 
        }
        
        let buttonsHTML = isReadOnly ? '' : `<div class="mt-3 pt-3 border-t border-slate-700 flex gap-2"><button onclick="event.stopPropagation(); openEditSegmentModal(${index})" class="bg-slate-700 hover:bg-slate-600 text-white text-xs px-3 py-1 rounded">Edit Plans</button><button onclick="event.stopPropagation(); removeSegment(${index})" class="bg-red-900/50 hover:bg-red-900 text-red-200 text-xs px-3 py-1 rounded">Delete</button></div>`;
        
        let dragAttrs = isReadOnly ? '' : `draggable="true" ondragstart="segDragStart(${index})" ondragover="allowDrop(event)" ondrop="segDrop(event, ${index})"`;
        let cursorClass = isReadOnly ? 'cursor-default' : 'cursor-pointer';

        // --- RENDER HTML ---
        container.innerHTML += `
        <div ${dragAttrs} class="match-card bg-slate-800 p-4 rounded-lg border-l-4 ${colorClass} ${champClass} ${cursorClass} group mb-3 relative overflow-hidden transition-all hover:bg-slate-750 hover:shadow-lg" onclick="toggleCardDetail('${index}')">
            
            <div class="flex items-center gap-3 relative z-10">
                <div class="w-6 shrink-0 text-center text-slate-500 font-bold text-xl ${isReadOnly ? 'hidden' : 'cursor-move opacity-50 hover:opacity-100'}">
                    <i class="fa-solid fa-grip-lines"></i>
                </div>

                <div class="flex-1 text-left px-4"> 
                    <div class="flex items-center justify-start gap-2 mb-1 opacity-80">
                        <i class="fa-solid ${iconClass} text-sm"></i>
                        <span class="text-xs font-bold text-slate-300 uppercase tracking-widest">${typeLabel}</span>
                    </div>
                    ${mainContent}
                    ${subContent}
                </div>

                <div class="w-6 shrink-0 text-right">
                    <i id="chevron-${index}" class="fa-solid fa-chevron-down text-slate-600 transition-transform group-hover:text-white"></i>
                </div>
            </div>

            ${beltIcon}

            <div id="detail-${index}" class="hidden cursor-auto text-left relative z-20">
                ${detailsHTML}${buttonsHTML}
            </div>
        </div>`;
    });
}
        // --- RESTORED LIVE SHOW FUNCTIONALITY ---
     function renderLiveFeed() { 
    const container = document.getElementById('live-feed'); 
    container.innerHTML = ''; 
    
    // Update progress bar
    const total = cardData.filter(c => c.type === 'match').length;
    const done = cardData.filter(c => c.type === 'match' && c.actual_winner).length;
    const pct = total > 0 ? (done / total) * 100 : 0;
    if(document.getElementById('show-progress-bar')) {
        document.getElementById('show-progress-bar').style.width = `${pct}%`;
        document.getElementById('show-completion-status').innerText = `${done} of ${total} Matches Completed`;
    }

    // --- PREPARE ROSTER DATA FOR DROPDOWNS ---
    const showRoster = getAvailableRosterObjects();

    cardData.forEach((seg, index) => { 
        let color = seg.type === 'match' ? 'red' : 'blue'; 
        let planHint = seg.booked_winner ? `<div class="text-xs text-green-400 mb-2 font-bold uppercase"><i class="fa-solid fa-lightbulb mr-1"></i> Creative Plan: ${seg.booked_winner}</div>` : ''; 
        
        let isDone = (seg.type === 'match' && seg.actual_winner);
        let borderClass = 'border-slate-700'; 
        let bgStyle = isDone ? 'bg-green-900/20' : 'bg-slate-800'; 

        if (isDone) {
            borderClass = 'border-green-500 shadow-lg shadow-green-900/20'; 
        } else if (seg.is_title_match) {
            borderClass = 'border-yellow-500'; 
        }

        let titleInfo = '';
        if (seg.is_title_match) {
            titleInfo = `<div class="text-center bg-yellow-900/30 text-yellow-500 font-bold text-xs uppercase py-1 border-b border-yellow-700"><i class="fa-solid fa-trophy mr-2"></i> ${seg.title_name} Match</div>`;
        }

        let subHeader = seg.match_type || seg.type;
        if(seg.participants && seg.participants.length > 0) subHeader += ` • ${seg.participants.join(' vs. ')}`;
        if(seg.stipulation) subHeader += ` • ${seg.stipulation}`;

        let detailsHTML = `<div class="grid grid-cols-2 gap-4 text-[10px] text-slate-400 mb-3 bg-black/20 p-2 rounded">
            <div><span class="font-bold text-slate-300">Context:</span> ${seg.context_deep || seg.desc || 'None'}</div>
            <div><span class="font-bold text-green-300">Push:</span> ${seg.creative_push || 'None'}</div>
            <div class="col-span-2"><span class="font-bold text-yellow-300">Spots:</span> ${seg.spots || 'None'}</div>
        </div>`;

        // GENERATE STAR RATING DROPDOWN
        let starOptions = `<option value="">Rate</option>`;
        for(let i=0; i<=5; i+=0.5) {
            let val = (i % 1 === 0) ? i : i; 
            let sel = (parseFloat(seg.stars) === i) ? 'selected' : '';
            starOptions += `<option value="${val}" ${sel}>${val} ★</option>`;
        }

        // GENERATE WINNER DROPDOWN
        let winnerOptions = `<option value="">Select Winner</option>`;
        showRoster.forEach(w => {
            let isSelected = (seg.actual_winner === w.name) ? 'selected' : '';
            winnerOptions += `<option value="${w.name}" ${isSelected}>${w.name}</option>`;
        });

        // BUILD INPUTS
        let inputs = '';

        if (seg.type === 'match') {
            inputs = `${planHint}
        <div class="grid grid-cols-2 gap-4 mb-3">
            <select id="winner-${seg.id}" class="bg-slate-900 border border-slate-700 p-2 rounded text-white text-sm">
                ${winnerOptions}
            </select>
            <div class="flex items-center gap-2">
                <select id="stars-${seg.id}" class="bg-slate-900 border border-slate-700 p-2 rounded text-white text-sm w-24">
                    ${starOptions}
                </select>
            </div>
        </div>`; 
        } else {
            inputs = `
            <div class="mb-3 flex items-center gap-3 bg-slate-900/50 p-2 rounded border border-slate-700/50">
                <span class="text-[10px] font-bold text-slate-400 uppercase tracking-wider">Segment Quality:</span>
                <select id="stars-${seg.id}" class="bg-slate-800 border border-slate-600 p-1 rounded text-white text-xs w-24">
                    ${starOptions}
                </select>
            </div>`;
        }
        
        // --- NEW: RENDER SAVED AI SCRIPT ---
        let aiOutputHTML = '';
        if (seg.ai_script) {
            if (seg.type === 'match') {
                // Render as Broadcast Box
                aiOutputHTML = `<div id="ai-result-${seg.id}" class="mt-3 bg-slate-900/80 p-4 rounded border border-slate-700 text-sm font-mono leading-relaxed shadow-inner animate-fade-in"><div class="text-xs text-slate-500 uppercase font-bold mb-2 tracking-widest">Broadcast Transcript</div>${seg.ai_script}</div>`;
            } else {
                // Render as Script Container
                // Check if script already has container class (it should from AI), if not wrap it
                let content = seg.ai_script.includes('script-container') ? seg.ai_script : `<div class="script-container">${seg.ai_script}</div>`;
                aiOutputHTML = `<div id="ai-result-${seg.id}" class="animate-fade-in mt-4">${content}</div>`;
            }
        }
        // -----------------------------------

        container.innerHTML += `<div id="segment-card-${seg.id}" class="${bgStyle} border ${borderClass} rounded-xl overflow-hidden shadow-lg mb-4 transition-all duration-500">
            ${titleInfo}
            <div class="bg-${color}-900/20 p-4 border-b border-slate-700 font-bold text-white flex justify-between items-center">
                <span>${seg.title}</span>
                <div class="text-xs opacity-70 text-right max-w-[50%] truncate">${subHeader}</div>
            </div>
            <div class="p-5">
                ${detailsHTML}
                ${inputs}
                <textarea id="notes-${seg.id}" placeholder="Live Notes: What actually happened?" class="w-full bg-slate-900 border border-slate-700 rounded p-3 text-sm text-white mb-3 h-20">${seg.notes || ''}</textarea>
                <div class="flex gap-2">
                    <button onclick="saveResult(${seg.id})" class="flex-1 bg-green-600 hover:bg-green-500 text-white py-2 px-4 rounded font-bold transition shadow-lg shadow-green-900/20"><i class="fa-solid fa-floppy-disk mr-2"></i> Log Result</button>
                    <button onclick="runAICritique(${seg.id})" class="bg-purple-600 hover:bg-purple-500 text-white py-2 px-4 rounded font-bold"><i class="fa-solid fa-microphone-lines"></i> AI Commentary</button>
                </div>
                ${aiOutputHTML} 
            </div>
        </div>`; 
    }); 
}

      // =================================================
// TRI-MODE AI ENGINE: COMMENTARY, SCRIPTS & VIDEO PACKAGES
// =================================================

async function runAICritique(id) { 
    const seg = activeShow.segments.find(s => s.id === id); 
    if(!seg) return; 

    const btn = event.currentTarget; 
    const originalText = btn.innerHTML;
    
    // UI Loading State
    btn.innerHTML = `<i class="fa-solid fa-film fa-spin"></i> Producing...`; 
    btn.disabled = true;

    try {
        const key = localStorage.getItem('openai_key'); 
        if(!key) throw new Error("No API Key");

        // 1. DETERMINE MODE
        const lowerTitle = seg.title.toLowerCase();
        const lowerType = seg.type.toLowerCase();
        
        const isMatch = lowerType === 'match';
        // Detect Video/Highlight keywords
        const isVideo = lowerType === 'video' || 
                        lowerTitle.includes('video') || 
                        lowerTitle.includes('package') || 
                        lowerTitle.includes('highlight') || 
                        lowerTitle.includes('vignette') ||
                        lowerTitle.includes('promo package');

// --- NEW: CONTEXT AWARENESS (TRANSITION VS. CLOSE) ---
        const currentIndex = activeShow.segments.findIndex(s => s.id === id);
        const nextSeg = activeShow.segments[currentIndex + 1];
        let transitionInstr = "";

        if (nextSeg) {
            transitionInstr = `CRITICAL SHOW FLOW: This is NOT the end of the show. You MUST conclude by transitioning/tossing to the next segment: "${nextSeg.title}". Do NOT say "Goodnight" or sign off.`;
        } else {
            transitionInstr = `CRITICAL SHOW FLOW: This is the MAIN EVENT / FINAL SEGMENT. You MUST write the show-closing sign-off. Include the Copyright graphic appearing on screen, announcers saying "Goodnight everybody!", and fade to black.`;
        }
        // -----------------------------------------------------

        // 2. CONSTRUCT PROMPT
        let systemRole, promptContext, taskInstruction;

        // --- A. MATCH MODE (Commentary) ---
        if (isMatch) {
            const pbp = (activeShow.commentators && activeShow.commentators.pbp.name) ? activeShow.commentators.pbp.name : "Play-by-Play";
            const color = (activeShow.commentators && activeShow.commentators.color.name) ? activeShow.commentators.color.name : "Color";
            
            systemRole = `You are the Lead Commentator for a Pro Wrestling TV Show. Speak in the voices of: ${pbp} and ${color}.`;
            promptContext = `
                MATCH: ${seg.title}
                WINNER: ${seg.actual_winner || "Undecided"}
                RATING: ${seg.stars || "3"} Stars
                DETAILS: "${seg.notes || "Competitive match."}"
            `;
            taskInstruction = `
               Write a broadcast-quality call of the FINISH + immediate aftermath that makes the user feel like they are watching live TV.
STYLE RULES (critical):
1) Do NOT recap the entire match. Focus on the final moments and the first few moments after the bell.
2) Write as a SCRIPT with speaker labels. Use this structure:
   - Play-by-Play call (2–4 lines)
   - Color reaction / interpretation (2–4 lines)
   - production beat in parentheses (camera cutaway / crowd shot / backstage reaction / replay note) (1 line)
   - Button line to transition back to the show (1 line)
3) Keep it punchy: 8–14 total lines max.
4) Use vivid pro wrestling broadcast language
5) If notes include a “question” (ex: “Or is he quietly concerned?”) you must treat it as ambiguity and hint at BOTH possibilities without deciding.
6) If the commentary team info includes styles (ex: “serious,” “comedic,” “technical”), honor them:
   - Play-by-play: clarity + momentum
   - Color: personality + analysis + bias
7) Keep names and events exactly as provided. Don’t invent new wrestlers, titles, or stipulations not mentioned.
            `;
        } 
        
        // --- B. VIDEO PACKAGE MODE (Cinematic) ---
        else if (isVideo) {
            systemRole = `You are producing a professionally edited televised wrestling highlight package. The output must feel like a premium network broadcast package — cinematic, tightly paced, emotionally escalating, and visually detailed.
ERA ETHOS:
{Territories | Golden Era | New Generation | Attitude | Ruthless Aggression | PG | Reality | Current}

SHOW PRESENTATION:
{User-entered show presentation style}

PACKAGE TYPE:
{Origin vignette | Championship reintroduction | PPV recap | Rivalry escalation | Tournament launch | #1 contender hype | Division spotlight | Character transformation}`;
            
            promptContext = `
                SEGMENT TITLE: ${seg.title}
                CONTENT NOTES: "${seg.notes || seg.desc || "Standard hype video."}"
            `;
            
            taskInstruction = `
                Write a VIDEO PRODUCTION SCRIPT.
                
                FORMATTING RULES:
                1. HEADER: Start with 🎥 [Video Package: "Title"].
                2. VISUALS: Describe the footage in [Brackets]. Be cinematic (e.g., "Slow motion", "Grainy filter", "Fast cuts of chaos").
                3. AUDIO: Describe the music/SFX in (Parentheses) or with 🎵 icons (e.g., "Ominous orchestral strings", "Distorted heavy metal").
                4. NARRATION: If there is a narrator, specify the tone (e.g., "Narrator (Gravelly voice)").
                5. GRAPHICS: If text appears on screen, format it like: TEXT: "THE END IS NEAR".
                6. ENDING: Always cut back to the LIVE ARENA for a reaction from the commentators (${activeShow.commentators?.pbp?.name || 'JR'} and ${activeShow.commentators?.color?.name || 'King'}).
                
            `;
        } 
        
        // --- C. PROMO MODE (Standard Script) ---
        else {
            systemRole = `You are writing a pro-wrestling TV segment as a SCRIPT. The user’s input is canon.`;
            
            promptContext = `
                SEGMENT TITLE: ${seg.title}
                CHARACTERS: ${seg.participants ? seg.participants.join(', ') : "Various"}
                SCENE NOTES: "${seg.notes || seg.desc || "Interview segment."}"
            `;
            
            taskInstruction = `
                Write a full TV SEGMENT SCRIPT in standard Screenplay Format.
                
                GUIDELINES:
                1. HEADER: Start with 🎥 [Backstage/In-Ring Segment — Title].
                2. ACTION: Use [Brackets] to describe camera angles, entrances, and physical actions.
                3. DIALOGUE: Capture the specific "Voice" of the wrestler.
                4. ENDING: Include a short commentary reaction or fade to black.


A) Promo Engine Prompt (universal, handles all promo types)
VOICE CONSTRAINT:
- You MUST preserve the user-provided names, relationships, and intent.

SEGMENT TYPE: {Backstage Interview | Locker Room | In-Ring Promo | Backstage Confrontation | Post-Match Angle | Authority Office | Parking Lot | Video Insert}
ERA LENS (ethos): {Territories | Golden | New Gen | Attitude | Ruthless | PG | Reality | Current}
SHOW PRESENTATION (user-entered):

CAST
- Optional: Interviewer/Authority/Faction members (only if user specified)

OUTPUT REQUIREMENTS:
1) Start with a production header like: 🎥 [Location — Show/Week: “Segment Title”]
2) Include lines of dialogue. Keep it tight. Enogh to get the story across
3) Include 3–6 “TV beats” in brackets: [camera moves], [crowd audio], [music hits], [cutaway], [replay], [lower-third], etc.
4) Maintain kayfabe stakes: why it matters *this week* and what it sets up next.
5) If the user includes uncertainty (“or is he concerned?”), present it as subtext via:
   - a pause, a look, a cutaway, or a line that can be read two ways.
6) End with a strong “hook” line that makes the next show/PPV feel inevitable.

FORMAT:
- Use screenplay-like formatting with character names.
- No analysis, no bullet points, no explanation. Script only.


B) Backstage Interview Prompt (tight, interviewer-driven)
Write a backstage interview segment.

- Interviewer asks questions
- Main talent answers in their voice and personality
- Interrupting talent may enter later as described by user, delivers a challenge, and forces a definitive “accept/deny—why” moment.
- Include tv beats
- End with a clear booking stamp (match teased or made).
Output: 12–20 lines max. Script only.

            `;
        }

        const fullPrompt = `
            ${systemRole}
            
            INPUT DATA:
            ${promptContext}
            
            TASK:
            ${taskInstruction}
            
            ${transitionInstr}  <-- CRITICAL: PLACED AT THE END FOR EMPHASIS
            
            OUTPUT FORMAT:
            Return valid HTML using <div class="script-container"> wrapper. 
            Use <div class="script-header"> for titles.
            Use <div class="script-action"> for visuals/action.
            Use <div class="script-character"> for names.
            Use <div class="script-dialogue"> for speech.
            Use <div class="script-parenthetical"> for tone/audio cues.
        `;

        // 3. CALL AI
        const response = await fetch("https://api.openai.com/v1/chat/completions", { 
            method: "POST", 
            headers: { "Content-Type": "application/json", "Authorization": `Bearer ${key}` }, 
            body: JSON.stringify({ 
                model: "gpt-5.2", 
                messages: [{role: "user", content: fullPrompt}],
                temperature: 0.85 
            }) 
        }); 
        
        const data = await response.json(); 
        if(data.error) throw new Error(data.error.message);

        let output = data.choices[0].message.content.replace(/```html|```/g, ''); 

        // 4. INJECT INTO UI
        let resultBox = document.getElementById(`ai-result-${id}`);
        if (!resultBox) {
            // Find parent card
            const target = document.getElementById(`segment-card-${id}`) || btn.closest('.bg-slate-800');
            
            resultBox = document.createElement('div');
            resultBox.id = `ai-result-${id}`;
            resultBox.className = "animate-fade-in mt-4";
            target.appendChild(resultBox);
        }
        
        // If it's a match, we wrap it in a simple box. If it's a script/video, the AI provides the container class.
        if (isMatch) {
             resultBox.innerHTML = `<div class="bg-slate-900/80 p-4 rounded border border-slate-700 text-sm font-mono leading-relaxed shadow-inner"><div class="text-xs text-slate-500 uppercase font-bold mb-2 tracking-widest">Broadcast Transcript</div>${output}</div>`;
        } else {
             // The AI prompt explicitly asks for .script-container, but we add a fallback just in case
             if(!output.includes('script-container')) {
                 output = `<div class="script-container">${output}</div>`;
             }
             resultBox.innerHTML = output;
        }

// --- 4. SAVE TO DATABASE (NEW) ---
        seg.ai_script = output; 
        saveGame();
        // --------------------------------

        // 5. INJECT INTO UI
        renderLiveFeed(); // Re-render to show the saved script immediately

        
    } catch(e) { 
        console.error(e);
        alert("Production Truck Error: " + e.message); 
    } finally { 
        btn.innerHTML = originalText; 
        btn.disabled = false; 
    } 
}

       function saveResult(id) { 
    const seg = cardData.find(s => s.id === id); 
    
    // 1. Capture Inputs
    if(document.getElementById(`winner-${id}`)) {
        seg.actual_winner = document.getElementById(`winner-${id}`).value;
    }
    if(document.getElementById(`stars-${id}`)) seg.stars = document.getElementById(`stars-${id}`).value; 
    seg.notes = document.getElementById(`notes-${id}`).value; 

    // --- 2. LOGIC CHECK: TAG TEAM TITLES ---
    // If it's a match, we need to calculate losers and validate teams
    if (seg.type === 'match' && seg.participants && seg.participants.length >= 2) {
        
        let losers = seg.participants.filter(p => p !== seg.actual_winner);
        
        // CHECK: Is this a Tag Team Match? (More than 2 people)
        if (seg.participants.length > 2) {
            
            // Find the Winner in the Roster
            const winnerObj = currentSave.roster.find(r => r.name === seg.actual_winner);
            
            if (winnerObj) {
                // A. Try to find a partner in this match sharing the same Team Name
                const partnerObj = currentSave.roster.find(r => 
                    r.teamName &&                               // Must have a team name
                    r.teamName === winnerObj.teamName &&        // Must match winner's team
                    seg.participants.includes(r.name) &&        // Must be in the match
                    r.name !== winnerObj.name                   // Cannot be the winner themselves
                );

                // B. If Title Match but NO TEAM FOUND -> STOP AND WARN
                if (seg.is_title_match && !partnerObj) {
                    alert(`⚠️ TAG TEAM ERROR\n\n${seg.actual_winner} won, but the system doesn't know who their partner is!\n\n1. Go to the ROSTER.\n2. Assign a "Tag Team Name" to ${seg.actual_winner} and their partner.\n3. Come back and save this result.\n\n(This prevents the '3 Champions' bug).`);
                    // RESET THE WINNER SO THEY CAN TRY AGAIN
                    document.getElementById(`winner-${id}`).value = "";
                    seg.actual_winner = null; 
                    return; // <--- STOP EXECUTION
                }

                // C. If Team Found -> Remove Partner from Losers List
                // (So they don't lose stats or get treated as a defeated opponent)
                if (partnerObj) {
                    losers = losers.filter(p => p !== partnerObj.name);
                }
            }
        }

        // Proceed to update standings with the CORRECTED losers list
        updateDivisionStandings(seg.actual_winner, losers, seg);
    }

    if (seg.type === 'match' && seg.actual_winner) {
        generatePowerRankings();
    }

    activeShow.segments = cardData; 
    saveGame(); 
    renderLiveFeed(); 
}

        // --- RESTORED ROSTER FUNCTIONS (Scan, Add, Upload, Drag) ---
        
        function openUploadModal(context) {
            document.getElementById('upload-context').value = context;
            const divSelect = document.getElementById('upload-division');
            divSelect.innerHTML = '';
            
            // Populate divisions based on current filter or defaults
            let currentDivNames = ["Division 1", "Division 2", "Division 3", "Division 4", "Division 5", "Division 6", "Division 7"];
            if (rosterFilter !== 'all' && rosterFilter !== 'free' && currentSave.showDivisions[rosterFilter]) {
                currentDivNames = currentSave.showDivisions[rosterFilter];
            }
            
            currentDivNames.forEach((d, i) => {
                divSelect.innerHTML += `<option value="${i}">${d}</option>`;
            });
            
            if(context === 'rankings') document.getElementById('upload-roster-options').classList.add('hidden');
            else document.getElementById('upload-roster-options').classList.remove('hidden');
            
            document.getElementById('upload-modal').classList.remove('hidden');
        }

        async function processUpload() {
            const context = document.getElementById('upload-context').value;
            const file = document.getElementById('upload-file').files[0];
            const key = localStorage.getItem('openai_key');
            
            if(!file || !key) return alert("File and API Key required");
            
            const btn = document.querySelector('#upload-modal button.bg-green-600');
            const originalText = btn.innerText;
            btn.innerText = "Scanning...";
            btn.disabled = true;

            try {
                const base64 = await readImage(file); // This already handles compression
                
                // prompt for AI Vision
                const prompt = context === 'rankings' 
                    ? "Identify the wrestler names in this image. Return strictly a JSON array of strings in order of rank. Example: [\"Name 1\", \"Name 2\"]"
                    : "Identify the wrestler names in this image. Return strictly a JSON array of strings. Example: [\"Name 1\", \"Name 2\"]";

                const res = await fetch("https://api.openai.com/v1/chat/completions", {
                    method: "POST",
                    headers: { "Content-Type": "application/json", "Authorization": `Bearer ${key}` },
                    body: JSON.stringify({
                        model: "gpt-5.2", // Vision capable model
                        messages: [
                            { role: "user", content: [
                                { type: "text", text: prompt },
                                { type: "image_url", image_url: { url: base64 } }
                            ]}
                        ]
                    })
                });
                
                const data = await res.json();
                const content = data.choices[0].message.content;
                const jsonStart = content.indexOf('[');
                const jsonEnd = content.lastIndexOf(']') + 1;
                const names = JSON.parse(content.substring(jsonStart, jsonEnd));
                
                if (context === 'rankings') {
                    // Update Rankings
                    if(!currentSave.powerRankings[rankingFilter]) currentSave.powerRankings[rankingFilter] = { manual: [], ai: [] };
                    // If overwrite or append? Usually overwrite for scans
                    currentSave.powerRankings[rankingFilter].manual = names;
                    renderRankings();
                } else {
                   // --- NEW: PER-SHOW CAP FOR BULK IMPORT ---
                    const settings = currentSave.settings || { capEnabled: false, capLimit: 50 };
                    
                    // Only check cap if uploading to a specific show (Not 'all' or 'free')
                    if (settings.capEnabled && rosterFilter !== 'all' && rosterFilter !== 'free') {
                        const showRosterCount = currentSave.roster.filter(w => w.shows === rosterFilter).length;
                        const availableSlots = settings.capLimit - showRosterCount;
                        
                        if (names.length > availableSlots) {
                            alert(`CAP EXCEEDED FOR ${rosterFilter.toUpperCase()}.\n\nCurrent Roster: ${showRosterCount}\nLimit: ${settings.capLimit}\nTrying to add: ${names.length}\nAvailable slots: ${availableSlots}\n\nImport cancelled.`);
                            return;
                        }
                    }
                    // -----------------------------------------

                    // Update Roster
                    const division = parseInt(document.getElementById('upload-division').value);
                    const show = (rosterFilter === 'all' || rosterFilter === 'free') ? '' : rosterFilter;
                    
                    names.forEach(name => {
                        currentSave.roster.push({
                            id: Date.now() + Math.random().toString(),
                            name: name,
                            shows: show,
                            division: division,
                            status: 'active'
                        });
                    });
                    renderRoster();
                }
                
                saveGame();
                document.getElementById('upload-modal').classList.add('hidden');
                alert(`Successfully imported ${names.length} names!`);

            } catch (e) {
                console.error(e);
                alert("Error scanning image. Ensure your API Key supports GPT-5.2 (Vision).");
            } finally {
                btn.innerText = originalText;
                btn.disabled = false;
            }
        }

        function openManualAddModal() {
            const showSelect = document.getElementById('manual-show');
            showSelect.innerHTML = '<option value="">Free Agent</option>';
            const uniqueShows = [...new Set(currentSave.shows.filter(s => s.type === 'weekly').map(s => s.name))];
            uniqueShows.forEach(s => {
                showSelect.innerHTML += `<option value="${s}">${s}</option>`;
            });
            document.getElementById('manual-roster-modal').classList.remove('hidden');
        }

        function saveManualRoster() {
    const name = document.getElementById('manual-name').value;
    const show = document.getElementById('manual-show').value; // "" means Free Agent
    const div = parseInt(document.getElementById('manual-division').value);
    
    if(!name) return;

    // --- NEW: PER-SHOW CAP LOGIC ---
    const settings = currentSave.settings || { capEnabled: false, capLimit: 50 };
    
    // Only enforce cap if:
    // 1. Cap is ON
    // 2. We are assigning to a specific Show (NOT Free Agent)
    if (settings.capEnabled && show !== "") {
        // Count only wrestlers on this specific show
        const showRosterCount = currentSave.roster.filter(w => w.shows === show).length;
        
        if (showRosterCount >= settings.capLimit) {
            alert(`ROSTER CAP REACHED FOR ${show.toUpperCase()}.\n\nLimit: ${settings.capLimit}\nCurrent: ${showRosterCount}\n\nYou must release someone from ${show} first, or add this wrestler as a Free Agent.`);
            return;
        }
    }
    // -------------------------------

    currentSave.roster.push({
        id: Date.now().toString(),
        name: name,
        shows: show,
        division: div,
        status: 'active'
    });
    
    saveGame();
    renderRoster();
    document.getElementById('manual-roster-modal').classList.add('hidden');
    document.getElementById('manual-name').value = '';
}

// --- FACE / HEEL LOGIC ---
function toggleAlignment(id) {
    const w = currentSave.roster.find(w => w.id === id);
    if(w) {
        // Default to 'Face' if not set, then toggle
        const current = w.alignment || 'Face';
        w.alignment = (current === 'Face') ? 'Heel' : 'Face';
        
        saveGame();
        renderRoster();
    }
}

// --- TAG TEAM LOGIC ---

// 1. Create or Assign a Team
function assignTeam(wrestlerId) {
    const w = currentSave.roster.find(r => r.id === wrestlerId);
    if (!w) return;

    // Pre-fill with existing team name if they have one
    const teamName = prompt("Enter Tag Team Name (Leave empty to remove from team):", w.teamName || "");
    
    // Remove from team if cleared
    if (teamName === "" || teamName === null) {
        delete w.teamName;
        delete w.teamId;
    } 
    // Create/Assign Team
    else {
        w.teamName = teamName;
        // Generate a shared ID based on the name (e.g., "The Usos" -> "the_usos")
        w.teamId = teamName.toLowerCase().replace(/\s+/g, '_');
    }

    saveGame();
    renderRoster();
}

// --- INJURY TRACKING LOGIC ---
function toggleInjury(id) {
    const w = currentSave.roster.find(w => w.id === id);
    if(w) {
        // Cycle: Healthy -> Light -> Moderate -> Severe -> Healthy
        if (!w.injury) w.injury = 'Light';
        else if (w.injury === 'Light') w.injury = 'Moderate';
        else if (w.injury === 'Moderate') w.injury = 'Severe';
        else w.injury = null; 
        
        saveGame();
        renderRoster();
    }
}

        function updateWrestlerShow(id, newShow) {
            const w = currentSave.roster.find(w => w.id === id);
            if(w) {
                w.shows = newShow;
                saveGame();
                renderRoster(); // Re-render to move them if filter is active
            }
        }

        function setRosterStatus(id, type) {
            const w = currentSave.roster.find(w => w.id === id);
            if(w) {
                // Toggle status
                if(w.status === type) w.status = 'active'; // toggle off
                else w.status = type;
                saveGame();
                renderRoster();
            }
        }
// --- TOGGLE LEGEND STATUS ---
function toggleLegend(id) {
    const w = currentSave.roster.find(w => w.id === id);
    if(w) {
        // Toggle boolean
        w.isLegend = !w.isLegend;
        
        // If becoming a Legend, give them a stats bump immediately (Optional immediate gratification)
        if (w.isLegend && w.stats) {
            w.stats.popularity = Math.max(w.stats.popularity, 90); // Legends are famous
            w.stats.draw = Math.max(w.stats.draw, 85); // Legends draw money
        }

        saveGame();
        renderRoster();
    }
}
function deleteWrestler(id) {
            if(confirm("Are you sure you want to release this wrestler?")) {
                // Convert both to String to ensure matching works for imported IDs
                currentSave.roster = currentSave.roster.filter(w => String(w.id) !== String(id));
                saveGame();
                renderRoster();
            }
        }        

        function renameDivision(index, newName) {
            const showKey = (rosterFilter === 'all' || rosterFilter === 'free') ? 'Global' : rosterFilter;
            // Initialize if empty
            if (rosterFilter === 'all' || rosterFilter === 'free') {
               // Global divisions aren't really editable in this view logic usually, but let's allow it 
               // For now, let's just save it to the current filter context
            }
            
            if (!currentSave.showDivisions[showKey]) {
                currentSave.showDivisions[showKey] = ["Division 1", "Division 2", "Division 3", "Division 4", "Division 5", "Division 6", "Division 7"];
            }
            currentSave.showDivisions[showKey][index] = newName;
            saveGame();
        }
// --- UPDATED: 4-STATE DIVISION TYPES ---
function getDivisionType(index) {
    const showKey = (rosterFilter === 'all' || rosterFilter === 'free') ? 'Global' : rosterFilter;
    const key = `${showKey}-${index}`;
    // Returns: 'Standard', 'Women', 'Tag', or 'WomenTag'
    return currentSave.divisionTypes?.[key] || 'Standard';
}

function toggleDivisionType(index) {
    const types = ['Standard', 'Women', 'Tag', 'WomenTag'];
    const current = getDivisionType(index);
    let next = types[(types.indexOf(current) + 1) % types.length];
    
    const showKey = (rosterFilter === 'all' || rosterFilter === 'free') ? 'Global' : rosterFilter;
    const key = `${showKey}-${index}`;
    
    if (!currentSave.divisionTypes) currentSave.divisionTypes = {};
    currentSave.divisionTypes[key] = next;
    
    saveGame();
    renderRoster();
}
        // --- UPDATED DRAG & DROP LOGIC (Re-Ranking + Mode Aware) ---

function dragStart(id) { draggedWrestlerId = id; }
function allowDrop(ev) { ev.preventDefault(); }
function dragOver(ev) { ev.preventDefault(); }

// 1. Drop ONTO another wrestler (Insert & Re-rank)
function drop(e, targetDiv, targetVisualIndex) {
    e.preventDefault();
    e.stopPropagation();

    const w = currentSave.roster.find(r => r.id === draggedWrestlerId);
    if(!w) return;

    // A. Detect Mode (Official vs System)
    const isSystem = (rosterViewMode === 'system');
    const getDiv = (x) => isSystem ? x.systemDivision : x.division;
    const setDiv = (x, v) => { if(isSystem) x.systemDivision = v; else x.division = v; };
    const getRank = (x) => isSystem ? x.systemRank : x.rank;
    const setRank = (x, v) => { if(isSystem) x.systemRank = v; else x.rank = v; };

    // B. Get the Target Roster (Everyone in that division)
    // CRITICAL FIX: Sort this EXACTLY how the UI sorts it (Champions First, then Rank)
    // This ensures 'Visual Index 2' matches 'Array Index 2'
    let divRoster = currentSave.roster.filter(r => 
        getDiv(r) === targetDiv && r.id !== w.id
    ).sort((a,b) => {
        if(a.status === 'champ') return -1; 
        if(b.status === 'champ') return 1;
        return getRank(a) - getRank(b);
    });

    // C. Insert at the specific visual index
    if (targetVisualIndex >= 0 && targetVisualIndex <= divRoster.length) {
        divRoster.splice(targetVisualIndex, 0, w);
    } else {
        divRoster.push(w); 
    }

    // D. Apply New Ranks to Everyone
    divRoster.forEach((r, index) => {
        setDiv(r, targetDiv);
        setRank(r, index);
    });

    saveGame();
    renderRoster();
}

// 2. Drop into an EMPTY zone (Add to bottom)
function dropOnDivision(e, targetDiv) {
    e.preventDefault();
    const w = currentSave.roster.find(r => r.id === draggedWrestlerId);
    if(!w) return;

    const isSystem = (rosterViewMode === 'system');
    const getDiv = (x) => isSystem ? x.systemDivision : x.division;
    const setDiv = (x, v) => { if(isSystem) x.systemDivision = v; else x.division = v; };
    const setRank = (x, v) => { if(isSystem) x.systemRank = v; else x.rank = v; };

    // Set Division
    setDiv(w, targetDiv);

    // Find current count to put them at the end
    const count = currentSave.roster.filter(r => getDiv(r) === targetDiv && r.id !== w.id).length;
    setRank(w, count);

    saveGame();
    renderRoster();
}

// --- STATIC DIVISION LOGIC ---

function getDivisionKey(index) {
    // Generate a unique key for this specific division (e.g. "Raw-6" or "Global-0")
    const showKey = (rosterFilter === 'all' || rosterFilter === 'free') ? 'Global' : rosterFilter;
    return `${showKey}-${index}`;
}

function toggleDivisionLock(index) {
    if(!currentSave.lockedDivisions) currentSave.lockedDivisions = [];
    
    const key = getDivisionKey(index);
    const isLocked = currentSave.lockedDivisions.includes(key);
    
    if(isLocked) {
        // Unlock it
        currentSave.lockedDivisions = currentSave.lockedDivisions.filter(k => k !== key);
    } else {
        // Lock it
        currentSave.lockedDivisions.push(key);
    }
    
    saveGame();
    renderRoster();
}

        // --- PUBLISH LOGIC ---
        async function finishShow() { 
// 1. API Key Check
    const key = localStorage.getItem('openai_key'); 
    if(!key) return alert("API Key needed"); 

// 1. RUN THE NIELSEN ENGINE
    const finalRating = calculateShowRatings(); // <--- NEW: Calculate real numbers
    
    // 2. Show Loading Screen
    document.getElementById('report-modal').classList.remove('hidden'); 
    document.getElementById('report-loading').classList.remove('hidden');
    document.getElementById('btn-publish').disabled = true; 

// --- NEW: START 2-MINUTE COUNTDOWN ---
    if(reportTimer) clearInterval(reportTimer); // Reset if exists
    let secondsLeft = 120; // 2 Minutes
    const timerDisplay = document.getElementById('report-countdown');
    if(timerDisplay) timerDisplay.innerText = "Estimated wait: 2m 00s";

    reportTimer = setInterval(() => {
        secondsLeft--;
        const m = Math.floor(secondsLeft / 60);
        const s = secondsLeft % 60;
        
        if(timerDisplay) {
            timerDisplay.innerText = `Estimated wait: ${m}m ${s.toString().padStart(2, '0')}s`;
            
            // Fun status updates based on time
            if(secondsLeft === 90) timerDisplay.innerText += " (Writing Headlines...)";
            if(secondsLeft === 60) timerDisplay.innerText += " (Calculating Ratings...)";
            if(secondsLeft === 30) timerDisplay.innerText += " (Finalizing Layout...)";
        }

        if(secondsLeft <= 0) {
            clearInterval(reportTimer);
            if(timerDisplay) timerDisplay.innerText = "Finishing up... (Almost there)";
        }
    }, 1000);

    
    // --- NEW: CALENDAR WEEK CALCULATOR (The Fix) ---
    const [y, m, d] = activeShow.date.split('-').map(Number);
    const dateObj = new Date(y, m - 1, d);
    const yearShort = String(y).slice(-2);
    // Get Day Number (Mon=1...Sun=7)
    let dayNum = dateObj.getDay(); 
    if (dayNum === 0) dayNum = 7; 
    // Calculate Actual Week of Year (1-52)
    const startOfYear = new Date(y, 0, 1);
    const days = Math.floor((dateObj - startOfYear) / (24 * 60 * 60 * 1000));
    const weekNum = Math.ceil((days + startOfYear.getDay() + 1) / 7);
    // RESULT: "98-20.7" (Year 98, Week 20, Sunday)
    const issueID = `${yearShort}-${weekNum}.${dayNum}`;
    // ----------------------------------------------

    const eraData = ERA_CONFIG[currentSave.era] || ERA_CONFIG['current']; 
    const promptText = document.getElementById('booker-prompt').value;
    
    // Image Logic
    const imgInput = document.getElementById('magazine-image-url');
    const imgUrl = imgInput ? imgInput.value : null;
    let imageInstruction = ""; // <--- WAS MISSING
    if (imgUrl) {
        const imageTag = `<img src="${imgUrl}" class="mag-feature-image" alt="Feature Image">`;
        imageInstruction = `IMPORTANT: You MUST include the Feature Image exactly between the 'mag-header' and the first H2 headline: ${imageTag}`;
    }

    // Commentary Logic
    let commentaryContext = "";
    let comms = activeShow.commentators;
    if(!comms && activeShow.type === 'weekly' && currentSave.seriesConfig && currentSave.seriesConfig[activeShow.name]) { 
        comms = currentSave.seriesConfig[activeShow.name].commentators; 
    }
    if (comms) { 
        if(comms.pbp?.name) commentaryContext += `Play-by-Play: ${comms.pbp.name} (${comms.pbp.style}). `; 
        if(comms.color?.name) commentaryContext += `Color: ${comms.color.name} (${comms.color.style}). `; 
        if(comms.interviewer?.name) commentaryContext += `Interviewer: ${comms.interviewer.name} (${comms.interviewer.style}). `; 
    }
    if(commentaryContext) commentaryContext = "IMPORTANT: Write this report incorporating quotes or the specific 'voice' of this broadcast team: " + commentaryContext;

// --- NEW: BUILD THE RATINGS TABLE HTML FOR THE AI ---
    // We construct the table here programmatically so the AI uses OUR numbers.
    let ratingsTableHTML = `
    <table class="ratings-table">
        <thead>
            <tr>
                <th>Segment</th>
                <th>Content</th>
                <th>Rating</th>
                <th>Trend</th>
            </tr>
        </thead>
        <tbody>`;
    
    let previousRating = currentSave.brandHealth.baseline; // Start comparison
    
    cardData.forEach((seg, i) => {
        const rating = parseFloat(seg.rating);
        const diff = rating - previousRating;
        let trend = "";
        
        if (diff > 0.05) trend = `<span class="trend-up">▲ (+${diff.toFixed(2)})</span>`;
        else if (diff < -0.05) trend = `<span class="trend-down">▼ (${diff.toFixed(2)})</span>`;
        else trend = `<span class="trend-flat">―</span>`;
        
        ratingsTableHTML += `
            <tr>
                <td>Q${i+1}</td>
                <td>${seg.title}</td>
                <td>${rating.toFixed(2)}</td>
                <td>${trend}</td>
            </tr>`;
            
        previousRating = rating; // Set for next comparison
    });
    
    ratingsTableHTML += `</tbody></table>
    <div style="margin-top:10px; font-weight:bold; border-top:1px solid #ccc; padding-top:5px;">
        FINAL SHOW RATING: ${finalRating}
    </div>`;


            // --- UPDATED PROMPT WITH YOUR NEW EDITORIAL GUIDELINES ---
    const prompt = `
    ${eraData.system}


    You are “The Inside Count,” a professional wrestling insider magazine that blends kayfabe reporting, backstage intelligence, creative analysis, and television metrics.
    You are writing a weekly issue covering the most recent show in a living wrestling promotion universe.
    
    CONTEXT DATA:
    - Era: ${currentSave.era}
    - Week: ${currentSave.weekNumber}
    - User Instructions: "${promptText}"
    - ${commentaryContext}
    - ${imageInstruction}
    - SHOW DATA: ${JSON.stringify(cardData)}

    Your voice should combine:
    - Insider credibility (industry-aware)
    - Narrative storytelling (dramatic, vivid)
    - Strategic production insight
    - Partial kayfabe (maintain illusion while acknowledging backstage reality)

    STRUCTURE YOUR ISSUE WITH THESE SECTIONS IN ORDER:

    1. 🗞️ HEADLINE & LEAD SUMMARY
       - One strong headline capturing the biggest story of the night
       - 1–2 paragraph lead summarizing the emotional and business impact

    2. 🔥 MAIN EVENT FALLOUT
       - Focus on the closing segment or biggest angle
       - Describe match finish, post-match developments, crowd reaction
       - Include backstage reaction, timing overruns, production or ratings impact
       - Seed future storyline direction  

    3. 🩸 MAJOR STORYLINE ANGLES (2–4 items)
      For each:
   - Describe what happened on-screen  
   - Add insider or creative context  
   - Compare to historical moments when relevant  
   - Indicate how this advances upcoming PPV or arcs

    4. 🏆 DIVISION REPORTS
       Cover relevant divisions that had meaningful developments:
(outcomes, reactions, booking implications)
   - Men’s Singles  
   - Women’s Division  
   - Tag Division  
   - Specialty / Hardcore / Cruiser / etc 
   Include:
   - Match outcomes  
   - Crowd reaction  
   - Internal praise or concern  
   - Future booking implications  

    5. 🕵️ DIRT SHEET RUMORS & SPECULATION
Generate a rumor-and-speculation section written in the style of wrestling dirt sheets.
Include:
- A dynamic, clickbait-style headline that teases controversy, a major reveal, or instability.
- 4–7 short rumor blurbs.
Each rumor should:
- Mix truth, half-truth, and speculation.
- Reference performers, title plans, returns, injuries, or creative direction.
- Use vague attribution (e.g., “one source,” “multiple insiders,” “creative sources”).
- Include uncertainty language (“subject to change,” “not finalized,” “being discussed”).
- Sometimes contradict Internal Notes or exaggerate real plans.
- Occasionally be completely wrong.
Tone:
- Sensational but plausible.
- Insider gossip voice.
- Written as if competing dirt sheets are racing to break news first.
Purpose:
- Create narrative uncertainty.
- Simulate media pressure on creative.
- Seed future storylines and red herrings.

    6. 💬 FAN BUZZ & EARLY PPV HYPE
       	- List 4–6 short fan reactions/headlines
	- Mix social reaction, arena reaction, and hype momentum  
	- Highlight what angles are driving ticket interest  

    7. 📊 TV RATINGS & ANALYSIS
       - IMPORTANT INSTRUCTION ON RATINGS:
    I have mathematically calculated the TV Ratings for this show based on the game engine.
    DO NOT hallucinate the "TV RATINGS & ANALYSIS" section.
    1. INJECT THE FOLLOWING HTML TABLE exactly as written into Section 7:
    ${ratingsTableHTML}
    2. In your analysis text for Section 7, reference these specific numbers. Explain WHY the rating went up or down based on the segment content (e.g. "The main event drew a massive number" or "The midcard promo lost viewers").
     • Peak segment  
     • Overrun performance  
     • Commercial drop-offs  
   - Provide:
     • Overall average  
     • Demo performance  
     • Trend vs last week  
   - Brief analysis of what drove gains or losses  

    8. ✒️ CLOSING LINE (EDITOR’S NOTE)
       	- 1–2 sentence editorial conclusion  
   	- Tie emotional tone to era philosophy and upcoming PPV  

OUTPUT FORMAT:

- Use clear section headers with emojis (🗞️ 🔥 🩸 🏆 👑 💀 🏷 🕵️ 💬 📊 💬)
- Write in full narrative paragraphs and bullet lists where appropriate
- End with “Internal Notes to follow” before the Internal Notes section

    9. 💀 INTERNAL NOTES (NON-PUBLIC — PROMOTER ONLY)
      Generate backstage and operational intelligence that would never appear in public reports.
Include a mix of the following categories where relevant:
1. Creative Control & Talent Requests
   - booking approvals, timing control, finish preferences, segment length requests
2. Health, Medical & Availability
   - injuries, clearances, restrictions, travel limits, workload management
3. Creative Direction & Long-Term Arcs
   - future storyline focus, division resets, faction plans, title trajectories
4. Character Development & Gimmick Evolution
   - new personas, vignette plans, heel/face shifts, presentation tweaks
5. Political & Backstage Dynamics
   - morale, conflicts, influence, locker room sentiment, talent negotiations
6. Production & Business Intelligence
   - attendance, ratings trends, merch, broadcast feedback, logistics
7. Match & Performer Evaluation
   - internal assessments of match quality, chemistry, pacing, star potential
8. Risk, Contingency & Crisis Planning
   - backup finishes, injury contingencies, crowd management, schedule risks
Guidelines:
- Write as confidential production notes.
- Use concise professional language.
- Include 4–8 notes per show depending on show importance.
- Each note should reference a specific performer, division, or production area.
- Notes should influence future booking logic and AI decisions.
Tone: Executive backstage memo. Strategic, candid, non-public.
Output as bullet-style entries under the header “INTERNAL NOTES (NON-PUBLIC)”.

    ---------------------------------------------------
    CRITICAL OUTPUT FORMATTING RULES:
    1. BREAK UP THE TEXT. Do not write long blobs.
    2. USE <h2 class="report-h2">...</h2> FOR EVERY NEW SECTION TITLE.
    3. For Section 7 (Ratings), you MUST use an HTML <table>.

    REQUIRED HTML STRUCTURE:

    <div class="mag-header">
        <div class="mag-headline">INSIDE COUNT</div>
        <div class="mag-subhead">Issue #${issueID} • ${activeShow.name}</div>
    </div>

    <div class="mag-content">
        
        <h2 class="report-h2">🗞️ [INSERT DYNAMIC ALL-CAPS HEADLINE HERE]</h2>
        <p>...</p>

        <h2 class="report-h2">🔥 MAIN EVENT FALLOUT</h2>
        <p>...</p>

        <h2 class="report-h2">🩸[INSERT DYNAMIC ALL-CAPS HEADLINE HERE]</h2>
        <p>...</p>

        <h2 class="report-h2">🏆 DIVISION REPORTS</h2>
        <p>...</p>

        <h2 class="report-h2">🕵️ [INSERT DYNAMIC ALL-CAPS HEADLINE HERE]</h2>
        <p>...</p>

        <h2 class="report-h2">💬 FAN BUZZ</h2>
        <ul>
            <li>Reaction 1...</li>
            <li>Reaction 2...</li>
        </ul>

        <h2 class="report-h2">📊 TV RATINGS ANALYSIS</h2>
        <p>Overview of the number: (e.g. 4.2 Million viewers, up from last week).</p>
        
        <table class="ratings-table">
            <thead>
                <tr>
                    <th>Segment</th>
                    <th>Content</th>
                    <th>Rating</th>
                    <th>Trend</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Q1</td>
                    <td>Opening Promo / Match A</td>
                    <td>4.5</td>
                    <td><span class="trend-up">▲ (+0.2)</span></td>
                </tr>
                <tr>
                    <td>Q2</td>
                    <td>Midcard Segment</td>
                    <td>4.3</td>
                    <td><span class="trend-down">▼ (-0.2)</span></td>
                </tr>
                </tbody>
        </table>

        <h2 class="report-h2">✒️ EDITOR'S NOTE</h2>
        <p>...</p>

        <h2 class="report-h2" style="color:#ef4444; border-color:#ef4444;">💀 INTERNAL NOTES (CONFIDENTIAL)</h2>
        <ul>
            <li>...</li>
        </ul>

    </div>`;
            
           try {
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: { "Content-Type": "application/json", "Authorization": `Bearer ${key}` },
        body: JSON.stringify({ model: "gpt-5.2", messages: [{role: "user", content: prompt}] })
    });

clearInterval(reportTimer);

    const data = await response.json();
    let rawHTML = data.choices[0].message.content.replace(/```html|```/g, '');
    
    // --- NEW: Wrap the raw HTML in our new page structure ---
    const wrapper = `
        <div class="magazine-bg-layer era-${currentSave.era}">
            <div class="magazine-page">
                ${rawHTML}
            </div>
        </div>
    `;
    
    generatedReportHTML = wrapper; // Save the FULL structure
    document.getElementById('report-preview-body').innerHTML = generatedReportHTML;
    
    // Enable Publish Button
    document.getElementById('report-loading').classList.add('hidden');
    document.getElementById('btn-publish').disabled = false;
    document.getElementById('btn-publish').classList.remove('opacity-50', 'cursor-not-allowed');

} catch(e) { 

clearInterval(reportTimer);

        // --- FIX 3: Actual Error Handling so the spinner stops ---
        console.error(e);
        alert("Error generating report: " + e.message);
        document.getElementById('report-loading').classList.add('hidden');
        document.getElementById('report-modal').classList.add('hidden');
}
        }
        
        async function addPosterToReport() {
    const file = document.getElementById('poster-upload').files[0];
    if(!file) return;
    const base64 = await readImage(file);
    
    // 1. Define the Image HTML with the aesthetic class
    const imgHTML = `<img src="${base64}" class="mag-feature-image" alt="Feature Image">`;

    // 2. Inject it INSIDE the magazine structure
    // We look for the start of the content section and put the image right before it.
    if(generatedReportHTML.includes('mag-content')) {
        generatedReportHTML = generatedReportHTML.replace('<div class="mag-content">', imgHTML + '<div class="mag-content">');
    } 
    // Fallback: If for some reason mag-content isn't there, put it at the start of the page
    else if (generatedReportHTML.includes('magazine-page')) {
        generatedReportHTML = generatedReportHTML.replace('<div class="magazine-page">', '<div class="magazine-page">' + imgHTML);
    } 
    // Legacy Fallback: Old reports
    else {
        generatedReportHTML = `<div class="mb-4 text-center">${imgHTML}</div>` + generatedReportHTML;
    }
    
    document.getElementById('report-preview-body').innerHTML = generatedReportHTML;
}
        

// =========================================
// RIVALRY ARCHIVER (Stops Old Feuds)
// =========================================
function checkRivalryCompletions() {
    if (!currentSave.rivalries) return;
    if (!currentSave.archivedRivalries) currentSave.archivedRivalries = [];

    const endingRivalries = currentSave.rivalries.filter(r => String(r.blowoff) === String(activeShow.id));
    
    if (endingRivalries.length > 0) {
        endingRivalries.forEach(r => {
            // 1. Initialize Chapters
            if (!r.chapters) r.chapters = [];

            // 2. Save THIS run as a chapter
            r.chapters.push({
                start: r.start,
                end: activeShow.date,
                blowoff: activeShow.id,
                name: r.name
            });

            // 3. Archive
            r.status = 'archived';
            r.archivedDate = activeShow.date;
            r.conclusionShow = activeShow.name;
            
            currentSave.archivedRivalries.push(r);
        });

        // 4. Remove from Active
        currentSave.rivalries = currentSave.rivalries.filter(r => String(r.blowoff) !== String(activeShow.id));
        
        const names = endingRivalries.map(r => r.name).join(', ');
        alert(`🏁 CHAPTER CLOSED:\n\n${names}\n\nThese storylines have been archived. You can resume them later to start a new chapter.`);
    }
}

        async function addArchiveImage() {
    if(!viewingArchiveId) return;
    const file = document.getElementById('archive-image-upload').files[0];
    if(!file) return;
    const base64 = await readImage(file);
    
    const report = currentSave.history.find(h => String(h.id) === String(viewingArchiveId));
    
    if(report) {
        const imgHTML = `<img src="${base64}" class="mag-feature-image" alt="Feature Image">`;

        if (report.html.includes('mag-content')) {
            report.html = report.html.replace('<div class="mag-content">', imgHTML + '<div class="mag-content">');
        } else if (report.html.includes('magazine-page')) {
            report.html = report.html.replace('<div class="magazine-page">', '<div class="magazine-page">' + imgHTML);
        } else {
            report.html = `<div class="mb-4 text-center">${imgHTML}</div>` + report.html;
        }
        
        saveGame();
        document.getElementById('archive-viewer').innerHTML = report.html;
    } else {
        alert("Error: Could not find the report to update.");
    }
}

        function deleteArchive(id, event) {
            event.stopPropagation();
            if(confirm("Delete this back issue permanently?")) {
                currentSave.history = currentSave.history.filter(h => h.id !== id);
                saveGame();
                renderArchiveList();
                document.getElementById('archive-viewer').innerHTML = '<div class="p-20 text-center text-slate-400">Select an issue.</div>';
                document.getElementById('archive-controls').classList.add('hidden');
            }
        }

       function publishAndArchive() { 
    const reportId = Date.now().toString(); 
    currentSave.history.push({ id: reportId, showName: activeShow.name, date: activeShow.date, html: generatedReportHTML, timestamp: new Date().toLocaleString() }); 
    
    const showIndex = currentSave.shows.findIndex(s => s.id === activeShow.id);
    if(showIndex !== -1) {
        currentSave.shows[showIndex].status = 'completed';
        currentSave.shows[showIndex].reportId = reportId;
    }

    // --- UPDATED: UPDATE RANKS BUT KEEP HISTORY ---
    // false = Do NOT reset the arrows to 0. Keep showing the movement.
    if (activeShow.type === 'weekly') {
        generatePowerRankings(activeShow.name, false); 
    }
    generatePowerRankings('global', false);
    
    // --- ADD THIS LINE HERE ---
    checkRivalryCompletions(); 
    // --------------------------


    saveGame(); 
    cardData = []; 
    activeShow = null; 
    renderArchiveList(); 
    renderCalendar(); 
    switchMainView('calendar'); 
    document.getElementById('report-modal').classList.add('hidden'); 
    alert("Report Archived! Rankings Updated."); 
}

        // --- ROSTER BELT LOGIC ---
        async function uploadBeltImage(divisionIndex, btn) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = async e => {
                const file = e.target.files[0];
                if(file) {
                    const base64 = await readImage(file);
                    const showKey = (rosterFilter === 'all' || rosterFilter === 'free') ? 'Global' : rosterFilter;
                    const key = `${showKey}-${divisionIndex}`;
                    currentSave.beltImages[key] = base64;
                    saveGame();
                    renderRoster();
                }
            };
            input.click();
        }
        
        function clearBeltImage(divisionIndex) {
            if(confirm("Remove belt image?")) {
                const showKey = (rosterFilter === 'all' || rosterFilter === 'free') ? 'Global' : rosterFilter;
                const key = `${showKey}-${divisionIndex}`;
                delete currentSave.beltImages[key];
                saveGame();
                renderRoster();
            }
        }
let rosterViewMode = 'official'; // 'official' or 'system'

function setRosterViewMode(mode) {
    rosterViewMode = mode;
    
    // 1. SAVE PREFERENCE
    if(!currentSave.settings) currentSave.settings = {};
    currentSave.settings.lastRosterMode = mode;
    saveGame();

    // 2. UPDATE BUTTON VISUALS
    updateRosterModeButtons(); // Extracted helper to reuse in switchMainView

    // 3. RENDER
    renderRoster();
}

// Helper function to update button styles (So we can call it on load too)
function updateRosterModeButtons() {
    const btnOff = document.getElementById('btn-view-official');
    const btnSys = document.getElementById('btn-view-system');
    
    if (btnOff && btnSys) {
        if (rosterViewMode === 'official') {
            btnOff.className = "px-3 py-1 rounded text-xs font-bold bg-blue-600 text-white shadow transition";
            btnSys.className = "px-3 py-1 rounded text-xs font-bold text-slate-400 hover:text-white transition";
        } else {
            btnSys.className = "px-3 py-1 rounded text-xs font-bold bg-purple-600 text-white shadow transition";
            btnOff.className = "px-3 py-1 rounded text-xs font-bold text-slate-400 hover:text-white transition";
        }
    }
}
     function renderRosterSidebar() { 
    const container = document.getElementById('roster-filters'); 
    container.innerHTML = ''; 
    
    // Helper to create the Main Filter Button
    const createFilterBtn = (id, label, style = '') => { 
        const active = rosterFilter === id ? 'active' : ''; 
        // Remove border radius if it's going to be part of a group
        return `<button onclick="setRosterFilter('${escapeStr(id)}')" class="roster-filter-btn flex-1 ${active}" style="${style}">${label}</button>`; 
    }; 
    
    // 1. STANDARD FILTERS (All)
    container.innerHTML += `<div class="mb-1">${createFilterBtn('all', '<i class="fa-solid fa-users mr-2"></i> All Roster', 'width:100%')}</div>`; 
    
    // --- UPDATED FREE AGENT LOGIC ---
    const uniqueShows = [...new Set(currentSave.shows.filter(s => s.type === 'weekly').map(s => s.name))];
    const freeAgents = currentSave.roster.filter(w => !w.shows || w.shows === "" || !uniqueShows.includes(w.shows));
    
    const freeTeams = [...new Set(freeAgents.filter(w => w.teamName).map(w => w.teamName))].sort();
    
    let faToggle = '';
    let faList = '';
    
    if (freeTeams.length > 0) {
        // New Layout: Full width button below
        faToggle = `<button onclick="toggleSidebarMenu('free-teams')" class="w-full text-xs text-left px-3 py-1 bg-slate-800 text-slate-500 hover:text-white border-t border-slate-700 flex items-center transition"><i class="fa-solid fa-caret-down mr-2"></i> Factions (${freeTeams.length})</button>`;
        
        faList = `<div id="menu-free-teams" class="hidden bg-slate-900/50 border-l-2 border-slate-700 ml-3 mt-1 pl-2 space-y-1 pb-2">
            ${freeTeams.map(t => `<button onclick="viewTeamMembers('${escapeStr(t)}')" class="block w-full text-left text-xs font-bold text-slate-400 hover:text-purple-400 py-1"><i class="fa-solid fa-users mr-2 text-[10px]"></i>${t}</button>`).join('')}
        </div>`;
    }

    // Wrap in a group div
    container.innerHTML += `
        <div class="mb-1 bg-slate-800 rounded-lg overflow-hidden border border-slate-700">
            ${createFilterBtn('free', `<i class="fa-solid fa-user-plus mr-2"></i> Free Agents`, 'width:100%; border:none; border-radius:0;')} 
            ${faToggle}
        </div>
        ${faList}`;
    
    // 2. SHOWS & THEIR FACTIONS
    uniqueShows.forEach(s => {
        // A. Visuals
        let showColor = "";
        const showRef = currentSave.shows.find(show => show.name === s);
        if(showRef && showRef.color) showColor = `border-left-color: ${showRef.color};`;
        
        let logoSrc = showRef ? showRef.logo : null;
        if (!logoSrc && currentSave.seriesConfig && currentSave.seriesConfig[s] && currentSave.seriesConfig[s].logo) {
            logoSrc = currentSave.seriesConfig[s].logo;
        }

        let labelHTML = `<i class="fa-solid fa-tv mr-2"></i> ${s}`;
        if (logoSrc) labelHTML = `<img src="${logoSrc}" class="roster-logo-sm mr-2"> ${s}`;

        // B. Find Teams
        const showRoster = currentSave.roster.filter(w => w.shows === s);
        const showTeams = [...new Set(showRoster.filter(w => w.teamName).map(w => w.teamName))].sort();

        // C. Build the Toggle & List
        let toggleBtn = '';
        let teamListHTML = '';
        
        if (showTeams.length > 0) {
            const menuId = `menu-${s.replace(/\s+/g, '-')}`;
            // New Layout: Full width button below
            toggleBtn = `<button onclick="toggleSidebarMenu('${menuId}')" class="w-full text-sm font-bold uppercase tracking-wide text-left px-3 py-1 bg-slate-800 text-slate-500 hover:text-white border-t border-slate-700 flex items-center transition"><i class="fa-solid fa-caret-down mr-2"></i> Factions (${showTeams.length})</button>`;
            
            teamListHTML = `<div id="${menuId}" class="hidden bg-slate-900/50 border-l-2 border-slate-700 ml-3 mt-1 pl-2 space-y-1 pb-2 transition-all">
                ${showTeams.map(t => `
                    <button onclick="viewTeamMembers('${escapeStr(t)}')" class="block w-full text-left text-xs font-bold text-slate-400 hover:text-purple-400 py-1 transition">
                        <i class="fa-solid fa-users mr-2 text-[10px]"></i>${t}
                    </button>
                `).join('')}
            </div>`;
        }

        // D. Render the Group
        container.innerHTML += `
        <div class="mb-1">
            <div class="bg-slate-800 rounded-lg overflow-hidden border border-slate-700">
                ${createFilterBtn(s, labelHTML, `${showColor} width:100%; border-right:none; border-top:none; border-bottom:none; border-radius:0;`)}
                ${toggleBtn}
            </div>
            ${teamListHTML}
        </div>`; 
    });
}

// 1. Toggle the sidebar sub-menus
function toggleSidebarMenu(id) {
    const el = document.getElementById(id);
    if(el) {
        if(el.classList.contains('hidden')) {
            el.classList.remove('hidden');
        } else {
            el.classList.add('hidden');
        }
    }
}

// 2. Show the Team Members Pop-up
function viewTeamMembers(teamName) {
    // 1. Find members
    const members = currentSave.roster.filter(w => w.teamName === teamName);
    
    // 2. Update Title & Store active team in hidden input (or dataset)
    const modalTitle = document.getElementById('team-modal-title');
    modalTitle.innerText = teamName;
    modalTitle.dataset.team = teamName; // Store for "Add" function
    
    // 3. Generate List HTML (With Remove Buttons)
    const listContainer = document.getElementById('team-modal-list');
    listContainer.innerHTML = '';
    
    if(members.length === 0) {
        listContainer.innerHTML = '<div class="text-sm italic opacity-50">No active members.</div>';
    } else {
        members.forEach(m => {
            let statusIcon = '';
            if(m.status === 'champ') statusIcon = '<i class="fa-solid fa-crown text-yellow-500 text-xs ml-1"></i>';
            
            listContainer.innerHTML += `
                <div class="flex items-center justify-between bg-slate-800 p-2 rounded mb-1">
                    <div class="flex items-center gap-2">
                        <span class="text-sm font-bold text-slate-200">${m.name}</span>
                        ${statusIcon}
                    </div>
                    <button onclick="removeTeamMember('${m.id}', '${escapeStr(teamName)}')" class="text-slate-500 hover:text-red-500 transition px-2" title="Remove from Faction">
                        <i class="fa-solid fa-xmark"></i>
                    </button>
                </div>
            `;
        });
    }
    
    // 4. Show "Add Member" Button
    listContainer.innerHTML += `
        <button onclick="openAddTeamMember('${escapeStr(teamName)}')" class="w-full mt-3 py-2 border border-dashed border-slate-600 text-slate-500 hover:text-white hover:border-slate-400 rounded text-xs transition uppercase font-bold">
            <i class="fa-solid fa-plus mr-1"></i> Add Member
        </button>
    `;
    
    // Show Modal
    document.getElementById('team-modal').classList.remove('hidden');
}
        function setRosterFilter(filter) { 
            rosterFilter = filter; 
            renderRosterSidebar(); 
            renderRoster(); 
        }

   function renderRoster() { 
    const container = document.getElementById('roster-container'); 
    container.innerHTML = ''; 
    document.getElementById('roster-view-title').innerText = rosterFilter === 'all' ? 'All Roster' : (rosterFilter === 'free' ? 'Free Agents' : rosterFilter); 
    
    // LOGO LOGIC
    const pageLogo = document.getElementById('roster-page-logo');
    if(rosterFilter !== 'all' && rosterFilter !== 'free') {
        const showRef = currentSave.shows.find(s => s.name === rosterFilter);
        let logoSrc = showRef ? showRef.logo : null;
        if (!logoSrc && currentSave.seriesConfig && currentSave.seriesConfig[rosterFilter]) {
            logoSrc = currentSave.seriesConfig[rosterFilter].logo;
        }
        if(logoSrc) { pageLogo.src = logoSrc; pageLogo.classList.remove('hidden'); } else { pageLogo.classList.add('hidden'); }
    } else { pageLogo.classList.add('hidden'); }

    // PREPARE DIVISIONS & ACTIVE SHOWS
    const uniqueShows = [...new Set(currentSave.shows.filter(s => s.type === 'weekly').map(s => s.name))]; 
    let currentDivNames = ["Division 1", "Division 2", "Division 3", "Division 4", "Division 5", "Division 6", "Division 7"]; 
    
    if (rosterFilter !== 'all' && rosterFilter !== 'free') { 
        if (!currentSave.showDivisions[rosterFilter]) currentSave.showDivisions[rosterFilter] = [...currentDivNames]; 
        currentDivNames = currentSave.showDivisions[rosterFilter]; 
    } 
    
    // --- RENDER EACH DIVISION ---
    currentDivNames.forEach((divName, index) => { 
        // 1. FILTER BY DIVISION
        let wrestlers = currentSave.roster.filter(w => {
            const wDiv = (rosterViewMode === 'system') ? w.systemDivision : w.division;
            return wDiv === index;
        });

        // 2. FILTER BY SHOW (UPDATED LOGIC)
        if (rosterFilter === 'free') {
            // FIX: If wrestler has no show OR their show is not in the active list (Orphan), show them here
            wrestlers = wrestlers.filter(w => !w.shows || w.shows === "" || !uniqueShows.includes(w.shows)); 
        } 
        else if (rosterFilter !== 'all') {
            wrestlers = wrestlers.filter(w => w.shows === rosterFilter); 
        }
        
        // Ensure Ranks Exist
        wrestlers.forEach((w, i) => { 
            if(w.rank === undefined) w.rank = i; 
            if(w.systemRank === undefined) w.systemRank = i; 
        }); 

        // 3. SORT
        wrestlers.sort((a,b) => { 
            if(a.status === 'champ') return -1; if(b.status === 'champ') return 1; 
            const rankA = (rosterViewMode === 'system') ? a.systemRank : a.rank;
            const rankB = (rosterViewMode === 'system') ? b.systemRank : b.rank;
            return rankA - rankB; 
        }); 
        
        // --- BUTTONS & STATES ---
        const showKey = (rosterFilter === 'all' || rosterFilter === 'free') ? 'Global' : rosterFilter;
        
        const beltKey = `${showKey}-${index}`;
        const beltImgSrc = currentSave.beltImages[beltKey];
        
        const divLockKey = `${showKey}-${index}`;
        if(!currentSave.lockedDivisions) currentSave.lockedDivisions = [];
        const isDivLocked = currentSave.lockedDivisions.includes(divLockKey);
        const lockIcon = isDivLocked ? 'fa-lock' : 'fa-unlock'; 
        const lockColor = isDivLocked ? 'text-red-500 hover:text-red-400' : 'text-slate-600 hover:text-white';
        const lockBtn = `<button onclick="toggleDivisionLock(${index})" class="${lockColor} text-xs mx-1" title="Lock Movement"><i class="fa-solid ${lockIcon}"></i></button>`;
        
        const divType = getDivisionType(index);
        let typeBadge = '';
        let typeTitle = "Standard Division";
        let btnColor = "text-slate-600 hover:text-white"; 
        let btnContent = '<i class="fa-solid fa-layer-group"></i>'; 

        if (divType === 'Women') {
            typeBadge = '<span class="bg-pink-600 text-white text-[10px] font-bold px-1 rounded ml-1">W</span>';
            btnColor = "text-pink-500 hover:text-pink-400";
            typeTitle = "Women's Division";
            btnContent = '<i class="fa-solid fa-venus"></i>';
        } 
        else if (divType === 'Tag') {
            typeBadge = '<span class="bg-purple-600 text-white text-[10px] font-bold px-1 rounded ml-1">TAG</span>';
            btnColor = "text-purple-500 hover:text-purple-400";
            typeTitle = "Tag Team Division";
            btnContent = '<i class="fa-solid fa-users"></i>';
        } 
        else if (divType === 'WomenTag') {
            typeBadge = '<span class="bg-pink-600 text-white text-[10px] font-bold px-1 rounded-l ml-1">W</span><span class="bg-purple-600 text-white text-[10px] font-bold px-1 rounded-r">TAG</span>';
            btnColor = "text-pink-400 hover:text-white";
            typeTitle = "Women's Tag Team Division";
            btnContent = '<i class="fa-solid fa-venus-mars"></i>';
        }

        const typeBtn = `<button onclick="toggleDivisionType(${index})" class="${btnColor} text-xs mx-1 px-2 py-1 bg-slate-800 rounded border border-slate-700 transition" title="${typeTitle} (Click to Toggle)">${btnContent}</button>`;

        let beltHTML = beltImgSrc 
            ? `<div class="relative group"><img src="${beltImgSrc}" class="h-10 w-auto object-contain cursor-pointer hover:opacity-80" onclick="uploadBeltImage(${index}, this)" title="Change Belt"><button onclick="clearBeltImage(${index})" class="absolute -top-2 -right-2 bg-red-600 text-white rounded-full w-4 h-4 flex items-center justify-center text-[10px] hidden group-hover:flex"><i class="fa-solid fa-xmark"></i></button></div>`
            : `<button onclick="uploadBeltImage(${index}, this)" class="text-xs text-slate-500 hover:text-white"><i class="fa-solid fa-trophy mr-1"></i></button>`;

        let listHTML = ''; 
        let rankCounter = 1; 
        
        const isDraggable = true; 
        
        wrestlers.forEach((w, visualIndex) => { 
            let badge = ''; 
            let rankDisplay = `<span class="text-slate-500 w-6 font-mono text-right mr-2">${rankCounter++}</span>`; 
            
            if(w.status === 'champ') { 
                if (beltImgSrc) {
                    badge = `<img src="${beltImgSrc}" class="h-5 w-auto object-contain ml-2 inline-block" title="Champion">`;
                } else {
                    badge = '<i class="fa-solid fa-crown text-yellow-500 ml-2"></i>'; 
                }
                rankDisplay = '<span class="text-yellow-500 w-6 font-bold text-right mr-2">C</span>'; 
                rankCounter--; 
            } 

            if(w.status === 'mitb') badge += '<i class="fa-solid fa-briefcase text-green-500 ml-2"></i>'; 
	    if(w.isLegend) {
                badge += '<span class="bg-yellow-600 text-white text-[10px] font-black px-1.5 rounded ml-2 shadow-sm border border-yellow-400" title="Legend Status">L</span>';
            }
            
            const isHeel = w.alignment === 'Heel';
            const alignClass = isHeel ? 'border-red-600 text-red-500 hover:bg-red-600 hover:text-white' : 'border-blue-500 text-blue-400 hover:bg-blue-500 hover:text-white';
            const alignLetter = isHeel ? 'H' : 'F';
            const alignBadge = `<button onclick="toggleAlignment('${w.id}')" class="ml-2 w-5 h-5 border ${alignClass} rounded flex items-center justify-center text-[10px] font-black transition cursor-pointer" title="Toggle Face/Heel">${alignLetter}</button>`;

            let teamBadge = '';
            if (w.teamName) {
                teamBadge = `<button onclick="assignTeam('${w.id}')" class="ml-2 px-2 py-0.5 border border-purple-500 text-purple-400 hover:bg-purple-500 hover:text-white rounded text-[10px] font-bold transition uppercase tracking-wider" title="Edit Team: ${w.teamName}"><i class="fa-solid fa-users mr-1"></i> ${w.teamName}</button>`;
            } else {
                teamBadge = `<button onclick="assignTeam('${w.id}')" class="ml-2 w-5 h-5 border border-slate-600 text-slate-600 hover:border-purple-500 hover:text-purple-500 rounded flex items-center justify-center text-[10px] transition" title="Create Tag Team"><i class="fa-solid fa-plus"></i></button>`;
            }

            let injClass = 'border-slate-700 text-slate-700 hover:border-green-500 hover:text-green-500'; 
            let injIcon = '<i class="fa-solid fa-heart-pulse"></i>';
            let injTitle = "Status: Healthy";
            let nameStyle = "text-white"; 

            if (w.injury === 'Light') { injClass = 'border-yellow-500 text-yellow-500 bg-yellow-900/10'; injIcon = '<i class="fa-solid fa-bandage"></i>'; injTitle = "Injury: Light"; } 
            else if (w.injury === 'Moderate') { injClass = 'border-orange-500 text-orange-500 bg-orange-900/20'; injIcon = '<i class="fa-solid fa-crutch"></i>'; injTitle = "Injury: Moderate"; } 
            else if (w.injury === 'Severe') { injClass = 'border-red-600 text-red-600 bg-red-900/30'; injIcon = '<i class="fa-solid fa-user-injured"></i>'; injTitle = "Injury: Severe"; nameStyle = "text-slate-500 line-through decoration-red-600 decoration-2"; }
            const injuryBadge = `<button onclick="toggleInjury('${w.id}')" class="ml-2 w-6 h-5 border ${injClass} rounded flex items-center justify-center text-[10px] transition" title="${injTitle}">${injIcon}</button>`;

            let showOptions = `<option value="">Free Agent</option>`; 
            uniqueShows.forEach(sName => { let selected = w.shows === sName ? 'selected' : ''; showOptions += `<option value="${sName}" ${selected}>${sName}</option>`; }); 
            
            let dragAttr = isDraggable ? `draggable="true" ondragstart="dragStart('${w.id}')" ondragover="dragOver(event)" ondrop="drop(event, ${index}, ${visualIndex})"` : '';
            let cursorClass = isDraggable ? 'cursor-move' : 'cursor-default opacity-90';

            listHTML += `<div ${dragAttr} class="wrestler-row flex flex-col bg-slate-900 p-2 rounded border border-slate-700 mb-1 ${cursorClass} group">
                <div class="flex justify-between items-center">
                    <div class="flex items-center text-sm font-bold flex-wrap gap-y-1 ${nameStyle}">
                        ${rankDisplay} ${w.name}${alignBadge}${teamBadge}${injuryBadge}${badge}
                    </div>
                   <div class="flex gap-2 opacity-0 group-hover:opacity-100 transition">
                        <button onclick="toggleLegend('${w.id}')" class="text-slate-600 hover:text-yellow-500" title="Toggle Legend Status"><i class="fa-solid fa-medal"></i></button>
                        
                        <button onclick="setRosterStatus('${w.id}', 'champ')" class="text-slate-600 hover:text-yellow-500" title="Toggle Champion"><i class="fa-solid fa-crown"></i></button>
                        <button onclick="setRosterStatus('${w.id}', 'mitb')" class="text-slate-600 hover:text-green-500" title="Toggle MITB"><i class="fa-solid fa-briefcase"></i></button>
                        <button onclick="deleteWrestler('${w.id}')" class="text-slate-600 hover:text-red-500" title="Release"><i class="fa-solid fa-xmark"></i></button>
                    </div>
                </div>
                <div class="mt-1"><select onchange="updateWrestlerShow('${w.id}', this.value)" class="bg-slate-900 text-white text-xs border border-slate-600 rounded w-full p-1 focus:border-blue-500" ${!isDraggable ? 'disabled' : ''}>${showOptions}</select></div>
            </div>`; 
        });
        
        let nameInput = (rosterFilter !== 'all' && rosterFilter !== 'free') 
            ? `<input type="text" value="${divName}" onchange="renameDivision(${index}, this.value)" class="bg-transparent font-bold text-white uppercase text-sm border-none focus:bg-slate-800 w-1/2">` 
            : `<span class="font-bold text-white uppercase text-sm w-3/4">${divName}</span>`; 
        
        let dropAttr = isDraggable ? `ondragover="allowDrop(event)" ondrop="dropOnDivision(event, ${index})"` : '';

        container.innerHTML += `<div ${dropAttr} class="division-container bg-slate-800 rounded-xl border border-slate-700 overflow-hidden flex flex-col h-full"><div class="bg-slate-900 p-3 border-b border-slate-700 flex justify-between items-center shrink-0"><div class="flex items-center gap-2">${beltHTML} ${nameInput} ${typeBadge}</div> <div class="flex items-center">${typeBtn} ${lockBtn} <span class="bg-slate-700 text-xs px-2 rounded text-white ml-2">${wrestlers.length}</span></div></div><div class="p-3 overflow-y-auto grow flex-1 h-96">${listHTML || '<div class="text-slate-500 text-xs italic text-center mt-4">Drag wrestlers here</div>'}</div></div>`; 
    });
}

// --- ROSTER SYNC LOGIC ---
function runRosterSync(direction) {
    let confirmMsg = "";
    
    if (direction === 'manual_to_system') {
        confirmMsg = "⚠️ OVERWRITE SYSTEM TRACKER?\n\nThis will force the System Tracker to match your Manual placements.\n\nThe system's mathematical rankings will be lost and replaced by your custom order.\n\nContinue?";
    } else {
        confirmMsg = "⚠️ OVERWRITE MANUAL ROSTER?\n\nThis will reset your Manual Booking view to match the System's calculated rankings.\n\nAny custom drag-and-drop changes you made will be undone.\n\nContinue?";
    }

    if (!confirm(confirmMsg)) return;

    currentSave.roster.forEach(w => {
        if (direction === 'manual_to_system') {
            // Apply God Mode (Manual) to the Math (System)
            w.systemDivision = w.division;
            w.systemRank = w.rank;
        } else {
            // Apply Math (System) to God Mode (Manual)
            w.division = w.systemDivision;
            w.rank = w.systemRank;
        }
    });

    saveGame();
    renderRoster();
    document.getElementById('sync-modal').classList.add('hidden');
    
    // Simple success feedback
    alert("Sync Complete!");
    
    // Visual Feedback
    const msg = direction === 'manual_to_system' ? "System Tracker updated to match Manual." : "Manual Roster updated to match System.";
    alert(msg);
}
       function toggleRecurrenceFields(val, selected = []) {
            const container = document.getElementById('brand-select-container');
            const checkboxContainer = document.getElementById('brand-checkboxes');
            const annualContainer = document.getElementById('annual-option-container'); // NEW

            if (val === 'special') {
                container.classList.remove('hidden');
                if(annualContainer) annualContainer.classList.remove('hidden'); // Show Annual Option
                
                checkboxContainer.innerHTML = '';
                
                const weeklyShows = [...new Set(currentSave.shows.filter(s => s.type === 'weekly').map(s => s.name))];
                
                if(weeklyShows.length === 0) {
                    checkboxContainer.innerHTML = '<div class="text-slate-500 text-xs italic">No weekly shows created yet.</div>';
                } else {
                    weeklyShows.forEach(showName => {
                        const isChecked = selected.includes(showName) ? 'checked' : '';
                        checkboxContainer.innerHTML += `
                            <label class="flex items-center gap-2 text-slate-300 text-xs cursor-pointer hover:text-white">
                                <input type="checkbox" value="${showName}" ${isChecked} class="rounded bg-slate-700 border-slate-600 text-blue-600">
                                ${showName}
                            </label>
                        `;
                    });
                }
            } else {
                container.classList.add('hidden');
                if(annualContainer) annualContainer.classList.add('hidden'); // Hide Annual Option
            }
        }

        // --- UPDATED SAVE SHOW (FIXED: CENTRALIZED LOGOS TO SAVE SPACE) ---
        async function saveShowToCalendar() { 
            const id = document.getElementById('edit-show-id').value; 
            const date = document.getElementById('show-date').value; 
            const name = document.getElementById('show-name').value; 
            const arena = document.getElementById('show-arena').value; 
            const recurrence = document.getElementById('show-recurrence').value; 
            const color = document.getElementById('show-color-picker').value;
            const logoFile = document.getElementById('show-logo-upload').files[0];
            
            let logoBase64 = null;
            if(logoFile) {
                logoBase64 = await readImage(logoFile);
            } else if (id && !logoRemoved) {
                const existing = currentSave.shows.find(s => String(s.id) === String(id));
                if(existing) logoBase64 = existing.logo;
            }

            if(!name || !date) return; 
            
            const commentators = {
                pbp: { name: document.getElementById('comm-pbp-name').value, style: document.getElementById('comm-pbp-style').value },
                color: { name: document.getElementById('comm-color-name').value, style: document.getElementById('comm-color-style').value },
                interviewer: { name: document.getElementById('comm-int-name').value, style: document.getElementById('comm-int-style').value }
            };

            const checkboxes = document.querySelectorAll('#brand-checkboxes input:checked'); 
            const participants = Array.from(checkboxes).map(cb => cb.value); 
            
            if(id) { 
                const show = currentSave.shows.find(s => String(s.id) === String(id)); 
                if(show) {
                    show.date = date; show.name = name; show.arena = arena; show.type = recurrence; show.commentators = commentators; show.color = color;


 		    // --- SAFETY: Prevent cross-brand roster bleed (esp. after New Year / schedule rollovers) ---
                    // Only SPECIAL events are allowed to have 'participatingShows'.
                    // If a show used to be special and is later saved as weekly, leaving 'participatingShows'
                    // behind will cause the booking dropdown to pull the wrong roster pool.
                    if (show.type !== 'special') {
                        delete show.participatingShows;
                    }
                    if (show.type === 'weekly') {
                        // Weekly logos are stored centrally in seriesConfig; keep per-instance logo clean.
                        show.logo = null;
                    }

                    
                    // IF SPECIAL: Save logo directly to object
                    if(recurrence === 'special') {
                        show.logo = logoBase64; 
                        show.participatingShows = participants; 
                    } 
                    
                    // IF WEEKLY: Save logo centrally to seriesConfig to save space
                    if (show.type === 'weekly') {
                        if (!currentSave.seriesConfig) currentSave.seriesConfig = {};
                        if (!currentSave.seriesConfig[show.name]) currentSave.seriesConfig[show.name] = {};
                        currentSave.seriesConfig[show.name].commentators = commentators;
                        
                        // Save the logo centrally if updated
                        if (logoBase64) {
                            currentSave.seriesConfig[show.name].logo = logoBase64;
                        }

                        // Propagate settings, but NULLIFY individual logos to save storage
                        currentSave.shows.forEach(s => {
                            if (s.name === show.name && s.type === 'weekly') {
                                s.commentators = commentators; 
                                s.color = color; 
                                // Remove individual logo to prevent storage explosion
                                s.logo = null; 
                            }
                        });
                    }
                    if(activeShow && String(activeShow.id) === String(id)) { activeShow = show; if(document.getElementById('view-dashboard').classList.contains('hidden-view') === false) loadShow(id); } 
                }
            } else { 
                // Creating NEW Show
                let useLogo = logoBase64;
                if (recurrence === 'weekly') {
                     if (!currentSave.seriesConfig) currentSave.seriesConfig = {};
                     if (!currentSave.seriesConfig[name]) currentSave.seriesConfig[name] = {};
                     currentSave.seriesConfig[name].commentators = commentators;
                     
                     if(logoBase64) {
                         currentSave.seriesConfig[name].logo = logoBase64;
                         useLogo = null; 
                     }
                }

                const newShows = []; 
                if(recurrence === 'special') { 
                    // 1. Create This Year's Show
                    newShows.push({ id: Date.now().toString(), date, name, arena, status: 'planned', type: 'special', segments: [], participatingShows: participants, commentators, color, logo: useLogo }); 
                    
                   // 2. NEW: Annual Recurrence Logic (Smart Weekday Matching)
                    if(document.getElementById('show-is-annual').checked) {
                        try {
                            // A. Parse Original Date (YYYY-MM-DD)
                            const [y, m, d] = date.split('-').map(Number); // Avoid timezone shifts
                            const sourceDate = new Date(y, m - 1, d);
                            
                            const weekday = sourceDate.getDay(); // 0 = Sunday, 1 = Monday...
                            const nthOccurrence = Math.ceil(d / 7); // Was it the 1st, 2nd, 3rd, or 4th Sunday?
                            
                            // B. Find Same Spot Next Year
                            const targetYear = y + 1;
                            const targetMonth = m - 1; 
                            
                            // Start at the 1st of the target month next year
                            let futureDate = new Date(targetYear, targetMonth, 1);
                            
                            // Advance to the first occurrence of that weekday
                            while (futureDate.getDay() !== weekday) {
                                futureDate.setDate(futureDate.getDate() + 1);
                            }
                            
                            // Jump to the correct Nth occurrence (e.g. add 1 week if it was the 2nd Sunday)
                            futureDate.setDate(futureDate.getDate() + (nthOccurrence - 1) * 7);
                            
                            // Edge Case: If original was a "5th Sunday" and next year only has 4, 
                            // the math above puts us in the Next Month. We roll back to the 4th (Last) Sunday.
                            if (futureDate.getMonth() !== targetMonth) {
                                futureDate.setDate(futureDate.getDate() - 7);
                            }
                            
                            // C. Format Result as YYYY-MM-DD
                            const nextDateStr = `${futureDate.getFullYear()}-${String(futureDate.getMonth()+1).padStart(2,'0')}-${String(futureDate.getDate()).padStart(2,'0')}`;
                            
                            // Create Future Show
                            newShows.push({ 
                                id: (Date.now() + 100).toString(), 
                                date: nextDateStr, 
                                name, 
                                arena, 
                                status: 'planned', 
                                type: 'special', 
                                segments: [], 
                                participatingShows: participants, 
                                commentators, 
                                color, 
                                logo: useLogo 
                            });
                            
                            alert(`Scheduled ${name} for ${date} and ${nextDateStr}`);
                        } catch(e) {
                            console.error("Date Error:", e);
                        }
                    }
                } else { 
    // --- DST SAFE WEEKLY SCHEDULER ---
    
    // 1. Parse Input Date explicitly (YYYY, MM, DD)
    const [y, m, d] = date.split('-').map(Number);
    
    // 2. Set Cursor to NOON (12:00) Local Time
    // Setting it to Noon prevents DST shifts (midnight +/- 1hr) from changing the day
    let cursor = new Date(y, m - 1, d, 12, 0, 0); 
    
    // 3. Define End of Year
    const targetYear = cursor.getFullYear();
    
    while(cursor.getFullYear() === targetYear) { 
        // 4. Manually format string to avoid UTC conversion errors
        // usage: YYYY-MM-DD
        const dateStr = `${cursor.getFullYear()}-${String(cursor.getMonth()+1).padStart(2,'0')}-${String(cursor.getDate()).padStart(2,'0')}`;
        
        newShows.push({ 
            id: Date.now().toString() + Math.random(), 
            date: dateStr, 
            name, 
            arena, 
            status: 'planned', 
            type: 'weekly', 
            segments: [], 
            commentators, 
            color, 
            logo: null 
        }); 
        
        // 5. Add 7 Days
        cursor.setDate(cursor.getDate() + 7); 
    } 
}
                currentSave.shows.push(...newShows); 
            }
            saveGame(); renderCalendar(); document.getElementById('show-modal').classList.add('hidden'); 
        }
        
        function clearShowLogo() {
            document.getElementById('show-logo-upload').value = "";
            logoRemoved = true;
            alert("Logo removed (Click Save to apply)");
        }

        // --- Standard Functions ---
        function navigateShow(direction) { if(!activeShow) return; const sortedShows = currentSave.shows.slice().sort((a,b) => new Date(a.date) - new Date(b.date)); const currentIndex = sortedShows.findIndex(s => s.id === activeShow.id); let newIndex = currentIndex + direction; if(newIndex >= 0 && newIndex < sortedShows.length) { loadShow(sortedShows[newIndex].id); } }
        function exitLiveShow() { document.getElementById('status-badge').innerText = "PLANNING"; document.getElementById('status-badge').classList.replace('bg-red-600', 'bg-blue-600'); document.getElementById('status-badge').classList.remove('live-indicator'); document.getElementById('planner-actions').classList.remove('hidden'); document.getElementById('live-actions').classList.add('hidden'); document.getElementById('subview-planner').classList.remove('hidden'); document.getElementById('subview-live').classList.add('hidden'); }
        function startLiveShow() { if(cardData.length === 0) return alert("Add segments first!"); document.getElementById('status-badge').innerText = "ON AIR"; document.getElementById('status-badge').classList.replace('bg-blue-600', 'bg-red-600'); document.getElementById('status-badge').classList.add('live-indicator'); document.getElementById('planner-actions').classList.add('hidden'); document.getElementById('live-actions').classList.remove('hidden'); renderLiveFeed(); document.getElementById('subview-planner').classList.add('hidden'); document.getElementById('subview-live').classList.remove('hidden'); }
        function renderRankingSidebar() { 
    const container = document.getElementById('ranking-filters'); 
    container.innerHTML = ''; 
    
    // Helper to create buttons
    const createBtn = (id, label) => { 
        const active = rankingFilter === id ? 'active' : ''; 
        return `<button onclick="setRankingFilter('${escapeStr(id)}')" class="roster-filter-btn w-full ${active}">${label}</button>`; 
    }; 
    
    // 1. Render Filters
    container.innerHTML += createBtn('global', '<i class="fa-solid fa-earth-americas mr-2"></i> All Universe'); 
    const uniqueShows = [...new Set(currentSave.shows.filter(s => s.type === 'weekly').map(s => s.name))]; 
    uniqueShows.forEach(s => container.innerHTML += createBtn(s, `<i class="fa-solid fa-tv mr-2"></i> ${s}`)); 
    
    // 2. Add The SYNC Button (New)
    container.innerHTML += `
        <div class="mt-4 pt-4 border-t border-slate-700 space-y-3">
            
            <div>
                <button onclick="openRankingSyncModal()" class="w-full bg-slate-800 hover:bg-slate-700 text-slate-300 hover:text-white border border-slate-600 px-3 py-2 rounded font-bold text-xs uppercase tracking-wider transition flex items-center justify-center gap-2">
                    <i class="fa-solid fa-rotate"></i> Sync Lists
                </button>
                <p class="text-[10px] text-slate-500 text-center mt-1">Copy Manual to System or vice versa</p>
            </div>

            <div>
                <button onclick="generatePowerRankings(); refreshRankingsIfVisible(); alert('System Rankings Recalculated!');" class="w-full bg-green-900/20 hover:bg-green-900/50 text-green-400 hover:text-white border border-green-800 px-3 py-2 rounded font-bold text-xs uppercase tracking-wider transition flex items-center justify-center gap-2">
                    <i class="fa-solid fa-calculator"></i> Recalc Math
                </button>
                <p class="text-[10px] text-slate-500 text-center mt-1">Force update based on recent matches</p>
            </div>

        </div>
    `;
}
        // --- UPDATED NAVIGATION & PERSISTENCE ---

function setRankingFilter(filter) { 
    rankingFilter = filter; 
    
    // Save preference
    if(!currentSave.settings) currentSave.settings = {};
    currentSave.settings.lastRankFilter = filter;
    saveGame(); // Persist immediately

    renderRankingSidebar(); 
    renderRankings(); 
}

function toggleRankingMode() { 
    const radio = document.querySelector('input[name="rank-mode"]:checked');
    if(radio) {
        rankingMode = radio.value;
        
        // Update Badge UI
        const badge = document.getElementById('ranking-mode-badge');
        if(rankingMode === 'ai') { 
            badge.innerText = "SYSTEM TRACKER"; 
            badge.className = "bg-purple-900 text-purple-200 text-xs font-bold px-2 py-1 rounded border border-purple-500"; 
        } else { 
            badge.innerText = "MANUAL MODE"; 
            badge.className = "bg-blue-900 text-blue-200 text-xs font-bold px-2 py-1 rounded border border-blue-500"; 
        }

        // Save preference
        if(!currentSave.settings) currentSave.settings = {};
        currentSave.settings.lastRankMode = rankingMode;
        saveGame(); // Persist immediately

        renderRankings(); 
    }
}

// --- NEW POWER RANKINGS RENDERER ---
function refreshRankingsIfVisible() {
    const view = document.getElementById('view-rankings');
    if(view && !view.classList.contains('hidden-view')) {
        try { renderRankingSidebar(); } catch(e) {}
        try { renderRankings(); } catch(e) {}
    }
}

// --- OVERHAULED RANKINGS DISPLAY (With Missing Wrestler Fix) ---
function renderRankings() { 
    // 1. SETUP UI TEXT & IMAGES
    const subtitle = document.getElementById('ranking-hero-subtitle');
    if(subtitle) subtitle.innerText = rankingFilter === 'global' ? 'Global Standings' : `${rankingFilter} Division`;

    const imgEl = document.getElementById('ranking-hero-img');
    let featureSrc = "Inside Count Start.jpg"; 
    
    // Feature Image Logic
    if (currentSave.powerRankings[rankingFilter] && currentSave.powerRankings[rankingFilter].featureImage) {
        featureSrc = currentSave.powerRankings[rankingFilter].featureImage;
    } else if (rankingFilter !== 'global') {
        if (currentSave.seriesConfig && currentSave.seriesConfig[rankingFilter] && currentSave.seriesConfig[rankingFilter].logo) {
            featureSrc = currentSave.seriesConfig[rankingFilter].logo;
        } else {
            const show = currentSave.shows.find(s => s.name === rankingFilter);
            if (show && show.logo) featureSrc = show.logo;
        }
    }
    if(imgEl) imgEl.src = featureSrc;

    // 2. GET DATA
    if (!currentSave.powerRankings[rankingFilter]) { currentSave.powerRankings[rankingFilter] = { manual: [], ai: [] }; } 
    
    // --- FIX START: AUTO-POPULATE MISSING WRESTLERS (MANUAL MODE ONLY) ---
    if (rankingMode === 'manual') {
        let manualList = currentSave.powerRankings[rankingFilter].manual || [];
        
        // 1. Get the list of names already ranked manually (Handle objects or strings)
        const rankedNames = manualList.map(entry => (typeof entry === 'object') ? entry.name : entry);
        
        // 2. Get the list of ALL wrestlers who SHOULD be here
        let eligibleRoster = [];
        if (rankingFilter === 'global') {
            eligibleRoster = currentSave.roster.filter(w => w.status !== 'inactive');
        } else {
            eligibleRoster = currentSave.roster.filter(w => w.shows === rankingFilter && w.status !== 'inactive');
        }

        // 3. Find who is missing
        const missing = eligibleRoster.filter(w => !rankedNames.includes(w.name));
        
        // 4. Append missing wrestlers to the bottom of the manual list
        if (missing.length > 0) {
            missing.forEach(w => {
                // Add as a simple object to match the structure
                manualList.push({ name: w.name, score: 0, prevRank: 999 });
            });
            // Update the source data so the change sticks
            currentSave.powerRankings[rankingFilter].manual = manualList;
        }
    }
    // --- FIX END ---

    const listData = currentSave.powerRankings[rankingFilter][rankingMode];
    
    // 3. CLEAR COLUMNS
    const col1 = document.getElementById('ranking-col-1');
    const col2 = document.getElementById('ranking-col-2');
    const col3 = document.getElementById('ranking-col-3');
    
    if(col1) col1.innerHTML = ''; 
    if(col2) col2.innerHTML = ''; 
    if(col3) col3.innerHTML = '';

    if (!listData || listData.length === 0) { 
        if(col1) col1.innerHTML = `<div class="text-slate-500 italic p-4">No rankings available. Switch to System Tracker or Drag Wrestlers here.</div>`;
        return; 
    } 

    // 4. RENDER LOOP
    let htmlLeft = '';
    let htmlRight = '';
    let htmlBottom = '';

    listData.forEach((entry, index) => {
        try {
            const rank = index + 1;
            
            // Safe Data Access
            let name = typeof entry === 'object' ? entry.name : entry;
            let score = (typeof entry === 'object' && entry.score) ? entry.score : 0;
            let prevRank = (typeof entry === 'object' && typeof entry.prevRank === 'number') ? entry.prevRank : 999;
            let blurb = (typeof entry === 'object' && entry.blurb) ? entry.blurb : "";
            
            // Belt Logic
            const w = currentSave.roster.find(r => r.name === name);
            
            // Safety check: If wrestler was deleted but still in rankings, skip rendering
            if (!w) return; 

            let beltHTML = '';
            
            if (w.status === 'champ') {
                const showKey = (w.shows && w.shows !== "") ? w.shows : 'Global';
                const divIndex = w.division !== undefined ? w.division : 0;
                const beltKey = `${showKey}-${divIndex}`;
                
                if (currentSave.beltImages[beltKey]) {
                    beltHTML = `<img src="${currentSave.beltImages[beltKey]}" class="h-6 w-auto object-contain drop-shadow-md ml-auto" title="Champion">`;
                } else {
                    beltHTML = `<i class="fa-solid fa-crown text-yellow-500 text-sm drop-shadow-md ml-auto"></i>`;
                }
            }

            // --- ROBUST MOVEMENT LOGIC ---
            let trendIcon = '';
            
            if (prevRank === 999) {
                trendIcon = `<span class="bg-blue-600 text-white text-[9px] font-bold px-1 rounded uppercase">NEW</span>`;
            } else {
                const diff = prevRank - rank;
                if (diff > 0) {
                    trendIcon = `<span class="text-green-500 font-bold text-xs flex items-center gap-1"><i class="fa-solid fa-caret-up"></i>${diff}</span>`;
                } else if (diff < 0) {
                    trendIcon = `<span class="text-red-500 font-bold text-xs flex items-center gap-1"><i class="fa-solid fa-caret-down"></i>${Math.abs(diff)}</span>`;
                } else {
                    trendIcon = `<span class="text-slate-500 font-bold text-xs flex items-center justify-center w-4">•</span>`;
                }
            }

            // Drag Attributes
            let dragAttr = '';
            let cursorClass = '';
            if (rankingMode === 'manual') {
                dragAttr = `draggable="true" ondragstart="rankDragStart(${index})" ondragover="rankDragOver(event)" ondrop="rankDrop(event, ${index})"`;
                cursorClass = 'cursor-move hover:ring-2 hover:ring-blue-500 hover:z-50';
            }

            // --- HTML GENERATION ---

            // TOP 10 (Left Column)
            if (rank <= 10) {
                let blurbHTML = blurb ? `<div class="rank-blurb">${blurb}</div>` : '';
                htmlLeft += `
                    <div class="rank-card-top10 ${cursorClass}" ${dragAttr}>
                        <div class="rank-row-top">
                            <div class="rank-number-big">${rank}</div>
                            <div class="flex-1 min-w-0 pl-3">
                                <div class="rank-identity-box">
                                    <h4 class="truncate">${name}</h4> 
                                    ${beltHTML}
                                </div>
                                <div class="flex justify-between items-center mt-1 pr-1">
                                    <div class="text-[9px] text-slate-400 font-bold uppercase">PWR: ${score}</div>
                                    ${trendIcon}
                                </div>
                            </div>
                        </div>
                        ${blurbHTML}
                    </div>`;
            } 
            // 11-20 (Right Column)
            else if (rank <= 20) {
                htmlRight += `
                    <div class="rank-card-mid ${cursorClass}" ${dragAttr}>
                        <div class="rank-number-mid">${rank}</div>
                        <div class="flex-1 min-w-0 flex items-center justify-between">
                             <div class="font-bold text-white text-xs truncate">${name}</div>
                             ${beltHTML}
                        </div>
                        <div class="flex flex-col items-end min-w-[40px] justify-center">
                            <div class="text-[9px] text-slate-500 mb-1">PWR: ${score}</div>
                            ${trendIcon}
                        </div>
                    </div>`;
            }
            // 21+ (Bottom Section)
            else {
                htmlBottom += `
                    <div class="bg-slate-800 p-2 rounded border-l-2 border-slate-600 ${cursorClass} grid grid-cols-[24px_1fr_auto_auto] gap-2 items-center" ${dragAttr}>
                        <span class="font-mono text-slate-500 text-xs text-right">${rank}</span>
                        <span class="text-xs text-slate-300 font-bold truncate" title="${name}">${name}</span>
                        <div class="flex justify-end min-w-[40px]">
                            ${trendIcon}
                        </div>
                        <div class="w-6 flex justify-center">
                            ${beltHTML}
                        </div>
                    </div>`;
            }
        } catch (err) {
            console.error("Error rendering rank " + index, err);
        }
    });

    if(col1) col1.innerHTML = htmlLeft;
    if(col2) col2.innerHTML = htmlRight;
    if(col3) col3.innerHTML = htmlBottom;
}


// --- MISSING HELPER FUNCTION ---
function getRecentMatchHistory(name, limit = 5) {
    if (!currentSave || !currentSave.shows) return [];
    
    // 1. Get all completed shows sorted by Date (Newest First)
    const completedShows = currentSave.shows
        .filter(s => s.status === 'completed')
        .sort((a, b) => new Date(b.date) - new Date(a.date));

    let matches = [];

    // 2. Dig through shows to find matches involving this wrestler
    for (const show of completedShows) {
        if (!show.segments) continue;

        // Find matches in this show where they participated AND there is a result
        // We reverse() so we see the Main Event of that night before the Opener (More recent)
        const showMatches = show.segments
            .filter(seg => 
                seg.type === 'match' && 
                seg.actual_winner && 
                seg.participants && 
                seg.participants.includes(name)
            )
            .reverse();

        matches.push(...showMatches);

        if (matches.length >= limit) break;
    }

    return matches.slice(0, limit);
}


// =========================================
// POWER RANKINGS ENGINE (Calculations Preserved, Movement Fixed)
// =========================================

function generatePowerRankings(targetScope = null, resetBaseline = false) {
    if (!currentSave.roster || currentSave.roster.length === 0) return;
    
    // 1. Determine Scope
    const scope = targetScope || rankingFilter;
    
    if (!currentSave.powerRankings) currentSave.powerRankings = { global: { manual: [], ai: [] } };
    if (!currentSave.powerRankings[scope]) currentSave.powerRankings[scope] = { manual: [], ai: [] };

    // --- SNAPSHOT OLD LIST ---
    const previousList = currentSave.powerRankings[scope].ai || [];

    // 2. Filter Roster
    let pool = [];
    if (scope === 'global') {
        pool = currentSave.roster.filter(w => w.status !== 'inactive');
    } else {
        pool = currentSave.roster.filter(w => w.shows === scope && w.status !== 'inactive');
    }

    if(pool.length === 0 && !targetScope) return alert("No wrestlers found for this filter.");
    if(pool.length === 0) return; 

    // 3. CALCULATE SCORES (MATH UNCHANGED)
    const scoredRoster = pool.map(w => {
        if (!w.stats) w.stats = { popularity: 70, momentum: 50 }; 

        // FACTORS
        let aura = w.stats.popularity || 50;
        if (w.status === 'champ') aura += 15; 
        if (aura > 100) aura = 100;

        let storyScore = 50;
        const activeRiv = currentSave.rivalries.find(r => r.sides.flat().includes(w.name));
        if (activeRiv) storyScore += 25; 
        
        const lastShows = currentSave.shows.filter(s => s.status === 'completed').slice(-2);
        lastShows.forEach(s => {
            const lastSeg = s.segments[s.segments.length - 1];
            if (lastSeg && lastSeg.participants && lastSeg.participants.includes(w.name)) storyScore += 15;
        });
        if (storyScore > 100) storyScore = 100;

        let momentumRaw = w.stats.momentum || 50;
        let momentumVar = momentumRaw - 50; 

        let matchScore = 70; 
        const history = getRecentMatchHistory(w.name, 5);
        if (history.length > 0) {
            const totalStars = history.reduce((acc, m) => acc + parseFloat(m.stars || 2.5), 0);
            matchScore = (totalStars / history.length) * 20; 
        }

        let legacyBonus = w.isLegend ? ((history.length > 0) ? 20 : 5) : 0; 

        let totalScore = (aura * 0.35) + (storyScore * 0.25) + (momentumVar) + (matchScore * 0.20) + legacyBonus;

        if (aura < 70 && matchScore > 85) totalScore += 10; 
        if (aura > 90 && storyScore > 80) totalScore = Math.max(totalScore, 85);

        // --- ARROW LOGIC FIX ---
        // Find them in the EXISTING list to see where they were LAST time
        const oldEntry = previousList.find(e => e.name === w.name);
        const oldIndex = previousList.findIndex(e => e.name === w.name);
        
        let contextualPrevRank = 999;

        if (resetBaseline) {
            // END OF WEEK / RESET: 
            // We lock in their current position (oldIndex + 1) as the new baseline for next week.
            contextualPrevRank = (oldIndex !== -1) ? oldIndex + 1 : 999;
        } else {
            // MID-WEEK / UPDATE: 
            // We must PRESERVE the baseline from the start of the week.
            if (oldEntry && oldEntry.prevRank) {
                contextualPrevRank = oldEntry.prevRank;
            } else {
                // If they weren't in the list before, they are new (999)
                contextualPrevRank = 999;
            }
        }

        return {
            name: w.name,
            score: Math.floor(totalScore),
            prevRank: contextualPrevRank,
            details: { aura, storyScore, momentumVar, matchScore }
        };
    });

    // 4. SORT
    scoredRoster.sort((a, b) => b.score - a.score);

    // 5. UPDATE DATA
    currentSave.powerRankings[scope].ai = scoredRoster; 
    
    // 6. SYNC TO ROSTER (Global Only)
    if (scope === 'global') {
        scoredRoster.forEach((entry, i) => {
            const w = currentSave.roster.find(r => r.name === entry.name);
            if(w) w.systemRank = i + 1; 
        });
    }

    // 7. RENDER (Only if viewing this list)
    if (scope === rankingFilter) {
        renderRankings();
    } else {
        saveGame();
    }
}
       async function aiBookShow() { 
    const prompt = document.getElementById('booker-prompt').value; 
    const key = localStorage.getItem('openai_key'); 
    if(!key) return alert("API Key required"); 
    
    document.getElementById('ai-loading').classList.remove('hidden'); 
    
  // 1. Build Context (Roster with Hierarchy & Types)
    let availableObjects = []; 
    // Filter roster based on show participation
    if (activeShow.type === 'special' && activeShow.participatingShows?.length > 0) { 
        availableObjects = currentSave.roster.filter(w => activeShow.participatingShows.includes(w.shows)); 
    } else { 
        availableObjects = currentSave.roster.filter(w => w.shows === activeShow.name); 
    }

// --- LOGIC UPDATE: CHECK ACTIVE VIEW MODE ---
    const isSystemMode = (rosterViewMode === 'system');
    const modeLabel = isSystemMode ? "SYSTEM PERFORMANCE TRACKER (Merit-Based)" : "OFFICIAL ROSTER (Booker's Choice)";

    // Build the Rich Context String
    let rosterContext = `ROSTER HIERARCHY [Source: ${modeLabel}]:\n`;
    
// --- SMART ROSTER CONTEXT HELPER (COMPLETE) ---
    // Output Example: "Roman Reigns [Heel, Team: The Bloodline, Champion, Legend]"
    const getNameWithTags = (w) => {
        let tags = [];
        
        // 1. Alignment (Face/Heel)
        if (w.alignment) tags.push(w.alignment); 
        
        // 2. Faction / Tag Team
        if (w.teamName) tags.push(`Team: ${w.teamName}`);

        // 3. Legend Status
        if (w.isLegend) tags.push("Legend");
        
        // 4. MITB
        if (w.status === 'mitb') tags.push("MITB Holder");
        
        // 5. Injuries
        if (w.injury && w.injury !== 'Healthy') tags.push(`${w.injury} Injury`);
        
        if (tags.length === 0) return w.name;
        return `${w.name} [${tags.join(', ')}]`;
    };

    // A. Champions First
    const champs = availableObjects.filter(w => w.status === 'champ');
    if(champs.length > 0) {
        // Now using the helper to include tags for champs too (e.g. Roman Reigns [Heel])
        const champList = champs.map(w => getNameWithTags(w)).join(', ');
        rosterContext += `👑 CHAMPIONS (Book Strong): ${champList}\n`;
    }

    // B. Group by Division
    const grouped = {};
    availableObjects.filter(w => w.status !== 'champ').forEach(w => {
        const div = isSystemMode ? (w.systemDivision ?? 6) : (w.division ?? 6);
        
        if(!grouped[div]) grouped[div] = [];
        
        // USE THE HELPER HERE
        grouped[div].push(getNameWithTags(w)); 
    });

    // C. Add to string with TYPE Labels (Women, Tag, etc.)
    Object.keys(grouped).sort().forEach(divKey => {
        const divNum = parseInt(divKey);
        
        // Fetch Type Logic
        const showKey = activeShow.name; 
        const typeKey = `${showKey}-${divNum}`;
        const type = currentSave.divisionTypes?.[typeKey] || 'Standard';
        
        let label = "Midcard";
        if(divNum === 0) label = "MAIN EVENTERS";
        else if(divNum >= 5) label = "Jobbers/Enhancement";
        
        // Apply Silo Labels
        if(type === 'Women') label = `WOMEN'S DIVISION (${label})`;
        else if(type === 'Tag') label = `TAG TEAM DIVISION (${label})`;
        else if(type === 'WomenTag') label = "WOMEN'S TAG TEAM DIVISION";

        rosterContext += `[Division ${divNum + 1} - ${label}]: ${grouped[divKey].join(', ')}\n`;
    });

    if (availableObjects.length === 0) rosterContext = "WARNING: No roster assigned.";

// --- NEW: INJECT ACTIVE POWER RANKINGS ---
    let rankingContext = "";
    if (currentSave.powerRankings && currentSave.powerRankings[rankingFilter]) {
        // Use the ACTIVE ranking mode (Manual vs System)
        const rankList = currentSave.powerRankings[rankingFilter][rankingMode] || [];
        if (rankList.length > 0) {
            const top5 = rankList.slice(0, 5).map((e, i) => `${i+1}. ${typeof e === 'object' ? e.name : e}`).join(', ');
            rankingContext = `CURRENT POWER RANKINGS (${rankingMode.toUpperCase()}): ${top5}\n(Book these wrestlers strongly to maintain ranking credibility.)`;
        }
    }

// --- NEW: RIVALRY ENGINE CONTEXT (Smart Blow-Off Logic) ---
    let rivalryContext = "ACTIVE STORYLINES & FACTIONS (Priority Booking):\n";
    if (currentSave.rivalries && currentSave.rivalries.length > 0) {
        currentSave.rivalries.forEach(r => {
            // 1. Check if TODAY is the Blow-Off Show
            const isBlowoffShow = (activeShow.id === r.blowoff);
            
            // 2. Build Side Strings
            let activeSides = [];
            const labels = ["Side A", "Side B", "Side C", "Side D"];
            r.sides.forEach((members, i) => {
                if(members.length > 0) {
                    activeSides.push(`[${labels[i]}: ${members.join(', ')}]`);
                }
            });

            if (activeSides.length > 0) {
                rivalryContext += `\n*** RIVALRY: ${r.name} ***\n`;
                rivalryContext += `- FACTIONS: ${activeSides.join(' VS ')}\n`;
                
                if (isBlowoffShow) {
                    // CRITICAL INSTRUCTION FOR THE AI
                    rivalryContext += `🚨 URGENT BOOKING INSTRUCTION: TODAY IS THE BLOW-OFF SHOW.\n`;
                    rivalryContext += `YOU MUST BOOK THE FINALE MATCH: "${r.goal}".\n`;
                    rivalryContext += `This match must be decisive. Do not delay it.\n`;
                } else {
                    // Standard Build Instruction
                    rivalryContext += `- STATUS: Ongoing. Build tension towards the End Goal.\n`;
                    rivalryContext += `- END GOAL: ${r.goal || 'TBD'}\n`;
                    rivalryContext += `- RULES: Allies (Same Side) team up. Enemies (Diff Sides) fight.\n`;
                }
            }
        });
    } else {
        rivalryContext += "No active specific rivalries. Create fresh matchups.\n";
    }
 
    // --- NEW: LONG-TERM BOOKING CONTEXT (Past & Future) ---
    const showIndex = currentSave.shows.findIndex(s => s.id === activeShow.id);
    
    // Get Past 4 Weeks
    const pastShows = currentSave.shows
        .slice(0, showIndex)
        .reverse()
        .filter(s => 
            (s.name === activeShow.name) || 
            (s.type === 'special' && s.participatingShows && s.participatingShows.includes(activeShow.name))
        )
        .slice(0, 4);

    let historyContext = "RECENT HISTORY (Continuity is Key):\n";
    if (pastShows.length === 0) {
        historyContext += "No recent show history. Start fresh storylines.\n";
    } else {
        pastShows.forEach(s => {
            historyContext += `[${s.date} - ${s.name}]\n`;
            if (s.segments) {
                s.segments.forEach(seg => {
                    if (seg.type === 'match' && seg.actual_winner) {
                        historyContext += `- Match: ${seg.title} | Winner: ${seg.actual_winner} | Note: ${seg.notes || 'None'}\n`;
                    } else if (seg.type === 'promo') {
                        historyContext += `- Promo: ${seg.title} | Context: ${seg.desc || 'None'}\n`;
                    }
                });
            }
        });
    }

    // Get Next 4 Weeks
    const futureShows = currentSave.shows
        .slice(showIndex + 1)
        .filter(s => 
            (s.name === activeShow.name) || 
            (s.type === 'special' && s.participatingShows && s.participatingShows.includes(activeShow.name))
        )
        .slice(0, 4);

    let futureContext = "UPCOMING SCHEDULE (Build Towards These):\n";
    if (futureShows.length === 0) {
        futureContext += "No specific future events scheduled.\n";
    } else {
        futureShows.forEach(s => {
            futureContext += `- ${s.date}: ${s.name} (${s.type === 'special' ? 'MAJOR EVENT' : 'Weekly TV'})\n`;
        });
    }

    let commentaryContext = "";
    const comms = activeShow.commentators || (currentSave.seriesConfig?.[activeShow.name]?.commentators);
    if (comms) {
        if(comms.pbp?.name) commentaryContext += `Play-by-Play: ${comms.pbp.name} (${comms.pbp.style}). `;
        if(comms.color?.name) commentaryContext += `Color: ${comms.color.name} (${comms.color.style}). `;
        if(commentaryContext) commentaryContext = `BROADCAST TEAM: ${commentaryContext}`;
    }
    
    // 2. Prepare System & User Messages
    const eraData = ERA_CONFIG[currentSave.era] || ERA_CONFIG['current']; 
    
    // --- FIX 1: ADDED HISTORY AND FUTURE CONTEXT HERE ---
    const systemMsg = `${eraData.system}
    ROLE: You are the Head Booker (Creative) answering to a Demanding Promoter (Business).
    You are constantly torn between putting on a 5-Star Classic and satisfying the massive egos in the locker room.
    
    THE CONFLICT (INTERNAL LOGIC):
    1. THE ART (Booker Brain): You want logical storytelling, clean finishes, and to build new stars.
    2. THE BUSINESS (Promoter Brain): You crave TV Ratings. You will hot-shot a title change or bring back a Legend to pop a number, even if it hurts long-term.
    3. THE POLITICS (Reality): Top Stars have "Creative Control"—they rarely lose clean. If a mid-carder has "Heat" (bad attitude), you might squash them just to send a message.
    4. THE SQUASH: Sometimes, you just need to fill time. Destroying a "smaller guy" for no reason makes the monster look scary. Do it.
    
🔒 1. RESPECT THE BOOKING (ABSOLUTE RULE)
If booking_instruction specifies: A required winner → That wrestler MUST win.
A required push → They must be protected and elevated.
A required opponent → Use that opponent.
A required finish → Use that finish.
You are not allowed to override booking instructions.

🏆 2. CHAMPIONSHIP LOGIC
Champions should be featured consistently.
Title matches should not be random.
Championship matches must:
Be earned (rankings, rivalry, tournament, authority decision).
Be protected (champions rarely lose clean on TV unless storyline-driven).
Heels may retain via:
Cheating
DQ
Outside interference
Face champions usually win clean unless part of larger angle.
Do NOT hot-potato titles unless era supports it.
If near a PPV or Blowoff show → Save major title changes for that show unless otherwise instructed.

🧠 3. ERA AUTHENTICITY
Respect the era tone provided:
Attitude Era → Chaos, factions, authority angles, interference.
Ruthless Aggression → Workrate + faction dominance.
Modern → Cleaner presentation, fewer dusty finishes.
Territory Era → Strong champions, slower builds.
Match pacing, promo tone, and finish types must reflect the era.

🧩 4. RIVALRY & STORY ARC MANAGEMENT
If a rivalry exists:
Weekly TV builds tension.
Do NOT prematurely end a rivalry unless it is a blowoff show.
If today is the Blowoff date:
Book the decisive final match.
Clear finish required.
Story must conclude or escalate to new phase.
After a blowoff:
Either end rivalry.
Or pivot into next chapter.
You may suggest logical new rivalries based on:
Rankings
Betrayals
Title contention
Faction tensions
Nielsen Ratings

🧬 5. FACTIONS & ALLIANCES
Allies team together.
Enemies fight.
Factions protect their leaders.
Heels interfere for stablemates.
Internal faction tension may be teased if story requires.
Never ignore faction alignment.

🚑 6. INJURY & STATUS MANAGEMENT
Injured wrestlers cannot wrestle unless injury is storyline.
Light injuries may cause loss or angle.
Major injuries require:
Replacement
Angle explanation
Write-off segment
Protect injured talent from unrealistic booking.

🎭 7. FACE / HEEL DYNAMICS
Face vs Heel preferred for main events.
Heel vs Heel or Face vs Face must have story justification.
Crowd psychology matters:
Faces rally.
Heels cheat.
Use alignment to determine finish logic.

🎬 8. SEGMENT VARIETY (MANDATORY SHOW STRUCTURE)
Every show must contain a mix of:
Wrestling matches
Promos
Backstage interviews
Video packages / highlight reels
Authority segments (if era appropriate)
Surprise returns / debuts (occasionally)
Tag matches
Multi-man matches
Do NOT book 100% matches.
Typical weekly TV format:
5–7 segments total
3–4 matches
2–3 non-wrestling segments
PPVs:
Mostly matches
Minimal filler promos

⚖️ 9. HIERARCHY & RANKING MATTERS
If no winner is specified:
Main eventers beat midcarders.
Midcarders beat enhancement talent.
Champions rarely lose non-title matches clean.
Top 5 in rankings must be booked strongly.
Do not bury top stars without storyline reason.

🎲 10. MATCH VARIETY
If no finish mandated:
Do not use only clean pinfalls.
Use:
Roll-ups
Ref distractions
DQ
Count-out
Interference
Submission
Technical knockout
TV matches often:
Protect both wrestlers.
Advance story over decisive wins.

👥 11. MATCH FORMAT INTEGRITY
Respect match types:
Tag Team → 2v2 minimum.
Triple Threat → 3 participants.
Fatal 4-Way → 4 participants.
6-Man → 6 participants.
8-Man → 8 participants.
Battle Royal → 4+ participants minimum.
Royal Rumble → 30 or 60 participants.
Do not violate participant count rules.

📈 12. STAR RATINGS (REALISTIC SCALE)
Use realistic match quality:
1.0–2.0 = Squash or filler.
2.5–3.5 = Standard TV match.
3.5–4.5 = Strong match.
4.5–5.0 = Major PPV classic.
Do NOT give 4.5+ every week.
Star rating should reflect:
Story importance
Talent level
Match time
Cleanliness of finish

🏁 13. BUILD TOWARD PPV / MAJOR EVENT
If upcoming show is:
PPV
Special Event
Blowoff date
Then:
Avoid giving away major matches early.
Tease confrontation.
Use tag previews.
Use contract signings.
End weekly show with hook.

🎯 14. LONG-TERM BOOKING CONSISTENCY
Wins and losses matter.
Do not book random opponent repeats without reason.
Avoid same matchup weekly unless storyline driven.
Protect momentum arcs.


    CONTEXTUAL DATA:
    ${rosterContext}
    ${rankingContext}
    ${commentaryContext}
    ${rivalryContext}
    ${historyContext}
    ${futureContext}
    
    OUTPUT INSTRUCTIONS:
    - Return valid JSON only.
    - The JSON must be an object with a single key "segments" containing an array of segment objects.
    - IMPORTANT: You must include "creative_push", "spots", and "context_deep" for every match.
    - Other keys: type, title, match_type, participants (array).
    - IMPORTANT: In "creative_push" and "backstage", reveal which side of your brain won. Did you book it for the *Rating* or the *Art*?`;

    const userMsg = `Book a card based on this request: "${prompt}".
    
    Required JSON Structure for segments:
    {
      "segments": [
        {
           "type": "match" (or "promo", "video", "interview", "angle"),
           "title": "CATCHY ERA APPROPRIATE HEADLINE (e.g. 'Grudge Match Explodes')",
           "participants": ["Name1", "Name2"],
           "match_type": "One on One",
           "stipulation": "If any",
           "context_short": "TV GUIDE SUMMARY: A punchy 1-sentence hook to make viewers tune in.",
          "creative_push": "AGENT NOTES: Speak like an insider (e.g., 'Going over', 'Doing the honors', 'Rocket strap', 'Burial', 'Heat'). If the Promoter (User) requested a push, explain HOW we execute it. Who is 'eating the pin'? Also explain if we should bury a wrestler because of backstage politics.",
           "spots": "THE FINISH & PSYCHOLOGY: You MUST use their REAL FINISHERS (e.g. Stunner, Spear). Incorporate their STATUS tags: If 'Heel', do they cheat? If 'Injured', is the limb targeted? If 'Faction', do they interfere? If 'Legend', are they protected? Match style MUST fit the Era. Describe the precise ending.",
           "context_deep": "THE ANGLE: What is the emotional conflict? Is it jealousy, respect, or revenge? Reference specific past events (e.g., 'Retribution for the attack last week').",
           "backstage": "DIRT SHEET RUMORS: Real-life context. Is the loser in the doghouse? Is the winner selling merch? Did they refuse to do a job? (Keep it realistic). Any heat? Contract issues? Morale notes?",
           "history": "TALE OF THE TAPE: Win/Loss records or 'First Time Ever' note. Rivalries"
        }
      ]
    }`;

    try { 
        const res = await fetch("https://api.openai.com/v1/chat/completions", { 
            method: "POST", 
            headers: { "Content-Type": "application/json", "Authorization": `Bearer ${key}` }, 
            body: JSON.stringify({ 
                model: "gpt-5.2", // --- FIX 2: CHANGED TO VALID MODEL ---
                messages: [
                    { role: "system", content: systemMsg },
                    { role: "user", content: userMsg }
                ],
                response_format: { type: "json_object" } 
            }) 
        }); 
        
        const data = await res.json(); 
        if (data.error) throw new Error(data.error.message);

        const cleanContent = data.choices[0].message.content.replace(/```json|```/g, '');
        const json = JSON.parse(cleanContent); 
        const segments = json.segments || json; 

        if (Array.isArray(segments)) {
            segments.forEach(s => { 
                s.id = Date.now() + Math.random(); 
		s.desc = s.context_short || s.context_deep;                
		cardData.push(s); 
            }); 
            activeShow.segments = cardData; 
            saveGame(); 
            renderPlanner(); 
        } else {
            throw new Error("Invalid structure");
        }

    } catch(e) { 
        console.error(e); 
        alert("AI Error: " + e.message); 
    } finally { 
        document.getElementById('ai-loading').classList.add('hidden'); 
    } 
}
       function openEditSegmentModal(index) { 
    const seg = cardData[index]; 
    if (!seg) return; 

    document.getElementById('edit-seg-index').value = index; 
    document.getElementById('edit-type').value = seg.type; 
    
    // 1. Reset visual state 
    toggleEditSegmentOptions(); 
    
    // 2. Populate Title Dropdown
    const titleSelect = document.getElementById('edit-title-select');
    if (titleSelect) {
        titleSelect.innerHTML = '<option value="">- None -</option>';
        getAvailableTitles().forEach(t => {
            let sel = (seg.title_name === t) ? 'selected' : '';
            titleSelect.innerHTML += `<option value="${t}" ${sel}>${t}</option>`;
        });
    }

    // 3. Populate Participants
    const safeParticipants = seg.participants || []; 
    const container = document.getElementById('edit-competitor-container');
    container.innerHTML = ''; // Clear previous

    if(seg.type === 'match') { 
        document.getElementById('edit-match-type').value = seg.match_type; 
        updateEditCompetitorSelectors(safeParticipants); 
    } else { 
        document.getElementById('edit-promo-type').value = seg.match_type; 
        
        // DYNAMIC PROMO LOADING: Load all saved participants
        if (safeParticipants.length > 0) {
            safeParticipants.forEach(p => addCompetitorSlot('edit-competitor-container', p));
        } else {
            addCompetitorSlot('edit-competitor-container'); // At least one
        }
    } 
    
// --- 3. NEW: Populate Referee ---
    const refSelect = document.getElementById('edit-referee');
    if (refSelect) {
        const roster = getAvailableRosterObjects();
        let refOpts = '<option value="">- Standard Official -</option>';
        roster.forEach(w => {
            let sel = (w.name === seg.special_referee) ? 'selected' : '';
            refOpts += `<option value="${w.name}" ${sel}>${w.name}</option>`;
        });
        refSelect.innerHTML = refOpts;
    }

    // --- 4. NEW: Populate Managers ---
    const mgrContainer = document.getElementById('edit-manager-container');
    mgrContainer.innerHTML = ''; // Clear previous
    if (seg.managers && seg.managers.length > 0) {
        // Parse string: "Paul Heyman (w/ Roman Reigns), Maryse (w/ The Miz)"
        const list = seg.managers.split(', ');
        list.forEach(item => {
            // Regex to extract Name and Client
            const match = item.match(/(.+) \(w\/ (.+)\)/);
            if (match) {
                addEditManagerSlot(match[1], match[2]);
            }
        });
    }

    // 4. Fill text fields
    document.getElementById('edit-stipulation').value = seg.stipulation || ""; 
    document.getElementById('edit-headline').value = seg.title || ""; 
    document.getElementById('edit-winner').value = seg.booked_winner || ""; 
    document.getElementById('edit-finish').value = seg.booked_finish || ""; 
    document.getElementById('edit-creative-push').value = seg.creative_push || ""; 
    document.getElementById('edit-spots').value = seg.spots || ""; 
    document.getElementById('edit-notes').value = seg.context_deep || seg.desc || ""; 
    document.getElementById('edit-backstage').value = seg.backstage || ""; 
    
    document.getElementById('edit-segment-modal').classList.remove('hidden'); 
}
       function toggleEditSegmentOptions() { 
    const type = document.getElementById('edit-type').value; 
    const btn = document.getElementById('btn-edit-add-promo-person');

    if(type === 'match') { 
        document.getElementById('edit-match-type-container').classList.remove('hidden'); 
        document.getElementById('edit-promo-type-container').classList.add('hidden'); 
        document.getElementById('edit-competitor-container').classList.remove('hidden'); 
        document.getElementById('edit-booking-controls').classList.remove('hidden'); 
        
        btn.classList.add('hidden');
        updateEditCompetitorSelectors(); 
    } else { 
        document.getElementById('edit-match-type-container').classList.add('hidden'); 
        document.getElementById('edit-promo-type-container').classList.remove('hidden'); 
        document.getElementById('edit-competitor-container').classList.remove('hidden'); 
        document.getElementById('edit-booking-controls').classList.add('hidden'); 
        
        btn.classList.remove('hidden');
        // Note: renderEditCompetitorSelects is called by the modal opener, so we don't reset here to avoid clearing data
    } 
}
        function updateEditCompetitorSelectors(prefill = []) {
    const matchFormat = document.getElementById('edit-match-type').value;
    const container = document.getElementById('edit-competitor-container');
    const btn = document.getElementById('btn-edit-add-promo-person');

    let count = 2;
    let max = null;

    switch (matchFormat) {
        case 'Triple Threat': count = 3; break;
        case 'Fatal 4-Way': count = 4; break;
        case 'Tag Team': count = 4; break;
        case 'Five-Way': count = 5; break;
        case 'Six-Man': count = 6; break;
        case '8-Man': count = 8; break;
        case '10-Man': count = 10; break;

        case 'Battle Royal':
            count = Math.max(10, prefill.length || 10);
            max = 60;
            break;

        case 'Royal Rumble 30':
            count = Math.max(10, prefill.length || 10);
            max = 30;
            break;

        case 'Royal Rumble 60':
            count = Math.max(10, prefill.length || 10);
            max = 60;
            break;
    }

    if (count >= 10) {
        container.className = "mb-3 grid grid-cols-2 md:grid-cols-4 gap-2";
    } else {
        container.className = "mb-3 grid grid-cols-2 gap-2";
    }

    const isLargeField = (matchFormat === 'Battle Royal' || matchFormat.startsWith('Royal Rumble'));
    if (isLargeField) {
        btn.classList.remove('hidden');
        btn.innerHTML = '<i class="fa-solid fa-plus mr-2"></i> Add Entrant';
        btn.dataset.maxEntrants = String(max || 60);
        btn.dataset.targetContainer = 'edit-competitor-container';
    } else {
        btn.classList.add('hidden');
        btn.removeAttribute('data-max-entrants');
        btn.removeAttribute('data-target-container');
    }

    // render with prefills (if any)
    container.innerHTML = '';
    for (let i = 0; i < count; i++) {
        addCompetitorSlot('edit-competitor-container', prefill[i] || "");
    }
}

      
	function renderEditCompetitorSelects(count, prefill = []) {
    const container = document.getElementById('edit-competitor-container');
    container.innerHTML = '';

    for(let i=0; i<count; i++) {
        // We pass the prefill name (e.g. "John Cena") if it exists
        addCompetitorSlot('edit-competitor-container', prefill[i] || "");
    }
}
       // EDIT MODAL HEADLINE (old behavior + tag-team formatting)
function updateEditSegmentHeadline() {
  const inputs = document.querySelectorAll('#edit-competitor-container select');
  const names = Array.from(inputs).map(sel => sel.value).filter(v => v !== "");
  if (names.length === 0) return;

  // IMPORTANT: In edit modal, match type lives in edit-match-type (not seg.type)
  const matchTypeEl = document.getElementById('edit-match-type');
  const matchType = matchTypeEl ? matchTypeEl.value : "";

  let title = "";
  if (matchType === 'Tag Team' && names.length === 4) {
    title = `${names[0]} & ${names[1]} vs. ${names[2]} & ${names[3]}`;
  } else {
    title = names.join(' vs. ');
  }

  document.getElementById('edit-headline').value = title;
}

// KEEP YOUR ORIGINAL saveSegmentDetails() AS-IS (no changes)
function saveSegmentDetails() { 
  const idx = document.getElementById('edit-seg-index').value; 
  const seg = cardData[idx]; 
  
  const newType = document.getElementById('edit-type').value;
  const inputs = document.querySelectorAll('#edit-competitor-container select'); 
  let newParticipants = []; 
  inputs.forEach(sel => { if(sel.value) newParticipants.push(sel.value); }); 

  // SAFETY STOP (INJURY CHECK)
  if (newType === 'match') {
    const severeInjured = newParticipants.find(name => {
      const w = currentSave.roster.find(r => r.name === name);
      return w && w.injury === 'Severe';
    });
    if (severeInjured) {
      return alert(`🚫 MEDICAL SUSPENSION: ${severeInjured} has a SEVERE injury and cannot be booked in a match.`);
    }
  }

  seg.type = newType;
  seg.match_type = (seg.type === 'match') ? document.getElementById('edit-match-type').value : document.getElementById('edit-promo-type').value; 
  seg.stipulation = document.getElementById('edit-stipulation').value; 
  seg.title = document.getElementById('edit-headline').value; 
  
  const titleName = document.getElementById('edit-title-select').value;
  seg.is_title_match = !!titleName;
  seg.title_name = titleName;

  seg.participants = newParticipants; 

// --- NEW: SAVE REF & MANAGERS ---
    seg.special_referee = document.getElementById('edit-referee').value;
    
    // Scrape Manager List
    const mgrRows = document.querySelectorAll('#edit-manager-container > div');
    let managerList = [];
    mgrRows.forEach(row => {
        const mgr = row.querySelector('.edit-manager-select').value;
        const client = row.querySelector('.edit-client-select').value;
        if(mgr && client) {
            managerList.push(`${mgr} (w/ ${client})`);
        }
    });
    seg.managers = managerList.join(', ');

  
  if(seg.type === 'match') { 
    seg.booked_winner = document.getElementById('edit-winner').value; 
    seg.booked_finish = document.getElementById('edit-finish').value; 
  } else { 
    seg.booked_winner = ""; 
    seg.booked_finish = ""; 
  } 
  
  seg.creative_push = document.getElementById('edit-creative-push').value; 
  seg.spots = document.getElementById('edit-spots').value; 
  seg.context_deep = document.getElementById('edit-notes').value; 
  seg.backstage = document.getElementById('edit-backstage').value; 
  
  activeShow.segments = cardData; 
  saveGame(); 
  renderPlanner(); 
  document.getElementById('edit-segment-modal').classList.add('hidden'); 
}

        function getAvailableRosterObjects() { if(!activeShow) return []; let wrestlers = []; if (activeShow.type === 'special' && activeShow.participatingShows && activeShow.participatingShows.length > 0) { wrestlers = currentSave.roster.filter(w => activeShow.participatingShows.includes(w.shows)); } else { wrestlers = currentSave.roster.filter(w => w.shows === activeShow.name); } return wrestlers.sort((a, b) => a.name.localeCompare(b.name)); }
        function getAvailableRoster() { return getAvailableRosterObjects().map(w => w.name); }
        function toggleSegmentOptions() { 
    const type = document.getElementById('modal-type').value; 
    const btn = document.getElementById('btn-add-promo-person');
    const container = document.getElementById('competitor-container');

    if(type === 'match') { 
        document.getElementById('match-options').classList.remove('hidden'); 
        document.getElementById('promo-options').classList.add('hidden'); 
        document.getElementById('competitor-container').classList.remove('hidden'); 
        
        // Hide "Add" button for matches (matches follow strict rules)
        btn.classList.add('hidden');
        
        updateCompetitorSelectors(); 
    } else { 
        document.getElementById('match-options').classList.add('hidden'); 
        document.getElementById('promo-options').classList.remove('hidden'); 
        
        // Show "Add" button for Promos
        btn.classList.remove('hidden');
        
        // Reset to 1 empty slot for a fresh promo
        container.innerHTML = '';
        addCompetitorSlot('competitor-container');
    } 
}
       function updateCompetitorSelectors() {
    const matchFormat = document.getElementById('modal-match-type').value;
    const container = document.getElementById('competitor-container');
    const btn = document.getElementById('btn-add-promo-person');

    // 1) Default counts
    let count = 2;
    let max = null;

    switch (matchFormat) {
        case 'Triple Threat': count = 3; break;
        case 'Fatal 4-Way': count = 4; break;
        case 'Tag Team': count = 4; break;
        case 'Five-Way': count = 5; break;
        case 'Six-Man': count = 6; break;
        case '8-Man': count = 8; break;
        case '10-Man': count = 10; break;

        // Large-field matches:
        // Start at 10 to avoid spawning 30/60 selects immediately.
        case 'Battle Royal':
            count = 10;
            max = 60; // practical cap; can raise later
            break;

        case 'Royal Rumble 30':
            count = 10;
            max = 30;
            break;

        case 'Royal Rumble 60':
            count = 10;
            max = 60;
            break;
    }

    // 2) Grid density
    if (count >= 10) {
        container.className = "mb-3 grid grid-cols-2 md:grid-cols-4 gap-2";
    } else {
        container.className = "mb-3 grid grid-cols-2 gap-2";
    }

    // 3) Enable Add Entrant button for BR/Rumbles
    const isLargeField = (matchFormat === 'Battle Royal' || matchFormat.startsWith('Royal Rumble'));
    if (isLargeField) {
        btn.classList.remove('hidden');
        btn.innerHTML = '<i class="fa-solid fa-plus mr-2"></i> Add Entrant';
        btn.dataset.maxEntrants = String(max || 60);
        btn.dataset.targetContainer = 'competitor-container';
    } else {
        btn.classList.add('hidden');
        btn.removeAttribute('data-max-entrants');
        btn.removeAttribute('data-target-container');
    }

    renderCompetitorSelects(count);
}


// --- NEW HELPER: Generates the Roster Options String ---
function getRosterOptionsHTML(isMatch) {
    let roster = getAvailableRosterObjects();
    let options = `<option value="">- Select -</option>`;
    
    roster.forEach(w => {
        let label = w.name;
        if (w.status === 'champ') label = `👑 ${w.name}`;
        else if (w.status === 'mitb') label = `💼 ${w.name}`;
        
        let disabledAttr = "";
        
        if (w.injury === 'Light') label += ` (🩹)`;
        if (w.injury === 'Moderate') label += ` (🚑)`;
        
        if (w.injury === 'Severe') {
            label += ` (❌ Injured)`;
            if (isMatch) disabledAttr = "disabled style='color:#ef4444;'"; 
        }

        options += `<option value="${w.name}" ${disabledAttr}>${label}</option>`;
    });
    return options;
}

// --- Adds a Single Slot Dynamically ---
function addCompetitorSlot(containerId, prefillValue = "") {
    const container = document.getElementById(containerId);
    if (!container) return;

    // --- Max entrant guard for BR/Rumbles ---
    const isEdit = containerId.includes('edit');
    const btnId = isEdit ? 'btn-edit-add-promo-person' : 'btn-add-promo-person';
    const btn = document.getElementById(btnId);

    if (btn && btn.dataset && btn.dataset.maxEntrants) {
        const max = parseInt(btn.dataset.maxEntrants, 10);
        if (!Number.isNaN(max) && container.children.length >= max) {
            alert(`Max entrants reached (${max}).`);
            return;
        }
    }

    // Check context (Match vs Promo) to determine if we block injured people
    const typeSelect = isEdit ? document.getElementById('edit-type') : document.getElementById('modal-type');
    const isMatch = typeSelect ? (typeSelect.value === 'match') : true;

    const options = getRosterOptionsHTML(isMatch);
    const count = container.children.length + 1;

    const div = document.createElement('div');
    const changeFunc = isEdit ? 'updateEditSegmentHeadline()' : 'updateSegmentHeadline()';

    div.innerHTML = `
        <label class="block text-xs font-bold text-slate-500 uppercase mb-1">Participant ${count}</label>
        <select onchange="${changeFunc}" class="w-full bg-slate-800 border-slate-600 text-white p-2 rounded text-sm mb-2">
            ${options}
        </select>
    `;

    container.appendChild(div);

    // Set value if provided
    if (prefillValue) {
        div.querySelector('select').value = prefillValue;
    }
}
       
	function renderCompetitorSelects(count) {
    const container = document.getElementById('competitor-container');
    container.innerHTML = '';
    
    // We just loop X times and ask the new helper to add a slot each time.
    // The helper (addCompetitorSlot) already handles the "Injury/Champion" logic.
    for(let i=0; i<count; i++) {
        addCompetitorSlot('competitor-container');
    }
}
      function updateSegmentHeadline() {
  const inputs = document.querySelectorAll('#competitor-container select');
  const names = Array.from(inputs).map(sel => sel.value).filter(v => v !== "");
  if (names.length === 0) return;

  const typeEl = document.getElementById('modal-match-type');
  const type = typeEl ? typeEl.value : "";

  let title = "";
  if (type === 'Tag Team' && names.length === 4) {
    title = `${names[0]} & ${names[1]} vs. ${names[2]} & ${names[3]}`;
  } else {
    title = names.join(' vs. ');
  }
  document.getElementById('modal-title').value = title;
}

function openSegmentModal() {
  // 1. Reset text fields (same as old)
  document.getElementById('modal-title').value = "";
  document.getElementById('modal-stipulation').value = "";

const mgrContainer = document.getElementById('manager-container');
    if(mgrContainer) mgrContainer.innerHTML = '';

  // 2. Setup the Title Dropdown (same as old)
  const titleSelect = document.getElementById('modal-title-select');
  if (titleSelect) {
    titleSelect.innerHTML = '<option value="">- None -</option>';
    const titles = getAvailableTitles();
    titles.forEach(t => titleSelect.innerHTML += `<option value="${t}">${t}</option>`);
  }

// --- NEW: POPULATE REFEREE & MANAGER DROPDOWNS ---
    const roster = getAvailableRosterObjects(); // Fetch roster for active show
    let rosterOptions = '';
    
    roster.forEach(w => {
        let label = w.name;
        // Add helpful context badges
        if (w.status === 'champ') label += ' 👑';
        if (w.injury === 'Severe') label += ' (Injured)'; 
        
        rosterOptions += `<option value="${w.name}">${label}</option>`;
    });

    // Populate Referee
    const refSelect = document.getElementById('modal-referee');
    if (refSelect) {
        refSelect.innerHTML = '<option value="">- Standard Official -</option>' + rosterOptions;
    }

    // Populate Managers
    const mgrSelect = document.getElementById('modal-managers');
    if (mgrSelect) {
        mgrSelect.innerHTML = '<option value="">- None -</option>' + rosterOptions;
    }

  // 3. Show the modal (same as old)
  toggleSegmentOptions();
  document.getElementById('segment-modal').classList.remove('hidden');
}
   
function addManualSegment() { 
    const type = document.getElementById('modal-type').value; 
    const title = document.getElementById('modal-title').value; 
    if(!title) return alert("Headline required"); 
    
    // Gather Participants
    const inputs = document.querySelectorAll('#competitor-container select'); 
    let participants = []; 
    inputs.forEach(sel => { if(sel.value) participants.push(sel.value); }); 

    // --- NEW: SAFETY STOP (INJURY CHECK) ---
    if (type === 'match') {
        const severeInjured = participants.find(name => {
            const w = currentSave.roster.find(r => r.name === name);
            return w && w.injury === 'Severe';
        });
        
        if (severeInjured) {
            return alert(`🚫 MEDICAL SUSPENSION: ${severeInjured} has a SEVERE injury and cannot be booked in a match.`);
        }
    }
    // ---------------------------------------

    let matchType = (type === 'match') ? document.getElementById('modal-match-type').value : document.getElementById('modal-promo-type').value; 
    let stipulation = document.getElementById('modal-stipulation') ? document.getElementById('modal-stipulation').value : ""; 
    const titleName = document.getElementById('modal-title-select').value;
    const isTitle = !!titleName;
    const referee = document.getElementById('modal-referee') ? document.getElementById('modal-referee').value : "";
   
 const mgrRows = document.querySelectorAll('#manager-container > div');
    let managerList = [];
    mgrRows.forEach(row => {
        const mgr = row.querySelector('.manager-select').value;
        const client = row.querySelector('.client-select').value;
        if(mgr && client) {
            managerList.push(`${mgr} (w/ ${client})`);
        }
    });
    const managers = managerList.join(', ');

    cardData.push({ 
        id: Date.now(), 
        type, 
        title, 
        match_type: matchType, 
        stipulation, 
        participants, 
        is_title_match: isTitle,
        title_name: titleName,
	special_referee: referee,
       managers: managers, // Saves as "Name (w/ Client), Name2 (w/ Client2)"
        context_short: "Manual Entry", 
        desc: "Manual Entry" 
    }); 
    
    activeShow.segments = cardData; 
    saveGame(); 
    renderPlanner(); 
    document.getElementById('segment-modal').classList.add('hidden'); 
}

// --- MISSING FUNCTION FIX ---
function removeSegment(index) {
    if(!confirm("Are you sure you want to delete this segment?")) return;
    
    // Remove the item from the array
    cardData.splice(index, 1);
    
    // Update the main show object
    activeShow.segments = cardData;
    
    // Save and Refresh
    saveGame();
    renderPlanner();
}
        // --- UPDATED DELETE LOGIC ---
function askDeleteShow(id) { 
    deleteTargetId = id; 
    const show = currentSave.shows.find(s => s.id === id); 
    
    // Always show modal for weekly shows to offer granularity
    if(show.type === 'weekly') {
        document.getElementById('delete-modal').classList.remove('hidden'); 
    } else {
        // For one-off special events, check if there are others with same name
        const count = currentSave.shows.filter(s => s.name === show.name).length;
        if (count > 1) {
             document.getElementById('delete-modal').classList.remove('hidden'); 
        } else {
             // If it's truly unique, just delete it
             confirmDelete('single'); 
        }
    }
}

function confirmDelete(mode) { 
    const target = currentSave.shows.find(s => s.id === deleteTargetId); 
    if(!target) return;

    if (mode === 'single') {
        // Just remove the specific ID
        currentSave.shows = currentSave.shows.filter(s => s.id !== deleteTargetId);
    } 
    else if (mode === 'all') {
        // Remove everything with matching name
        currentSave.shows = currentSave.shows.filter(s => s.name !== target.name);
    }
    else if (mode === 'future') {
        // Remove same name, where date is >= target date
        const targetDate = new Date(target.date); // Midnight/UTC nuances don't matter as much for simple comparison
        currentSave.shows = currentSave.shows.filter(s => {
            // Keep if name doesn't match
            if (s.name !== target.name) return true;
            
            // If name matches, keep ONLY if it's strictly BEFORE this one
            // We compare strings (YYYY-MM-DD) for safety
            return s.date < target.date;
        });
    }

    saveGame(); 
    renderCalendar(); 
    document.getElementById('delete-modal').classList.add('hidden'); 
    document.getElementById('day-detail-modal').classList.add('hidden'); 
}
        function editShow(id) { logoRemoved = false; const show = currentSave.shows.find(s => s.id === id); if(!show) return; document.getElementById('show-modal-title').innerText = "Edit Show Details"; document.getElementById('edit-show-id').value = show.id; document.getElementById('show-date').value = show.date; document.getElementById('show-name').value = show.name; document.getElementById('show-arena').value = show.arena || ""; document.getElementById('show-recurrence').value = show.type; document.getElementById('show-color-picker').value = show.color || '#334155'; document.getElementById('show-logo-upload').value = ""; let comms = show.commentators; if (!comms) { if (show.type === 'weekly' && currentSave.seriesConfig[show.name] && currentSave.seriesConfig[show.name].commentators) { comms = currentSave.seriesConfig[show.name].commentators; } } if(comms) { document.getElementById('comm-pbp-name').value = comms.pbp?.name || ""; document.getElementById('comm-pbp-style').value = comms.pbp?.style || ""; document.getElementById('comm-color-name').value = comms.color?.name || ""; document.getElementById('comm-color-style').value = comms.color?.style || ""; document.getElementById('comm-int-name').value = comms.interviewer?.name || ""; document.getElementById('comm-int-style').value = comms.interviewer?.style || ""; } else { ['pbp-name','pbp-style','color-name','color-style','int-name','int-style'].forEach(id => document.getElementById('comm-'+id).value = ""); } toggleRecurrenceFields(show.type, show.participatingShows || []); document.getElementById('show-modal').classList.remove('hidden'); document.getElementById('day-detail-modal').classList.add('hidden'); }
        function viewReport(reportId) { viewingArchiveId = reportId; switchMainView('dirtsheet'); openArchive(reportId); }
        function renderArchiveList() { const list = document.getElementById('archive-list'); list.innerHTML = ''; [...currentSave.history].reverse().forEach(item => { list.innerHTML += `<div class="relative group cursor-pointer border-l-4 border-red-500 mb-2 bg-slate-700 hover:bg-slate-600 rounded p-3" onclick="openArchive('${item.id}')"><div class="font-bold text-white text-sm">${item.showName}</div><div class="text-xs text-slate-400">${item.date}</div><button onclick="deleteArchive('${item.id}', event)" class="absolute top-2 right-2 text-red-400 hover:text-red-200 hidden group-hover:block"><i class="fa-solid fa-trash"></i></button></div>`; }); }
       function openArchive(id) {
    const item = currentSave.history.find(i => i.id === id);
    if(item) {
        const viewer = document.getElementById('archive-viewer');
        
        // CHECK: Is this a "New Style" report with the era background?
        if (item.html.includes('magazine-bg-layer')) {
            // NEW REPORT: Full width, transparent container (Let the internal wrapper handle style)
            viewer.className = "h-full w-full overflow-y-auto"; 
        } else {
            // OLD REPORT: Enforce the "White Paper" look manually
            // We add 'text-slate-900' to force black text, and 'bg-white' for the paper
            viewer.className = "max-w-4xl mx-auto bg-white shadow-2xl min-h-screen rounded p-10 text-slate-900";
        }
        
        viewer.innerHTML = item.html;
    }
}
        function openShowModal(prefillDate) { logoRemoved = false; document.getElementById('show-modal-title').innerText = "Schedule Show"; document.getElementById('edit-show-id').value = ""; document.getElementById('show-date').value = prefillDate || new Date().toISOString().split('T')[0]; document.getElementById('show-name').value = ""; document.getElementById('show-arena').value = ""; document.getElementById('show-recurrence').value = "weekly"; document.getElementById('show-logo-upload').value = ""; ['pbp-name','pbp-style','color-name','color-style','int-name','int-style'].forEach(id => document.getElementById('comm-'+id).value = ""); toggleRecurrenceFields("weekly", []); document.getElementById('show-modal').classList.remove('hidden'); }
        function clearShowLogo() { document.getElementById('show-logo-upload').value = ""; logoRemoved = true; alert("Logo removed (Click Save to apply)"); }
        function clearBeltImage(divisionIndex) { if(confirm("Remove belt image?")) { const showKey = (rosterFilter === 'all' || rosterFilter === 'free') ? 'Global' : rosterFilter; const key = `${showKey}-${divisionIndex}`; delete currentSave.beltImages[key]; saveGame(); renderRoster(); } }


function calculateStarsFromText(text) {
    if (!text) return "2.5"; // Safety Net
    
    // 1. Clean and Tokenize (Break sentence into a list of words)
    const lower = text.toLowerCase().replace(/[.,/#!$%^&*;:{}=\-_`~()]/g,"");
    const words = lower.split(/\s+/); 

    let score = 2.5; // Start at the "Average" baseline
    let hits = 0;    // Track if we found any keywords

    // 2. Define the Dictionary (Word Values)
    const ratings = {
        // --- 5 STAR WORDS (+2.5) ---
        "masterpiece": 2.5, "classic": 2.5, "perfection": 2.5, "unforgettable": 2.5, "legendary": 2.5,
        
        // --- 4 STAR WORDS (+1.5) ---
        "amazing": 1.5, "incredible": 1.5, "fantastic": 1.5, "spectacular": 1.5, "electric": 1.5, "awesome": 1.5, "excellent": 1.5, "thrilling": 1.5,
        
        // --- 3 STAR WORDS (+0.5) ---
        "good": 0.5, "solid": 0.5, "strong": 0.5, "great": 0.8, "heated": 0.5, "competitive": 0.5, "decent": 0.2, "entertaining": 0.5,
        
        // --- 2 STAR WORDS (-0.5) ---
        "average": -0.3, "okay": -0.5, "standard": -0.5, "mediocre": -0.8, "nothing": -0.5, // "nothing special"
        
        // --- 1 STAR WORDS (-1.5) ---
        "sloppy": -1.5, "boring": -1.5, "bad": -1.5, "rough": -1.5, "confusing": -1.5, "dragged": -1.0, "awkward": -1.0,
        
        // --- DUD WORDS (-2.5) ---
        "terrible": -2.5, "disaster": -2.5, "awful": -2.5, "horrible": -2.5, "botch": -2.0, "mess": -2.0,
        
        // --- SQUASH HANDLING (Context Dependent) ---
        "squash": 0.5, "destroyed": 1.5, "quick": 0.0, "dominated": 1.5, "powerhouse": 1.0, "shocking": 1.0
    };

    const negations = ["not", "wasnt", "never", "no", "hardly", "didnt"];

    // 3. Scan the Text
    for (let i = 0; i < words.length; i++) {
        const word = words[i];
        
        if (ratings[word] !== undefined) {
            hits++;
            let val = ratings[word];

            // 4. THE CONTEXT CHECK (Look back 1 or 2 words for "not")
            // Example: "not a classic" or "was not good"
            const prev1 = words[i-1];
            const prev2 = words[i-2];

            if (negations.includes(prev1) || negations.includes(prev2)) {
                // FLIP IT: "Not good" (0.5) becomes (-0.5)
                // We dampen it slightly so "not classic" isn't instantly 0 stars, just a penalty.
                val = -val * 0.8; 
            }

            score += val;
        }
    }

    // 5. Handle "Squash" Logic Exception
    // If the text is extremely short and contains "squash", cap the stars low.
    if (lower.includes("squash") && words.length < 15) {
        score = Math.min(score, 1.5);
    }

    // 6. Clamp & Round
    // Ensure we don't go below 0 or above 5
    score = Math.max(0, Math.min(5, score));
    
    // Round to nearest 0.5 (e.g. 3.2 becomes 3.0, 3.3 becomes 3.5)
    return (Math.round(score * 2) / 2).toFixed(1);
}

// --- NEW FEATURES: Simulate & Quick Finish ---

    // OLD BASE + UPDATE (adds booked_finish support) — nothing removed
// MERGED VERSION (OLD BASE PRESERVED) + Tag-Team context improvements
// Nothing removed: finish_type stays, mandatory keywords stay, fallback stays, segments+matches counts stay.
// Additions: match_style + participants_structure to prevent tag matches being treated as 4-way.

// ================================
// SIMULATION: CHRONOLOGY + BATCH
// ================================

function _dateKeyToDate(d) {
  // expects "YYYY-MM-DD"
  const [y, m, day] = String(d || "").split("-").map(n => parseInt(n, 10));
  if (!y || !m || !day) return null;
  return new Date(y, m - 1, day, 12, 0, 0); // noon = avoids TZ edge
}

function getUnplayedShowsBefore(dateStr) {
  if (!currentSave || !Array.isArray(currentSave.shows)) return [];
  const target = _dateKeyToDate(dateStr);
  if (!target) return [];

  return currentSave.shows
    .filter(s => s && s.date && s.status !== "completed")
    .filter(s => {
      const sd = _dateKeyToDate(s.date);
      return sd && sd < target;
    })
    .sort((a, b) => _dateKeyToDate(a.date) - _dateKeyToDate(b.date));
}

function markShowCompletedUnbooked(showObj) {
  // Minimal completion for unbooked/empty shows
  const idx = currentSave.shows.findIndex(s => String(s.id) === String(showObj.id));
  if (idx === -1) return;

  const nowStamp = new Date().toLocaleString();
  currentSave.shows[idx].status = "completed";
  currentSave.shows[idx].completedAt = currentSave.shows[idx].completedAt || nowStamp;

  // Keep consistent fields so UI doesn’t choke later
  currentSave.shows[idx].segments = Array.isArray(currentSave.shows[idx].segments) ? currentSave.shows[idx].segments : [];
  currentSave.shows[idx].rating = currentSave.shows[idx].rating || "0.00";
  currentSave.shows[idx].reportId = currentSave.shows[idx].reportId || null;

  saveGame();
}

// Simulate every show leading up to targetDateStr (Headless / Batch Mode)
async function simulateAllShowsThroughDate(targetDateStr) {
  if (!currentSave || !Array.isArray(currentSave.shows)) {
    return alert("No universe loaded.");
  }

  const target = _dateKeyToDate(targetDateStr);
  if (!target) return alert("Invalid target date.");

  // Choose ONE:
  const includeTargetDay = false; // set true if you want to simulate shows ON the selected date too

  const queue = currentSave.shows
    .filter(s => s && s.date)
    .filter(s => {
      const d = _dateKeyToDate(s.date);
      if (!d) return false;
      return includeTargetDay ? (d <= target) : (d < target);
    })
    .filter(s => s.status !== "completed")
    .sort((a, b) => _dateKeyToDate(a.date) - _dateKeyToDate(b.date));

  if (queue.length === 0) {
    return alert("No unplayed shows on or before this date.");
  }

  const preview = queue.slice(0, 6).map(s => `${s.date} — ${s.name}`).join("\n");
  const ok = confirm(
    `Simulate ${queue.length} show(s) up to ${targetDateStr}?\n\n` +
    `${preview}${queue.length > 6 ? `\n… (+${queue.length - 6} more)` : ""}\n\n` +
    `Booked matches use booked winners. Unbooked matches use the fast algorithm. Empty shows will be auto-completed.`
  );
  if (!ok) return;

  const originalTitle = document.title;

  // Preserve caller state
  const prevActiveShow = activeShow;
  const prevCardData = cardData;

  showLoadingOverlay("Running simulation algorithm...");

  try {
    for (let i = 0; i < queue.length; i++) {
      const s = queue[i];
      const progress = Math.round(((i + 1) / queue.length) * 100);

      // UI updates
      updateLoadingProgress(progress, `Simulating: ${s.name} (${s.date})`);
      document.title = `Simulating ${i + 1}/${queue.length}...`;
      await new Promise(r => requestAnimationFrame(r));

      const segs = Array.isArray(s.segments) ? s.segments : [];

      // A) Empty shows
      if (segs.length === 0) {
        if (typeof markShowCompletedUnbooked === "function") {
          markShowCompletedUnbooked(s);
        } else {
          // fallback minimal completion
          s.status = "completed";
          s.completedAt = new Date().toLocaleString();
        }

        // periodic save
        if (i % 5 === 0) saveGame();
        continue;
      }

      // B) Make globals consistent for downstream helpers
      activeShow = s;
      cardData = segs;

      // C) Simulate segments
      segs.forEach(seg => {
        if (seg.type === "match" && !seg.actual_winner) {
          // 1) booked winner wins
          if (seg.booked_winner) {
            seg.actual_winner = seg.booked_winner;
            seg.finish_type = seg.booked_finish || "Pinfall";
            seg.stars = seg.stars || "3.0";
            seg.notes = seg.notes || `Booked victory for ${seg.booked_winner}.`;
          } else {
            // 2) algorithm
            const res = (typeof simulateMatchAlgorithm === "function")
              ? simulateMatchAlgorithm(seg)
              : null;

            // guard: algorithm must produce a winner
            const parts = Array.isArray(seg.participants) ? seg.participants : [];
            let winner = res && res.winner ? res.winner : "";
            if (!winner && parts.length) {
              winner = parts[Math.floor(Math.random() * parts.length)];
            }
            if (!winner) winner = "Draw";

            seg.actual_winner = winner;
            seg.stars = (res && res.stars) ? String(res.stars) : (seg.stars || "2.5");
            seg.notes = (res && res.summary) ? res.summary : (seg.notes || "Simulated result.");
            seg.finish_type = seg.finish_type || "Pinfall";
          }

          // Update standings
          const losers = (seg.participants || []).filter(p => p !== seg.actual_winner);
          if (typeof updateDivisionStandings === "function") {
            updateDivisionStandings(seg.actual_winner, losers, seg);
          }
        } else if (seg.type !== "match") {
          // promo/segment autofill
          if (!seg.notes) seg.notes = "Segment occurred as planned.";
          if (!seg.stars) seg.stars = "2.5";
        }
      });

      // D) Ratings / archive
      const finalRating = (typeof calculateShowRatings === "function")
        ? calculateShowRatings()
        : (s.rating || "0.0");

      const reportId = Date.now().toString() + Math.random().toString();

      // Keep NEW lightweight archive, but include notes if you want
      const html = `
        <div class="p-8 text-center">
          <h1 class="text-2xl font-bold mb-2">SIMULATED RESULT</h1>
          <div class="text-slate-500 mb-6">${s.date} • ${s.name} • Rating: ${finalRating}</div>
          <div class="text-left max-w-xl mx-auto space-y-3">
            ${segs.map(seg => `
              <div class="border-b border-slate-700 pb-2">
                <div class="font-bold text-sm">${seg.title}</div>
                ${seg.type === 'match'
                  ? `<div class="text-green-400 text-xs">Winner: ${seg.actual_winner} (${seg.stars}★)</div>`
                  : `<div class="text-slate-400 text-xs">Segment</div>`
                }
                ${seg.notes ? `<div class="text-slate-500 text-xs italic mt-1">"${seg.notes}"</div>` : ``}
              </div>
            `).join('')}
          </div>
        </div>`;

      currentSave.history = currentSave.history || [];
      currentSave.history.push({
        id: reportId,
        showName: s.name,
        date: s.date,
        html,
        timestamp: new Date().toLocaleString()
      });

      // E) Finalize show (preserve segments!)
      s.status = "completed";
      s.reportId = reportId;
      s.completedAt = new Date().toLocaleString();
      s.segments = segs;

      if (typeof checkRivalryCompletions === "function") {
        checkRivalryCompletions();
      }

      // Save every 5 shows (safer than end-only)
      if (i % 5 === 0) saveGame();
    }

    saveGame();
    hideLoadingOverlay();
    alert(`✅ Simulation Complete!\n\n${queue.length} shows processed successfully.`);
    renderCalendar();

  } catch (e) {
    console.error(e);
    hideLoadingOverlay();
    alert("Simulation Error: " + e.message);
  } finally {
    document.title = originalTitle;
    activeShow = prevActiveShow;
    cardData = prevCardData;
  }
}

async function simulateShow() {
  const key = localStorage.getItem('openai_key');
  if (!key) return alert("API Key required");

  // 1) Identify what needs simulation
  const pending = cardData.filter(s =>
    !s.stars ||
    (s.type === 'match' && !s.actual_winner) ||
    (s.type !== 'match' && !s.notes)
  );

  if (pending.length === 0) return alert("No pending segments to simulate!");

  const btn = document.querySelector('button[onclick="simulateShow()"]');
  const originalText = btn.innerHTML;
  btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Booking...`;
  btn.disabled = true;

  // 2) Prepare simplified data for AI (token-efficient, but booking-aware)
  const tempMap = {};
  const simulationContext = pending.map((p, index) => {
    const simpleId = index + 1;
    tempMap[simpleId] = p.id;

    // --- Robust instruction builder + booked_finish support (kept) ---
    let bookingInstruction = p.actual_winner
      ? `RESULT LOCKED: Winner is ${p.actual_winner}. Generate summary & stars only.`
      : (p.creative_push || p.booked_winner
        ? `MUST WIN/PUSH: ${p.booked_winner || p.creative_push}`
        : "No specific winner planned.");

    // Preserve booked finish enforcement
    if (p.booked_finish) {
      bookingInstruction += ` | MANDATORY FINISH TYPE: ${p.booked_finish}`;
    }

    // --- Tag-Team context improvements (added, does not remove anything) ---
    const matchStyle = p.match_type || (p.type === 'match' ? 'Standard' : 'Segment');

    let participantsStructure = "";
    if (Array.isArray(p.participants) && p.participants.length) {
      if (matchStyle === 'Tag Team' && p.participants.length === 4) {
        participantsStructure =
          `TEAM 1: ${p.participants[0]} & ${p.participants[1]} VS TEAM 2: ${p.participants[2]} & ${p.participants[3]}`;
      } else {
        participantsStructure = p.participants.join(' vs. ');
      }
    }
    // ---------------------------------------------------------------

    return {
      temp_id: simpleId,
      type: p.type,                 // 'match' or 'promo' (or other segment types you use)
      match_style: matchStyle,      // ADDED
      title: p.title,
      participants: p.participants, // KEPT (for backward compatibility)
      participants_structure: participantsStructure, // ADDED
      stipulation: p.stipulation,
      booking_instruction: bookingInstruction,
      story_notes: p.notes
        ? `EVENT LOGGED: ${p.notes}. Generate stars based on this.`
        : (p.context_deep || "Generic segment")
    };
  });

  // 3) Prompt (OLD rules preserved) + Tag-Team rule added
  const prompt = `You are the official match + segment simulation engine for a professional wrestling booking universe.
Task: Simulate realistic results for the following show segments.

INPUT DATA: ${JSON.stringify(simulationContext)}

You will receive roster entries formatted with tags, e.g.:
"Roman Reigns [Heel, Team: The Bloodline, Champion, Legend, MITB Holder, Knee Injury]"

You MUST interpret these tags and apply them to outcomes, finishes, and star ratings.

========================
CORE BOOKING AUTHORITY
========================

1) BOOKING IS LAW
- If "booking_instruction" specifies a winner, push, or direction — that outcome MUST happen.
- If "booking_instruction" includes "MANDATORY FINISH TYPE:", you MUST:
  - Use that exact finish type in "finish_type"
  - Describe it clearly in the summary

You may enhance the drama, but you may NOT override booking.

========================
ROSTER TAGS (CRITICAL INPUTS)
========================

You MUST recognize and use these tags when simulating:

A) Alignment Tags
- Face: tends toward clean wins, comebacks, fighting spirit, crowd sympathy
- Heel: tends toward shortcuts, taunts, cowardly tactics, interference, opportunistic finishes

B) Team / Faction Tags
- "Team: X" means allies may influence outcomes:
  - Interference is more likely when teammates are present or active in story context
  - Saves are more likely for Faces with allies
  - Betrayals are possible if story logic suggests tension (rare unless instructed)

C) Champion Tag
Champions are protected and treated as major assets to the brand.

GENERAL PROTECTION:
- Champions rarely lose clean on weekly TV unless booking explicitly mandates it.
- If a Champion must lose and booking is NOT explicit, prefer protected losses:
  - Roll-up
  - Distraction
  - Interference
  - Count-out
  - DQ (non-title situations)

HEEL CHAMPION RETENTION LOGIC:
- Heel Champions are more likely to retain using:
  - Cheating
  - Ref distraction
  - Outside interference (especially if Team tag present)
  - Weapon usage in No-DQ environments
  - Intentional DQ to retain (if title is not on the line in No-DQ format)
- Heel Champions should rarely win with pure dominance unless they are positioned as unstoppable monsters.
- A Heel Champion retaining via questionable means increases story heat but may slightly reduce star rating.

FACE CHAMPION RETENTION LOGIC:
- Face Champions typically retain via:
  - Clean pinfall
  - Submission
  - Comeback victory
  - Overcoming interference
- Face Champions should not intentionally DQ themselves to retain.
- If a Face Champion retains via DQ, it should be due to the challenger losing control (not the champion cheating).

TITLE MATCH RULES:
- Title matches have higher intensity and slightly higher star rating ceilings.
- Champions losing clean in a title match should feel significant and rare.
- If a Champion retains via DQ in a title match, clearly explain that the title does NOT change hands.

STORY HEAT MODIFIER:
- Heel Champion cheating retention = +story heat
- Face Champion clean retention = +credibility
- Repeated identical finishes (e.g., same cheat twice in a row) reduce match freshness and star ceiling

D) Legend Tag
- Legends receive “legacy protection”:
  - They can lose, but should usually be protected unless booking mandates a clean loss
  - Legends often influence pacing (big-match aura) and crowd reaction

E) MITB Holder Tag
- MITB holder creates volatility:
  - They should be treated as a credible threat even if not top-ranked
  - Surprise cash-in teases or “briefcase presence” can increase segment drama
  - Cash-in only happens if booking_instruction implies it (do NOT force cash-ins)

F) Injury Tag (e.g., "Knee Injury", "Shoulder Injury", "Cleared for limited physicality")
- Injured wrestlers:
  - Reduced workrate ceiling and endurance
  - More selling and targeted offense by opponents
  - Higher chance of non-clean finish (ref stoppage, doctor check, quick win)
  - If injury is severe, avoid 4.5–5 star outputs unless booking_instruction demands a masterpiece
- If tag indicates limited clearance, keep it safe: shorter match, fewer risky spots

========================
MATCH STRUCTURE LOGIC
========================

2) MATCH TYPE CLARITY
- "Tag Team" = 2 vs 2 (NOT a 4-way)
- Use "participants_structure" to identify teams
- Only legal participants may be pinned/submitted

3) HIERARCHY (If winner not mandated)
Default hierarchy:
Champion > Main Eventer > Upper Midcard > Midcard > Lower Card > Jobber
Plus modifiers from tags:
- Heel tactics can steal wins more often than Faces
- MITB holders have a higher upset potential than normal
- Injuries reduce upset probability for the injured wrestler

If no winner specified:
- Higher hierarchy wins 80–90% of the time
- Upsets only if justified by momentum/story OR rare shock (max 1 in 10)

========================
FINISH VARIETY + TAG-BASED FINISHING
========================

4) FINISH VARIETY (avoid repetitive clean pins)
If no mandated finish, rotate between:
- Clean Pin
- Submission
- Roll-up / Flash Pin
- Distraction
- DQ
- Count-out
- Ref stoppage (especially for injuries)
- Interference (especially for Heels/Teams)
- Squash (Star vs Jobber)
- No contest (rare, only if story calls for chaos)

Never use the same finish type more than twice in a row on a single show.

5) PROTECTION LOGIC (Champions + Legends)
If a Champion or Legend must lose (and booking is not explicit):
Prefer protected losses:
- Roll-up / Distraction
- DQ
- Interference
- Count-out
Avoid clean losses unless:
- Booking mandates it
- Story logic strongly demands a credibility shift

========================
PROMOS / NON-MATCH SEGMENTS
========================

6) PROMOS
- winner must be null
- Must advance story (stakes, motive, challenge, betrayal, reveal)
- Alignment influences tone:
  - Face: rallying, emotional, honorable
  - Heel: manipulative, arrogant, dismissive
- Team tags can imply backup presence, intimidation, or recruitment

========================
STAR RATING ENGINE (WITH TAG IMPACT)
========================

7) STAR RATINGS
PROMOS:
1–5 stars based on:
- heat, clarity, stakes, character authenticity, crowd reaction

MATCHES:
0–1 stars: squash or injury-shortened
1–2 stars: sloppy/boring/rough
2.5–3.5 stars: TV standard
3.5–4 stars: very strong
4–4.5 stars: fantastic
4.5–5 stars: rare classic/masterpiece

Tag impacts:
- Injury tags reduce ceiling unless story requires otherwise
- Champions/Legends increase “big match feel” (slightly higher ceiling)
- Heel interference can lower match quality but increase story heat

========================
MANDATORY SUMMARY LANGUAGE
========================

8) REQUIRED ADJECTIVE
You MUST include at least ONE adjective in the summary from the list below:

Perfect-tier: "Classic", "Masterpiece", "Incredible"
Great-tier: "Fantastic", "Thrilling", "Excellent"
Standard-tier: "Solid", "Competitive", "Decent"
Poor-tier: "Sloppy", "Boring", "Rough"
Squash-tier: "Squash", "Dominated", "Quick Win"

Use it naturally inside the recap.

OUTPUT FORMAT:
Return strictly a JSON Array of objects using the 'temp_id' provided.
Example:
[
  {
    "temp_id": 1,
    "winner": "Name" (or null),
    "stars": "3.5",
    "finish_type": "Pinfall" (or DQ, Submission, Count Out, Roll-up / Distraction),
    "summary": "Detailed 2-3 sentence recap of the finish or promo event. Explain segment quality for ratings system. Use keywords like 'Classic' or 'Sloppy' to describe it."
  }
]`;

  try {
    const res = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${key}`
      },
      body: JSON.stringify({
        model: "gpt-5.2",
        messages: [{ role: "user", content: prompt }]
      })
    });

    const data = await res.json();
    if (data.error) throw new Error(data.error.message);

    const content = data.choices[0].message.content.replace(/```json|```/g, '');
    const results = JSON.parse(content);

    let matchCount = 0;

    // 4) Safety loop (OLD behavior preserved): iterate PENDING, apply fallbacks if AI drops items
    pending.forEach((p, index) => {
      const simpleId = index + 1;
      const segment = cardData.find(m => m.id === p.id);
      const aiRes = results.find(r => r.temp_id === simpleId || r.id === simpleId);

      if (!segment) return;

      if (aiRes) {
        // Success path
        if (!segment.actual_winner && aiRes.winner) segment.actual_winner = aiRes.winner;
        if (!segment.notes && aiRes.summary) segment.notes = aiRes.summary;

        // Preserve structured finish_type if returned
        if (segment.type === 'match' && aiRes.finish_type && !segment.finish_type) {
          segment.finish_type = aiRes.finish_type;
        }

        // Stars: prefer your text->stars extractor (kept)
        if (!segment.stars && typeof calculateStarsFromText === 'function') {
          segment.stars = calculateStarsFromText(aiRes.summary);
        } else if (!segment.stars && aiRes.stars) {
          // fallback to model-provided stars if your extractor isn't available
          segment.stars = String(aiRes.stars);
        }

      } else {
        // Fallback path (OLD behavior preserved)
        console.warn(`AI dropped segment "${p.title}". Applying defaults.`);
        if (!segment.actual_winner && segment.type === 'match') {
          segment.actual_winner = (segment.participants && segment.participants[0]) ? segment.participants[0] : "Draw";
        }
        if (!segment.notes) segment.notes = "Simulated result (AI Timeout). Match was decent.";
        segment.stars = segment.stars || "2.5";
        if (segment.type === 'match' && !segment.finish_type) segment.finish_type = "Pinfall";
      }

      // Rankings/divisions update (OLD behavior preserved)
      if (segment.type === 'match' && segment.participants) {
        matchCount++;
        const losers = segment.participants.filter(x => x !== segment.actual_winner);
        if (typeof updateDivisionStandings === 'function') {
          updateDivisionStandings(segment.actual_winner, losers, segment);
        }
      }
    });

    generatePowerRankings();
    saveGame();
    renderLiveFeed();

    alert(`Simulation Complete!\n\n- ${results.length} Segments Simulated\n- ${matchCount} Matches Decided`);

  } catch (e) {
    console.error(e);
    alert("Simulation failed: " + e.message);
  } finally {
    btn.innerHTML = originalText;
    btn.disabled = false;
  }
}


       function finishShowSimple() {
    if(!confirm("Finish show and save results? (No magazine report will be generated)")) return;
    
    const summaryHTML = `<div class="p-10 text-center"><h1 class="text-4xl font-black text-slate-800 mb-4">${activeShow.name} Results</h1><div class="text-left max-w-2xl mx-auto space-y-4">${cardData.map(s => `
        <div class="border-b border-slate-300 pb-2">
            <div class="font-bold text-lg">${s.title}</div>
            <div class="text-sm text-slate-600">${s.type === 'match' ? `Winner: ${s.actual_winner || 'Draw'} (${s.stars}★)` : 'Segment'}</div>
            <div class="text-xs text-slate-500 italic">${s.notes || ''}</div>
        </div>`).join('')}</div></div>`;

    const reportId = Date.now().toString(); 
    currentSave.history.push({ id: reportId, showName: activeShow.name, date: activeShow.date, html: summaryHTML, timestamp: new Date().toLocaleString() }); 
    
    const showIndex = currentSave.shows.findIndex(s => s.id === activeShow.id);
    if(showIndex !== -1) {
        currentSave.shows[showIndex].status = 'completed';
        currentSave.shows[showIndex].reportId = reportId;
    }

    // --- UPDATED: UPDATE RANKS BUT KEEP HISTORY ---
    if (activeShow.type === 'weekly') {
        generatePowerRankings(activeShow.name, false);
    }
    generatePowerRankings('global', false);

    // --- ADD THIS LINE HERE ---
    checkRivalryCompletions();
    // --------------------------


    saveGame(); 
    cardData = []; 
    activeShow = null; 
    renderArchiveList(); 
    renderCalendar(); 
    switchMainView('calendar'); 
}

function updateDivisionStandings(winnerName, loserNames, segment) {
    if (!winnerName || !loserNames || loserNames.length === 0) return;
    if(!currentSave.lockedDivisions) currentSave.lockedDivisions = [];
    if(!currentSave.divisionTypes) currentSave.divisionTypes = {};

    // --- 1. STAT IMPACT (Unchanged) ---
    try {
        const starsNumRaw = parseFloat(segment?.stars || segment?.match_stars || 2.5);
        const starsNum = isNaN(starsNumRaw) ? 2.5 : Math.max(1, Math.min(5, starsNumRaw));

        const winnerObj = currentSave.roster.find(w => w.name === winnerName);
        const loserObjs = (loserNames || []).map(n => currentSave.roster.find(w => w.name === n)).filter(Boolean);

        if (winnerObj) {
            if (!winnerObj.stats) winnerObj.stats = { popularity: 70, momentum: 50 };
            const starDelta = Math.round((starsNum - 2.5) * 4);
            let underdogBonus = 0;
            loserObjs.forEach(lo => {
                if (lo?.stats?.popularity != null && lo.stats.popularity >= (winnerObj.stats.popularity + 10)) {
                    underdogBonus = Math.max(underdogBonus, 4);
                }
            });
            winnerObj.stats.momentum = Math.max(0, Math.min(100, winnerObj.stats.momentum + 6 + starDelta + underdogBonus));
            winnerObj.stats.popularity = Math.max(0, Math.min(100, winnerObj.stats.popularity + 1 + Math.max(0, Math.floor(starDelta / 4))));
        }

        loserObjs.forEach(lo => {
            if (!lo.stats) lo.stats = { popularity: 70, momentum: 50 };
            const starDelta = Math.round((starsNum - 2.5) * 4);
            lo.stats.momentum = Math.max(0, Math.min(100, lo.stats.momentum - (4 + Math.max(0, -starDelta))));
            lo.stats.popularity = Math.max(0, Math.min(100, lo.stats.popularity - (starsNum <= 2 ? 1 : 0)));
        });
    } catch(e) { console.warn("Stat calc error", e); }
    // ----------------------------------------------------------------

    ['system', 'official'].forEach(scope => {
        if (scope === 'official' && rankingMode === 'manual') return;

        // Helper accessors (Scope Aware)
        const getDiv = (w) => {
            const val = (scope === 'system' ? w.systemDivision : w.division);
            return (val === undefined || val === null) ? 6 : val;
        };
        const setDiv = (w, v) => { if(scope === 'system') w.systemDivision = v; else w.division = v; };
        const getRank = (w) => (scope === 'system' ? w.systemRank : w.rank);
        const setRank = (w, v) => { if(scope === 'system') w.systemRank = v; else w.rank = v; };

        // --- STEP 1: SNAPSHOT "INTEGRITY" COUNTS ---
        // We count exactly how big each division is RIGHT NOW so we can restore this exact size later.
        const snapshotCounts = {};
        
        currentSave.roster.forEach(w => {
            if (w.status === 'inactive' || w.status === 'champ') return; // Do not count inactive or champs

            const showKey = (w.shows && w.shows !== "") ? w.shows : 'Global';
            const d = getDiv(w);
            const divKey = `${showKey}-${d}`;
            
            // If this division is locked, we don't need to count it (it won't be poured)
            if (currentSave.lockedDivisions.includes(divKey)) return;

            // Save the count specifically for this division index
            if (!snapshotCounts[d]) snapshotCounts[d] = 0;
            snapshotCounts[d]++;
        });

        // --- STEP 2: CREATE POOLS (Exclude Locked, Inactive) ---
        const pools = { 'Standard': [], 'Women': [], 'Tag': [], 'WomenTag': [] };
        
        currentSave.roster.filter(w => w.status !== 'inactive').forEach(w => {
            const showKey = (w.shows && w.shows !== "") ? w.shows : 'Global';
            const currentDivIndex = getDiv(w);
            const divKey = `${showKey}-${currentDivIndex}`;
            
            // LOCKED DIVISIONS: Do not touch them.
            if (currentSave.lockedDivisions.includes(divKey)) return;

            const type = currentSave.divisionTypes[divKey] || 'Standard';
            
            if (pools[type]) pools[type].push(w);
            else pools['Standard'].push(w);
        });

        // --- STEP 3: PROCESS EACH POOL ---
        Object.keys(pools).forEach(type => {
            const roster = pools[type];
            if(roster.length === 0) return;

            // A. Sort by Rank
            roster.sort((a, b) => {
                if (a.status === 'champ' && b.status !== 'champ') return -1;
                if (b.status === 'champ' && a.status !== 'champ') return 1;
                return (getDiv(a) - getDiv(b)) || (getRank(a) - getRank(b));
            });

            // B. Apply Match Movement
            const winner = roster.find(w => w.name === winnerName);
            
            if (winner) {
               
		// --- TITLE LOGIC (GLOBAL ROSTER FIX) ---
                if (segment && segment.is_title_match && segment.title_name) {
                    let titleDivIndex = -1;
                    
                    if (activeShow && currentSave.showDivisions[activeShow.name]?.includes(segment.title_name)) {
                        titleDivIndex = currentSave.showDivisions[activeShow.name].indexOf(segment.title_name);
                    } else if (currentSave.showDivisions['Global']?.includes(segment.title_name)) {
                        titleDivIndex = currentSave.showDivisions['Global'].indexOf(segment.title_name);
                    }

                    if (titleDivIndex !== -1) {
                        // A. IDENTIFY NEW CHAMPIONS (Winner + Partner)
                        const newChamps = [winner];
                        
                        // FIX: Search GLOBAL roster for partner (ignore division boundaries)
                        if (winner.teamName) {
                            const partner = currentSave.roster.find(w => 
                                w.teamName === winner.teamName &&   
                                w.name !== winner.name &&           
                                segment.participants.includes(w.name) 
                            );
                            if (partner) newChamps.push(partner);
                        }

                        // B. STRIP *ALL* OLD CHAMPIONS IN THIS DIVISION
                        // Scan entire roster to ensure we catch everyone holding this specific belt
                        currentSave.roster.forEach(w => {
                            const wDiv = getDiv(w);
                            // Check if they are in this division AND have champ status
                            if (w.status === 'champ' && wDiv === titleDivIndex) {
                                // Only strip if they are NOT in the winning team (Retention check)
                                if (!newChamps.some(nc => nc.id === w.id)) {
                                    w.status = 'active'; 
                                }
                            }
                        });

                        // C. CROWN THE NEW CHAMPIONS
                        newChamps.forEach((nc, idx) => {
                            nc.status = 'champ';
                            setDiv(nc, titleDivIndex); // Move partner to this division
                            
                            // VISUAL FIX: If partner wasn't in this list effectively, pull them in
                            if (!roster.includes(nc)) {
                                roster.push(nc);
                            }
                            
                            // Move to Rank 0 (Winner) and Rank 1 (Partner)
                            moveWrestlerInArray(roster, nc, idx); 
                        });
                    }
                }
                // -------------------------------------------

                // Standard Leapfrog
                if (winner.status !== 'champ') {
                    let bestOpponentIdx = 99999;
                    loserNames.forEach(name => {
                        const l = roster.find(w => w.name === name);
                        if (l && l.status !== 'champ') { 
                            const idx = roster.indexOf(l);
                            if (idx < bestOpponentIdx) bestOpponentIdx = idx;
                        }
                    });
                    const winnerIdx = roster.indexOf(winner);
                    if (winnerIdx > bestOpponentIdx) {
                        moveWrestlerInArray(roster, winner, bestOpponentIdx);
                    }
                }
                
                // Loser Drop
                loserNames.forEach(name => {
                    const l = roster.find(w => w.name === name);
                    if (l && l.status !== 'champ' && winner.status !== 'champ') {
                        if (roster.indexOf(l) < roster.indexOf(winner)) {
                            moveWrestlerInArray(roster, l, roster.indexOf(winner));
                        }
                    }
                });
            }

            // C. THE POUR (Using SNAPSHOT counts)
            
            // 1. Identify Valid Target Buckets
            const validDivisions = [];
            const refWrestler = winner || roster[0];
            const showKey = (refWrestler && refWrestler.shows) ? refWrestler.shows : 'Global';

            for(let d=0; d<=6; d++) {
                const divKey = `${showKey}-${d}`;
                if (currentSave.lockedDivisions.includes(divKey)) continue;

                const divType = currentSave.divisionTypes[divKey] || 'Standard';
                if(divType === type) {
                    validDivisions.push({ index: d, key: divKey });
                }
            }
            
            // 2. Pour Logic
            let cursor = 0;
            
            validDivisions.forEach(divData => {
                const d = divData.index;
                
                // USE THE SNAPSHOT LIMIT HERE
                // If the snapshot has no data for this division (e.g. empty), limit is 0.
                let capacity = snapshotCounts[d] || 0;
                
                for (let i = 0; i < capacity; i++) {
                    // Skip Champs (they don't consume capacity)
                    while(cursor < roster.length && roster[cursor].status === 'champ') {
                        cursor++;
                    }
                    // Assign valid wrestler to this bucket
                    if (roster[cursor]) {
                        setDiv(roster[cursor], d);
                        setRank(roster[cursor], i);
                        cursor++;
                    }
                }
            });
            
            // 3. Dump Stragglers (Anyone left over goes to the lowest/last bucket)
            if (validDivisions.length > 0) {
                const dumpDiv = validDivisions[validDivisions.length - 1].index;
                while(cursor < roster.length) {
                    if (roster[cursor].status !== 'champ') {
                        setDiv(roster[cursor], dumpDiv);
                    }
                    cursor++;
                }
            }
        });
    });
    
    saveGame();
}

function moveWrestlerInArray(arr, item, toIndex) {
    const fromIndex = arr.indexOf(item);
    if (fromIndex === -1) return;
    arr.splice(fromIndex, 1);
    arr.splice(toIndex, 0, item);
}

// --- MISSING FUNCTIONS FIX ---

function toggleCardDetail(index) {
    const detail = document.getElementById(`detail-${index}`);
    const chevron = document.getElementById(`chevron-${index}`);
    
    if (detail.classList.contains('hidden')) {
        detail.classList.remove('hidden');
        chevron.classList.remove('fa-chevron-down');
        chevron.classList.add('fa-chevron-up');
    } else {
        detail.classList.add('hidden');
        chevron.classList.remove('fa-chevron-up');
        chevron.classList.add('fa-chevron-down');
    }
}

// Fix Drag & Drop (also likely missing)
let draggedSegmentIndex = null;

function segDragStart(index) {
    draggedSegmentIndex = index;
}

function allowDrop(ev) {
    ev.preventDefault();
}

function segDrop(ev, targetIndex) {
    ev.preventDefault();
    if (draggedSegmentIndex === null || draggedSegmentIndex === targetIndex) return;
    
    // Move the segment
    const item = cardData.splice(draggedSegmentIndex, 1)[0];
    cardData.splice(targetIndex, 0, item);
    
    draggedSegmentIndex = null;
    activeShow.segments = cardData; // Update the show object
    saveGame();
    renderPlanner();
}

// Fix Roster Drag Over (also missing)
function dragOver(ev) {
    ev.preventDefault();
}

// --- EXPORT / BACKUP FUNCTION ---
function exportSaveToFile() {
    if (!currentSave) return alert("No active save to backup!");

    // --- PRE-FLIGHT CHECK: Ensure new features exist in the data structure ---
    // This guarantees your JSON file has the correct schema for the new engines
    if (!currentSave.rivalries) currentSave.rivalries = [];
    if (!currentSave.divisionTypes) currentSave.divisionTypes = {};       // For the 4-Silo System
    if (!currentSave.lockedDivisions) currentSave.lockedDivisions = [];   // For Roster Locks
    if (!currentSave.settings) currentSave.settings = { capEnabled: false, capLimit: 50 }; // For Hard Mode
    if (!currentSave.seriesConfig) currentSave.seriesConfig = {};         // For Centralized Logos
    if (!currentSave.beltImages) currentSave.beltImages = {};             // For Custom Belts

    // Add a timestamp so you know exactly when this file was made
    currentSave.lastExported = new Date().toLocaleString();

    // 1. Create the JSON string
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(currentSave));
    
    // 2. Create a virtual anchor link
    const downloadAnchorNode = document.createElement('a');
    
    // 3. Name the file: "InsideCount_SaveName_Date.json"
    const dateStr = new Date().toISOString().split('T')[0];
    const safeName = (currentSave.name || "Universe").replace(/[^a-z0-9]/gi, '_').toLowerCase();
    
    downloadAnchorNode.setAttribute("href", dataStr);
    downloadAnchorNode.setAttribute("download", `InsideCount_${safeName}_${dateStr}.json`);
    
    // 4. Trigger the download
    document.body.appendChild(downloadAnchorNode);
    downloadAnchorNode.click();
    downloadAnchorNode.remove();
}

// =========================================
// RIVALRY ENGINE (Upgraded)
// =========================================

let activeRivalryId = null;
let activeSideIndex = 0; 

// 1. Initialize data structure
function initRivalries() {
    if (!currentSave.rivalries) currentSave.rivalries = [];
}

// Helper: Get Next Unplayed Show Date
function getNextShowDate() {
    const planned = currentSave.shows
        .filter(s => s.status === 'planned')
        .sort((a,b) => new Date(a.date) - new Date(b.date));
    return planned.length > 0 ? planned[0].date : new Date().toISOString().split('T')[0];
}

// 2. Render Sidebar (Grouped by Show)
function renderRivalryList() {
    initRivalries();
    const list = document.getElementById('rivalry-list');
    list.innerHTML = '';
    
    // Check if totally empty
    if (currentSave.rivalries.length === 0 && (!currentSave.archivedRivalries || currentSave.archivedRivalries.length === 0)) {
        list.innerHTML = '<div class="text-xs text-slate-500 italic p-2">No active or archived storylines.</div>';
        return;
    }
    
    // --- 1. ACTIVE RIVALRIES (Grouped by Show) ---
    const groups = {};
    currentSave.rivalries.forEach(r => {
        const host = r.host || 'Global';
        if (!groups[host]) groups[host] = [];
        groups[host].push(r);
    });

    Object.keys(groups).sort().forEach(host => {
        list.innerHTML += `<div class="text-[10px] font-bold text-blue-400 uppercase mt-4 mb-1 px-1 border-b border-slate-700 pb-1">${host}</div>`;
        groups[host].forEach(r => {
            const activeClass = (activeRivalryId === r.id) ? 'bg-slate-700 border-l-4 border-blue-500' : 'bg-slate-800 hover:bg-slate-700 border-l-4 border-transparent';
            
            let blowoffName = "No End Date";
            if (r.blowoff) {
                const show = currentSave.shows.find(s => s.id === r.blowoff);
                if(show) blowoffName = `Ends: ${show.name}`;
            }

            list.innerHTML += `
                <div onclick="loadRivalry('${r.id}')" class="${activeClass} p-3 rounded cursor-pointer transition mb-2">
                    <div class="font-bold text-white text-sm truncate">${r.name || 'Untitled'}</div>
                    <div class="text-[10px] text-slate-400 flex justify-between mt-1">
                        <span>${blowoffName}</span>
                        <span>${countParticipants(r)} People</span>
                    </div>
                </div>`;
        });
    });

    // --- 2. ARCHIVED RIVALRIES (Grouped by Show) ---
    if (currentSave.archivedRivalries && currentSave.archivedRivalries.length > 0) {
        
        // Group Archives
        const arcGroups = {};
        currentSave.archivedRivalries.forEach(r => {
            const host = r.host || 'Global';
            if (!arcGroups[host]) arcGroups[host] = [];
            arcGroups[host].push(r);
        });

        Object.keys(arcGroups).sort().forEach(host => {
            // Grey Header for Archives
            list.innerHTML += `<div class="text-[10px] font-bold text-slate-500 uppercase mt-6 mb-1 px-1 border-b border-slate-700 pb-1">${host} ARCHIVE</div>`;
            
            arcGroups[host].slice().reverse().forEach(r => {
                const activeClass = (activeRivalryId === r.id) ? 'bg-slate-800 border-l-4 border-slate-500' : 'bg-slate-900 hover:bg-slate-800 border-l-4 border-transparent opacity-60 hover:opacity-100';
                
                list.innerHTML += `
                    <div onclick="loadRivalry('${r.id}')" class="${activeClass} p-3 rounded cursor-pointer transition mb-2">
                        <div class="font-bold text-slate-400 text-sm truncate line-through decoration-slate-600">${r.name}</div>
                        <div class="text-[10px] text-slate-500 mt-1 flex justify-between">
                            <span>🏁 ${r.conclusionShow || 'Finished'}</span>
                            <span>${r.archivedDate || ''}</span>
                        </div>
                    </div>`;
            });
        });
    }
}

// 3. Create New (With Default Date)
function createNewRivalry() {
    initRivalries();
    const newRiv = {
        id: Date.now().toString(),
        name: "New Storyline",
        start: getNextShowDate(), // Defaults to next show date
        host: "Global",
        blowoff: "", 
        goal: "",
        sides: [[], [], [], []]
    };
    currentSave.rivalries.push(newRiv);
    saveGame();
    renderRivalryList();
    loadRivalry(newRiv.id);
}

// 4. Load & Populate Dropdowns
function loadRivalry(id) {
    activeRivalryId = id;
    
    // 1. Identify Target
    let r = currentSave.rivalries.find(x => x.id === id);
    let isArchived = false;

    if (!r && currentSave.archivedRivalries) {
        r = currentSave.archivedRivalries.find(x => x.id === id);
        isArchived = true;
    }
    
    if(!r) return;

    // 2. UI Setup
    document.getElementById('rivalry-empty').classList.add('hidden');
    const editor = document.getElementById('rivalry-editor');
    editor.classList.remove('hidden');

    // 3. ARCHIVE VIEW MODE
    if (isArchived) {
        // Generate the History Report HTML
        const historyHTML = generateRivalryReport(r);
        
        // Inject into a temporary viewer (or overlay the editor)
        // We use a specific ID for the container so we can clear it later
        if(!document.getElementById('rivalry-archive-viewer')) {
            const viewer = document.createElement('div');
            viewer.id = 'rivalry-archive-viewer';
            viewer.className = "space-y-4";
            editor.appendChild(viewer);
        }
        
        // Hide standard inputs, Show Report
        Array.from(editor.children).forEach(c => {
            if(c.id !== 'rivalry-archive-viewer') c.style.display = 'none';
        });
        
        const viewer = document.getElementById('rivalry-archive-viewer');
        viewer.style.display = 'block';
        viewer.innerHTML = historyHTML;
        
        renderRivalryList();
        return; 
    }

    // 4. ACTIVE EDITOR MODE (Standard)
    // Restore inputs if they were hidden by the viewer
    if(document.getElementById('rivalry-archive-viewer')) {
        document.getElementById('rivalry-archive-viewer').style.display = 'none';
    }
    Array.from(editor.children).forEach(c => {
        if(c.id !== 'rivalry-archive-viewer') c.style.display = ''; // Restore default
    });

    // ... (Rest of your existing Input population logic) ...
    const nameInput = document.getElementById('riv-name');
    nameInput.value = r.name;
    nameInput.classList.remove('text-slate-500', 'line-through'); // Reset style

    document.getElementById('riv-start').value = r.start;
    document.getElementById('riv-goal').value = r.goal;

    const hostSelect = document.getElementById('riv-host');
    hostSelect.innerHTML = '<option value="Global">Global (Cross-Brand)</option>';
    const weeklyShows = [...new Set(currentSave.shows.filter(s => s.type === 'weekly').map(s => s.name))].sort();
    weeklyShows.forEach(s => hostSelect.innerHTML += `<option value="${s}">${s}</option>`);
    hostSelect.value = r.host || 'Global';

    populateBlowoffDropdown(); 
    document.getElementById('riv-blowoff').value = r.blowoff || "";

    for(let i=0; i<4; i++) {
        const container = document.getElementById(`riv-side-${i}`);
        container.innerHTML = '';
        if(r.sides[i]) {
            r.sides[i].forEach((wName, wIdx) => {
                container.innerHTML += `
                    <div class="flex justify-between items-center bg-slate-900/50 p-2 rounded border border-slate-700 mb-1">
                        <span class="text-xs font-bold text-slate-300">${wName}</span>
                        <button onclick="removeRivalryMember(${i}, ${wIdx})" class="text-slate-600 hover:text-red-500"><i class="fa-solid fa-xmark"></i></button>
                    </div>
                `;
            });
        }
    }

if (!isArchived) {
        let historyContainer = document.getElementById('active-rivalry-history');
        if (!historyContainer) {
            historyContainer = document.createElement('div');
            historyContainer.id = 'active-rivalry-history';
            historyContainer.className = "mt-12 pt-8 border-t border-slate-700";
            document.getElementById('rivalry-editor').appendChild(historyContainer);
        }
        // Generate the report inside the editor
        historyContainer.innerHTML = generateRivalryReport(r);
    }

    renderRivalryList();
}

// Helper: Populate Blowoff based on Start Date
function populateBlowoffDropdown() {
    const startDateVal = document.getElementById('riv-start').value;
    const blowoffSelect = document.getElementById('riv-blowoff');
    const currentVal = blowoffSelect.value; // Keep selection if possible

    blowoffSelect.innerHTML = '<option value="">- Select Target Show -</option>';
    
    if (!startDateVal) return;

    // Filter shows that happen ON or AFTER the start date
    const targetDate = new Date(startDateVal);
    const validShows = currentSave.shows
        .filter(s => new Date(s.date) >= targetDate)
        .sort((a,b) => new Date(a.date) - new Date(b.date));

    validShows.forEach(s => {
        let typeBadge = s.type === 'special' ? '⭐' : '📺';
        blowoffSelect.innerHTML += `<option value="${s.id}">${typeBadge} ${s.date} - ${s.name}</option>`;
    });

    blowoffSelect.value = currentVal;
}

// 5. Save Changes
function saveCurrentRivalry() {
    if(!activeRivalryId) return;
    const r = currentSave.rivalries.find(x => x.id === activeRivalryId);
    if(r) {
        r.name = document.getElementById('riv-name').value;
        r.start = document.getElementById('riv-start').value;
        r.host = document.getElementById('riv-host').value;
        r.blowoff = document.getElementById('riv-blowoff').value;
        r.goal = document.getElementById('riv-goal').value;
        
        saveGame();
        renderRivalryList();
    }
}

// 6. Delete
function deleteCurrentRivalry() {
    if(confirm("End this storyline permanently?")) {
        currentSave.rivalries = currentSave.rivalries.filter(r => r.id !== activeRivalryId);
        activeRivalryId = null;
        document.getElementById('rivalry-editor').classList.add('hidden');
        document.getElementById('rivalry-empty').classList.remove('hidden');
        saveGame();
        renderRivalryList();
    }
}

// 7. Add Member Modal (With Status Icons)
function addRivalryMember(sideIndex) {
    activeSideIndex = sideIndex;
    const r = currentSave.rivalries.find(x => x.id === activeRivalryId);
    if(r.sides[sideIndex].length >= 5) return alert("Max 5 wrestlers per side.");

    const select = document.getElementById('riv-wrestler-select');
    select.innerHTML = '<option value="">Select Wrestler</option>';
    
    // Filter Logic (Show Specific vs Global)
    let sourceRoster = currentSave.roster;
    if (r.host && r.host !== 'Global') {
        sourceRoster = sourceRoster.filter(w => w.shows === r.host);
    }

    // Sort alpha
    const sortedRoster = [...sourceRoster].sort((a,b) => a.name.localeCompare(b.name));
    
    sortedRoster.forEach(w => {
        let label = w.name;
        
        // --- ADD STATUS ICONS ---
        if (w.status === 'champ') label = `👑 ${w.name}`;
        else if (w.status === 'mitb') label = `💼 ${w.name}`;
        
        // --- ADD INJURY ICONS ---
        if (w.injury === 'Light') label += ` (🩹)`;
        else if (w.injury === 'Moderate') label += ` (🚑)`;
        else if (w.injury === 'Severe') label += ` (❌ Injured)`;

        // Note: We do NOT disable severe injuries here, because you might want 
        // to add an injured wrestler to a faction for storyline purposes (e.g. as a manager).
        select.innerHTML += `<option value="${w.name}">${label}</option>`;
    });

    document.getElementById('rivalry-pick-modal').classList.remove('hidden');
}

function confirmRivalryMember() {
    const name = document.getElementById('riv-wrestler-select').value;
    if(!name) return;
    
    const r = currentSave.rivalries.find(x => x.id === activeRivalryId);
    r.sides[activeSideIndex].push(name);
    
    saveGame();
    loadRivalry(activeRivalryId);
    document.getElementById('rivalry-pick-modal').classList.add('hidden');
}

function removeRivalryMember(sideIdx, memberIdx) {
    const r = currentSave.rivalries.find(x => x.id === activeRivalryId);
    r.sides[sideIdx].splice(memberIdx, 1);
    saveGame();
    loadRivalry(activeRivalryId);
}

function countParticipants(r) {
    let count = 0;
    r.sides.forEach(s => count += s.length);
    return count;
}    

async function uploadRankingHero() {
    const input = document.getElementById('rankings-upload-input');
    const file = input.files[0];
    if (!file) return;

    // 1. Convert image to Base64 string
    const base64 = await readImage(file);

    // 2. Ensure the data object exists for the current filter (Global, Raw, etc.)
    if (!currentSave.powerRankings) currentSave.powerRankings = {};
    if (!currentSave.powerRankings[rankingFilter]) {
        currentSave.powerRankings[rankingFilter] = { manual: [], ai: [] };
    }

    // 3. Save the image string to the save file
    currentSave.powerRankings[rankingFilter].featureImage = base64;
    saveGame();

    // 4. Update the visual immediately
    document.getElementById('ranking-hero-img').src = base64;
    
    // 5. Reset input so you can upload the same file again if needed
    input.value = ''; 
}

// ROBUST MERGED VERSION
// Goal: keep the OLD functionality (works even with minimal data) + add the NEW dossier grounding
// Added: hard guards for missing functions/fields, exact-key enforcement, score preservation, safe fallbacks.

async function generateRankingBlurbs() {
  const key = localStorage.getItem('openai_key');
  if (!key) return alert("API Key required for AI Analysis.");

  // 1) Get current list (Top 10)
  if (!currentSave.powerRankings || !currentSave.powerRankings[rankingFilter]) {
    return alert("No rankings found. Run the tracker first.");
  }
  let list = currentSave.powerRankings[rankingFilter][rankingMode];
  if (!list || list.length === 0) return alert("List is empty.");

  const topEntries = list.slice(0, 10);

  // Preserve any existing scores BEFORE we potentially convert strings -> objects
  const scoreMap = {};
  topEntries.forEach((entry) => {
    if (entry && typeof entry === 'object' && entry.name) {
      scoreMap[entry.name] = entry.score;
    }
  });

  // 2) UI Feedback
  const btn = document.querySelector('button[onclick="generateRankingBlurbs()"]');
  const originalText = btn ? btn.innerHTML : "";
  if (btn) {
    btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Gathering Intel...`;
    btn.disabled = true;
  }

  // Helper: safe string name extraction
  const getEntryName = (entry) => (typeof entry === 'object' ? entry.name : entry);

  // Helper: safe recent history fetch
  const safeRecentHistory = (name, n) => {
    try {
      if (typeof getRecentMatchHistory === 'function') {
        const h = getRecentMatchHistory(name, n);
        return Array.isArray(h) ? h : [];
      }
    } catch (e) {
      console.warn("getRecentMatchHistory failed:", e);
    }
    return [];
  };

  // Helper: safe rivalry lookup
  const safeRivalryText = (name) => {
    try {
      if (Array.isArray(currentSave.rivalries)) {
        const rivalry = currentSave.rivalries.find(r => {
          const flat = Array.isArray(r?.sides) ? r.sides.flat() : [];
          return flat.includes(name);
        });
        if (rivalry) {
          const flat = Array.isArray(rivalry?.sides) ? rivalry.sides.flat() : [];
          const rival = flat.find(n => n && n !== name);
          return rival ? `Feuding with ${rival}` : "Active feud (faction)";
        }
      }
    } catch (e) {
      console.warn("Rivalry lookup failed:", e);
    }
    return "No active feud";
  };

  // Helper: build opponent text safely (tag/multi aware)
  const describeOpponents = (participants, name) => {
    const arr = Array.isArray(participants) ? participants.filter(Boolean) : [];
    const opps = arr.filter(p => p !== name);
    if (opps.length === 0) return "an opponent";
    // Keep it short for tickers
    if (opps.length === 1) return opps[0];
    if (opps.length === 2) return `${opps[0]} and ${opps[1]}`;
    return `${opps[0]} and others`;
  };

  try {
    // 3) Build dossier (Top 10)
    const dossier = topEntries.map((entry, i) => {
      const name = getEntryName(entry);
      const w = Array.isArray(currentSave.roster)
        ? currentSave.roster.find(r => r && r.name === name)
        : null;

      // Score preservation
      const score =
        (entry && typeof entry === 'object' && typeof entry.score !== 'undefined') ? entry.score :
        (typeof scoreMap[name] !== 'undefined') ? scoreMap[name] :
        (entry && typeof entry === 'object' && typeof entry.score === 'number') ? entry.score :
        "N/A";

      // Recent history (safe)
      const historyRaw = safeRecentHistory(name, 3);
      const history = historyRaw.map(m => {
        const winner = m?.actual_winner;
        const participants = m?.participants;
        const result = (winner && winner === name) ? "WON against" : "LOST to";
        const opponentText = describeOpponents(participants, name);

        // date field can vary by save version
        const date = m?.date || m?.showDate || m?.eventDate || "";
        const dateText = date ? ` (${date})` : "";
        return `${result} ${opponentText}${dateText}`;
      }).filter(Boolean);

      // Status (safe)
      let status = [];
      if (w) {
        if (w.status === 'champ') status.push("CHAMPION");
        if (w.status === 'mitb') status.push("MITB HOLDER");
        if (w.injury && w.injury !== 'Healthy') status.push(`INJURED (${w.injury})`);
      }

      return {
        rank: i + 1,
        name,
        power_score: score,
        status: status.length ? status.join(", ") : (w ? "Active" : "No roster data"),
        recent_activity: history.length ? history.join("; ") : "No recent televised matches.",
        current_story: safeRivalryText(name)
      };
    });

    // 4) Context-aware prompt (robust)
    const namesList = dossier.map(d => d.name);

    const prompt = `
You are a professional wrestling sports analyst (Kayfabe + Insider mix).

INPUT DATA (Top 10 Power Rankings with Context):
${JSON.stringify(dossier)}

TASK:
Write EXACTLY ONE punchy 1-sentence "Ticker Blurb" for EACH wrestler in the Top 10 explaining why they are ranked there.

CRITICAL RULES:
1) STRICT KEYS: Your JSON must contain EXACTLY these 10 keys, spelled EXACTLY as given:
${JSON.stringify(namesList)}
No extra keys. No missing keys. No renamed keys.

2) USE THE DATA: If "recent_activity" contains WON/LOST results, mention them accurately. Do NOT invent matches.
3) IF QUIET WEEK: If "recent_activity" is "No recent televised matches.", write something generic like "Maintains position during a quiet week."
4) CHAMPIONS: If status contains CHAMPION, acknowledge it.
5) INJURIES: If status contains INJURED, reflect it (e.g., "drops due to injury concern" or "holds steady despite injury").
6) STYLE: SportsCenter / ESPN ticker. Tight and punchy. No more than ~20 words.

OUTPUT FORMAT:
Return ONLY a JSON object mapping names -> blurb strings. No markdown. No commentary.
Example:
{
  "Name A": "Blurb...",
  "Name B": "Blurb..."
}
`.trim();

    const res = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: { "Content-Type": "application/json", "Authorization": `Bearer ${key}` },
      body: JSON.stringify({
        model: "gpt-5.2",
        messages: [{ role: "user", content: prompt }],
        response_format: { type: "json_object" }
      })
    });

    const data = await res.json();
    if (data.error) throw new Error(data.error.message);

    let json;
    try {
      json = JSON.parse(data.choices[0].message.content);
    } catch (e) {
      console.warn("AI returned non-JSON; attempting cleanup parse.");
      const cleaned = String(data.choices[0].message.content || "").replace(/```json|```/g, "").trim();
      json = JSON.parse(cleaned);
    }

    // 5) Enforce completeness & safe fallback
    const fallbackBlurb = (name, idx) => {
      // Small variety but still safe (no hallucinated matches)
      const templates = [
        "Holds steady in the rankings after a quiet week.",
        "Maintains momentum as the division watches closely.",
        "Stays in the mix with consistent performances.",
        "Keeps their spot while the landscape shifts around them."
      ];
      return templates[idx % templates.length];
    };

    // 6) Update the data (preserve existing scores; add/overwrite blurbs)
    list.forEach((entry, listIdx) => {
      const name = getEntryName(entry);
      if (!namesList.includes(name)) return; // only top 10 updated

      const blurb = (json && typeof json[name] === 'string' && json[name].trim())
        ? json[name].trim()
        : fallbackBlurb(name, namesList.indexOf(name));

      if (typeof entry !== 'object') {
        // Convert string entry to object so we can store blurb; preserve score if known
        const idx = list.indexOf(entry);
        list[idx] = {
          name,
          score: (typeof scoreMap[name] !== 'undefined') ? scoreMap[name] : 0,
          blurb
        };
      } else {
        // Keep existing object fields intact; only update blurb
        entry.blurb = blurb;
        // If score was missing but we had it, restore
        if (typeof entry.score === 'undefined' && typeof scoreMap[name] !== 'undefined') {
          entry.score = scoreMap[name];
        }
      }
    });

    saveGame();
    renderRankings();
    alert("Analysis Complete!");

  } catch (e) {
    console.error(e);
    alert("AI Error: " + e.message);
  } finally {
    if (btn) {
      btn.innerHTML = originalText;
      btn.disabled = false;
    }
  }
}


// --- RANKING DRAG & DROP LOGIC ---
let draggedRankIndex = null;

function rankDragStart(index) {
    draggedRankIndex = index;
}

function rankDragOver(e) {
    e.preventDefault(); // Allows the drop to happen
}

function rankDrop(e, targetIndex) {
    e.preventDefault();
    if (draggedRankIndex === null || draggedRankIndex === targetIndex) return;

    // 1. Get the current list (Manual Mode only)
    // We strictly assume we are in manual mode if dragging is enabled
    const list = currentSave.powerRankings[rankingFilter].manual;

    // 2. Perform the Move
    // Remove from old spot
    const item = list.splice(draggedRankIndex, 1)[0];
    // Insert at new spot
    list.splice(targetIndex, 0, item);

    // 3. Save & Render
    draggedRankIndex = null;
    saveGame();
    renderRankings();
}


// 1. OPEN ROSTER MODE (Connects to your existing Roster Sync)
function openRosterSyncModal() {
    const modal = document.getElementById('sync-modal');
    if(!modal) return;

    // Reset Title
    modal.querySelector('h3').innerText = "Sync Roster Data";

    // Reset Buttons to use ROSTER logic
    const btn1 = modal.querySelector('button[onclick*="_to_system"]');
    const btn2 = modal.querySelector('button[onclick*="_to_manual"]');

    // Set Roster Actions
    btn1.setAttribute('onclick', "runRosterSync('manual_to_system')");
    btn1.innerHTML = `
        <span class="text-sm font-bold uppercase tracking-wider">Push Manual <i class="fa-solid fa-arrow-right mx-1 text-slate-500"></i> System</span>
        <span class="text-[10px] text-blue-300/70 font-normal">Make System Tracker match my manual edits</span>
    `;

    btn2.setAttribute('onclick', "runRosterSync('system_to_manual')");
    btn2.innerHTML = `
        <span class="text-sm font-bold uppercase tracking-wider">Pull System <i class="fa-solid fa-arrow-right mx-1 text-slate-500"></i> Manual</span>
        <span class="text-[10px] text-purple-300/70 font-normal">Reset my manual view to match system math</span>
    `;

    modal.classList.remove('hidden');
}

// 2. OPEN RANKING MODE (The New Feature)
function openRankingSyncModal() {
    const modal = document.getElementById('sync-modal');
    if(!modal) return;

    // Change Title
    modal.querySelector('h3').innerText = "Sync Power Rankings";
    
    // Change Buttons to use RANKING logic
    const btn1 = modal.querySelector('button[onclick*="_to_system"]');
    const btn2 = modal.querySelector('button[onclick*="_to_manual"]');
    
    // Set Ranking Actions
    btn1.setAttribute('onclick', "runRankingSync('manual_to_system')");
    btn1.innerHTML = `
        <span class="text-sm font-bold uppercase tracking-wider">Push Manual <i class="fa-solid fa-arrow-right mx-1 text-slate-500"></i> System</span>
        <span class="text-[10px] text-blue-300/70 font-normal">Force System Tracker to match my Manual order</span>
    `;

    btn2.setAttribute('onclick', "runRankingSync('system_to_manual')");
    btn2.innerHTML = `
        <span class="text-sm font-bold uppercase tracking-wider">Pull System <i class="fa-solid fa-arrow-right mx-1 text-slate-500"></i> Manual</span>
        <span class="text-[10px] text-purple-300/70 font-normal">Reset Manual view to match calculated scores</span>
    `;

    modal.classList.remove('hidden');
}

// 3. THE RANKING LOGIC (The Math)
function runRankingSync(direction) {
    if (!currentSave.powerRankings[rankingFilter]) {
        currentSave.powerRankings[rankingFilter] = { manual: [], ai: [] };
    }
    
    const root = currentSave.powerRankings[rankingFilter];
    let confirmMsg = "";

    if (direction === 'manual_to_system') {
        confirmMsg = "⚠️ OVERWRITE SYSTEM TRACKER?\n\nThis will replace the calculated AI scores with your Manual order.\n\nArbitrary scores will be assigned to preserve the rank order.\n\nContinue?";
        if (!confirm(confirmMsg)) return;

        // Map Manual List -> System Object Structure (Assign fake scores to keep order)
        root.ai = root.manual.map((entry, i) => {
            let name = typeof entry === 'object' ? entry.name : entry;
            return {
                name: name,
                score: 100 - i, // Fake score to force order
                prevRank: i + 1,
                blurb: (typeof entry === 'object' ? entry.blurb : "")
            };
        });

    } else {
        confirmMsg = "⚠️ OVERWRITE MANUAL RANKINGS?\n\nThis will discard your custom drag-and-drop order and replace it with the System's mathematical rankings.\n\nContinue?";
        if (!confirm(confirmMsg)) return;

        // Clone AI List -> Manual List
        root.manual = JSON.parse(JSON.stringify(root.ai));
    }

    saveGame();
    renderRankings();
    document.getElementById('sync-modal').classList.add('hidden');
    alert("Rankings Synced!");
}

// =========================================
// EXTEND TIMELINE 2.0 (Granular & Smart)
// =========================================

// 1. OPEN THE UI
function extendSpecificYear() {
    if (!currentSave.shows || currentSave.shows.length === 0) return alert("No shows found to extend!");

    const inputYear = prompt("Which year do you want to use as the template?\n(e.g., enter '2024' to generate the 2025 schedule)");
    if (!inputYear) return;

    const sourceYear = parseInt(inputYear);
    if (isNaN(sourceYear)) return alert("Invalid year entered.");
    
    // Prep Data
    const showsInYear = currentSave.shows.filter(s => parseInt(s.date.split('-')[0]) === sourceYear);
    if (showsInYear.length === 0) return alert(`No shows found in ${sourceYear}.`);

    // Get Unique Series Names
    const uniqueSeries = [...new Set(showsInYear.map(s => s.name))].sort();

    // Fill Modal
    document.getElementById('extend-source-year').value = sourceYear;
    document.getElementById('extend-target-year').value = sourceYear + 1;
    
    const list = document.getElementById('extend-show-list');
    list.innerHTML = '';

    uniqueSeries.forEach(name => {
        // Find one instance to get type info
        const ref = showsInYear.find(s => s.name === name);
        let badge = ref.type === 'weekly' ? '<span class="bg-blue-600 text-white text-[10px] px-1 rounded">WEEKLY</span>' : '<span class="bg-yellow-600 text-white text-[10px] px-1 rounded">PPV</span>';
        let hostInfo = "";
        if (ref.participatingShows && ref.participatingShows.length > 0) hostInfo = `<span class="text-[9px] text-slate-500 ml-2">Hosts: ${ref.participatingShows.join(', ')}</span>`;

        list.innerHTML += `
            <label class="flex items-center bg-slate-900 p-2 rounded border border-slate-700 cursor-pointer hover:border-slate-500">
                <input type="checkbox" class="extend-checkbox w-4 h-4 text-green-500 rounded bg-slate-800 border-slate-600 mr-3" value="${escapeStr(name)}" checked>
                <div class="flex-1">
                    <div class="flex justify-between items-center">
                        <span class="font-bold text-sm text-white">${name}</span>
                        ${badge}
                    </div>
                    ${hostInfo}
                </div>
            </label>
        `;
    });

    document.getElementById('extend-modal').classList.remove('hidden');
}

function toggleExtendCheckboxes(state) {
    document.querySelectorAll('.extend-checkbox').forEach(cb => cb.checked = state);
}

// 2. PROCESS THE EXTENSION
function processExtension() {
    const sourceYear = parseInt(document.getElementById('extend-source-year').value);
    const targetYear = parseInt(document.getElementById('extend-target-year').value);
    
    // Get Selected Names
    const checkboxes = document.querySelectorAll('.extend-checkbox:checked');
    const selectedNames = Array.from(checkboxes).map(cb => cb.value);

    if (selectedNames.length === 0) return alert("Select at least one show to extend.");

    let createdCount = 0;
    let skippedCount = 0; // For duplication reporting

    // Helper to check duplication
    const checkExists = (name, dateStr) => {
        // Does a show with this name exist within 3 days of target date?
        // (Allows for slight calendar drifts without duplicating)
        const target = new Date(dateStr);
        return currentSave.shows.some(s => {
            if (s.name !== name) return false;
            const existing = new Date(s.date);
            const diffTime = Math.abs(target - existing);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)); 
            return diffDays <= 6; // 6 day buffer (catches same-week duplicates)
        });
    };

    // Filter Source Data based on Selection
    const sourceShows = currentSave.shows.filter(s => {
        const y = parseInt(s.date.split('-')[0]);
        return y === sourceYear && selectedNames.includes(s.name);
    });

    // 1. Process Weekly Shows (Find latest config for each selected series)
    const weeklyConfigs = {};
    const specialEvents = [];

    sourceShows.forEach(s => {
        if (s.type === 'weekly') {
            // Calculate day of week
            const [y, m, d] = s.date.split('-').map(Number);
            const dayName = new Date(y, m - 1, d, 12, 0, 0).toLocaleDateString('en-US', { weekday: 'long' });
            weeklyConfigs[s.name] = {
                name: s.name, day: dayName, logo: s.logo, brand: s.brand, color: s.color, commentators: s.commentators, arena: s.arena
            };
        } else if (s.type === 'special') {
            specialEvents.push(s);
        }
    });

    // 2. Generate Weekly
    Object.values(weeklyConfigs).forEach(config => {
        const newDates = getDatesForYear(targetYear, config.day);
        newDates.forEach(dateStr => {
            if (checkExists(config.name, dateStr)) {
                skippedCount++;
                return;
            }

            currentSave.shows.push({
                id: Date.now() + Math.random().toString(), 
                name: config.name,
                date: dateStr,
                type: 'weekly',
                logo: config.logo,
                brand: config.brand,
                color: config.color,
                commentators: config.commentators,
                arena: config.arena,
                segments: [],
                status: 'planned'
            });
            createdCount++;
        });
    });

    // 3. Generate Specials (PPVs)
    specialEvents.forEach(ppv => {
        try {
            const [sy, sm, sd] = ppv.date.split('-').map(Number);
            
            // Logic: Find "Nth Weekday of Month"
            const sourceObj = new Date(sy, sm - 1, sd, 12, 0, 0);
            const weekday = sourceObj.getDay(); 
            const nthOccurrence = Math.ceil(sd / 7);
            
            let targetDate = new Date(targetYear, sm - 1, 1, 12, 0, 0);
            while (targetDate.getDay() !== weekday) targetDate.setDate(targetDate.getDate() + 1);
            targetDate.setDate(targetDate.getDate() + (nthOccurrence - 1) * 7);
            if (targetDate.getMonth() !== (sm - 1)) targetDate.setDate(targetDate.getDate() - 7);
            
            const dateStr = `${targetDate.getFullYear()}-${String(targetDate.getMonth()+1).padStart(2,'0')}-${String(targetDate.getDate()).padStart(2,'0')}`;
            
            // THE FIX: Check duplication before adding
            if (checkExists(ppv.name, dateStr)) {
                skippedCount++;
                return;
            }

            currentSave.shows.push({
                id: Date.now() + Math.random().toString(), 
                name: ppv.name,
                date: dateStr,
                type: 'special',
                logo: ppv.logo,
                color: ppv.color,
                commentators: ppv.commentators,
                arena: ppv.arena,
                participatingShows: ppv.participatingShows,
                segments: [],
                status: 'planned'
            });
            createdCount++;
            
        } catch(e) { console.error("Error extending PPV " + ppv.name, e); }
    });

    saveGame();
    renderCalendar();
    document.getElementById('extend-modal').classList.add('hidden');
    
    let msg = `Timeline Extended!\n\n${createdCount} new shows generated for ${targetYear}.`;
    if (skippedCount > 0) msg += `\n\n${skippedCount} shows were skipped because they (or something with the same name) already exist in ${targetYear}.`;
    
    alert(msg);
}
// Helper: Returns all dates for a specific weekday in a year
function getDatesForYear(year, dayName) {
    const dates = [];
    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    const targetDayIndex = days.indexOf(dayName);
    
    if (targetDayIndex === -1) return []; 

    let d = new Date(`${year}-01-01T12:00:00`);
    while (d.getDay() !== targetDayIndex) {
        d.setDate(d.getDate() + 1);
    }
    while (d.getFullYear() === year) {
        dates.push(d.toISOString().split('T')[0]); 
        d.setDate(d.getDate() + 7);
    }
    return dates;
}

function generateRivalryReport(r) {
    const allParticipants = r.sides.flat();
    let combinedHTML = '';

    // --- HELPER: Render Single Timeline Block ---
    const renderChapter = (start, end, blowoffId, chapterIndex, isCurrent) => {
        const startDate = new Date(start);
        const endDate = end ? new Date(end) : new Date(); // If active, go to today
        
        // 1. Filter Shows for this specific window
        const relevantShows = currentSave.shows.filter(s => {
            const sDate = new Date(s.date);
            // Strict Window: Start <= Show <= End
            return sDate >= startDate && sDate <= endDate && (String(s.id) !== String(blowoffId));
        });

        // 2. Build Timeline Bullets with Story Context
        let timelineBullets = '';
        relevantShows.forEach(show => {
            if (!show.segments) return;
            show.segments.forEach(seg => {
                if (seg.participants && seg.participants.some(p => allParticipants.includes(p))) {
                    // Context Logic: Try 'notes' (result) -> 'context_short' (plan) -> 'desc' -> 'Generic'
                    let narrative = seg.notes || seg.context_short || seg.desc || "No detailed notes.";
                    // Truncate if too long
                    if (narrative.length > 1000) narrative = narrative.substring(0, 1000) + "...";

                    let icon = seg.type === 'match' ? '<i class="fa-solid fa-fist-raised"></i>' : '<i class="fa-solid fa-microphone"></i>';
                    let resultBadge = '';
                    
                    if (seg.type === 'match' && seg.actual_winner) {
                        resultBadge = `<span class="text-[9px] font-bold bg-slate-700 px-1 rounded text-green-400 ml-2">WINNER: ${seg.actual_winner}</span>`;
                    }

                    timelineBullets += `
                    <div class="flex gap-4 relative pb-8 border-l-2 border-slate-700 pl-6 ml-2 last:border-0 last:pb-0 group">
                        <div class="absolute -left-[11px] top-0 w-6 h-6 rounded-full bg-slate-800 border-2 border-slate-600 flex items-center justify-center text-[10px] text-slate-400 group-hover:border-blue-500 group-hover:text-white transition">
                            ${icon}
                        </div>
                        <div>
                            <div class="flex items-center gap-2 mb-1">
                                <span class="text-[10px] font-bold text-slate-500 uppercase tracking-widest">${show.date} • ${show.name}</span>
                                ${resultBadge}
                            </div>
                            <div class="text-sm font-bold text-slate-200">${seg.title}</div>
                            <div class="text-xs text-slate-400 mt-1 italic leading-relaxed border-l-2 border-slate-600 pl-2">"${narrative}"</div>
                        </div>
                    </div>`;
                }
            });
        });

        if (timelineBullets === '') timelineBullets = `<div class="text-xs text-slate-600 italic pl-4">No interactions recorded in this chapter.</div>`;

        // 3. Find Finale (If it exists for this chapter)
        let finaleHTML = '';
        if (blowoffId) {
            const show = currentSave.shows.find(s => String(s.id) === String(blowoffId));
            if (show && show.segments) {
                const match = show.segments.find(seg => 
                    seg.type === 'match' && 
                    seg.participants && 
                    seg.participants.some(p => allParticipants.includes(p))
                );

                if (match) {
                    finaleHTML = `
                    <div class="mt-6 mb-8 transform hover:scale-[1.01] transition duration-300">
                        <div class="bg-gradient-to-r from-red-900/40 to-slate-900 border-l-4 border-red-500 p-5 rounded-r-lg shadow-xl">
                            <div class="flex justify-between items-start mb-2">
                                <span class="text-[10px] font-black text-red-500 uppercase tracking-[0.2em]">CHAPTER FINALE</span>
                                <span class="text-[10px] font-bold text-slate-500 uppercase">${show.date} • ${show.name}</span>
                            </div>
                            <h3 class="text-xl font-black text-white italic mb-2">${match.title}</h3>
                            <div class="text-sm text-slate-300 italic bg-black/30 p-3 rounded border border-white/5">
                                "${match.notes || match.desc || "Match conclusion."}"
                            </div>
                            <div class="mt-3 flex items-center gap-2">
                                <span class="text-xs font-bold text-slate-500 uppercase">Victor:</span>
                                <span class="text-xs font-black text-green-400 bg-green-900/30 px-2 py-1 rounded border border-green-700/50">${match.actual_winner || "Draw"}</span>
                            </div>
                        </div>
                    </div>`;
                }
            }
        }

        // 4. Wrapper for the Chapter
        const title = isCurrent ? "CURRENT RUN (Active)" : `CHAPTER ${chapterIndex + 1}`;
        const dateRange = `${start} — ${end ? end : 'Present'}`;
        
        return `
            <div class="mb-12 relative">
                <div class="sticky top-0 bg-slate-900/95 backdrop-blur z-10 py-3 border-b border-slate-700 mb-6 flex justify-between items-end">
                    <h3 class="text-lg font-black text-white italic tracking-tighter">${title}</h3>
                    <span class="text-[10px] font-mono text-slate-400">${dateRange}</span>
                </div>
                ${timelineBullets}
                ${finaleHTML}
            </div>
        `;
    };

    // --- MAIN RENDER LOOP ---
    
    // A. Render Past Chapters
    if (r.chapters && r.chapters.length > 0) {
        r.chapters.forEach((chap, idx) => {
            combinedHTML += renderChapter(chap.start, chap.end, chap.blowoff, idx, false);
        });
    }

    // B. Render Current Active Run
    if (r.status === 'active') {
        const nextIdx = (r.chapters ? r.chapters.length : 0);
        combinedHTML += renderChapter(r.start, null, r.blowoff, nextIdx, true);
    }
    // C. Render Legacy Single Run (If archived but no chapters yet)
    else if (r.status === 'archived' && (!r.chapters || r.chapters.length === 0)) {
        combinedHTML += renderChapter(r.start, r.archivedDate, r.blowoff, 0, false);
    }

    const activeLabel = r.status === 'active' ? '<span class="bg-green-600 text-white px-2 py-1 rounded text-[10px] font-bold uppercase tracking-wider animate-pulse">Live Storyline</span>' : '<span class="bg-slate-600 text-white px-2 py-1 rounded text-[10px] font-bold uppercase tracking-wider">Archived</span>';

    return `
        <div class="animate-fade-in max-w-4xl mx-auto">
            <div class="mb-8 border-b-2 border-slate-700 pb-6">
                <div class="flex justify-between items-start mb-2">
                    <div class="text-[10px] font-bold text-slate-500 uppercase tracking-widest">Rivalry History</div>
                    ${activeLabel}
                </div>
                <h1 class="text-4xl font-black text-white italic uppercase tracking-tight mb-2">${r.name}</h1>
                <div class="flex items-center gap-4 text-xs text-slate-400 font-mono">
                    <span><i class="fa-solid fa-tv mr-2"></i>${r.host}</span>
                    <span><i class="fa-solid fa-flag-checkered mr-2"></i>Goal: ${r.goal}</span>
                </div>
            </div>

            <div class="space-y-4">
                ${combinedHTML}
            </div>
            
            <div class="mt-12 pt-6 border-t border-slate-800 flex justify-between items-center bg-slate-900 sticky bottom-0 p-4">
                ${r.status === 'archived' ? `
                <button onclick="resumeRivalry('${r.id}')" class="bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded font-bold text-xs shadow-lg flex items-center gap-2 transform hover:-translate-y-1 transition">
                    <i class="fa-solid fa-book-open"></i> Start New Chapter
                </button>` : `<div class="text-xs text-green-400 font-bold italic">● Storyline is Active</div>`}
                
                <button onclick="deleteCurrentRivalry()" class="text-xs text-red-500 hover:text-red-400 flex items-center gap-1 opacity-60 hover:opacity-100 transition">
                    <i class="fa-solid fa-trash"></i> Delete Entire History
                </button>
            </div>
        </div>
    `;
}

// =========================================
// THE NIELSEN ENGINE (4-LAYER SYSTEM)
// =========================================

const ERA_RATINGS_WEIGHTS = {
    territories:    { match_quality: 1.5, star_power: 0.8, shock: 0.2, clean_finish_bonus: 0.3 },
    golden:         { match_quality: 0.6, star_power: 1.5, shock: 0.5, clean_finish_bonus: 0.2 },
    new_generation: { match_quality: 1.0, star_power: 1.0, shock: 0.5, clean_finish_bonus: 0.2 }, // Added
    attitude:       { match_quality: 0.4, star_power: 1.2, shock: 2.0, clean_finish_bonus: -0.1 },
    ruthless:       { match_quality: 1.2, star_power: 1.0, shock: 0.8, clean_finish_bonus: 0.1 },
    pg:             { match_quality: 0.8, star_power: 1.4, shock: 0.4, clean_finish_bonus: 0.2 },
    reality:        { match_quality: 1.5, star_power: 0.7, shock: 0.5, clean_finish_bonus: 0.0 },
    current:        { match_quality: 1.2, star_power: 1.0, shock: 1.0, clean_finish_bonus: 0.1 }
};

function calculateShowRatings() {
    initRatingsSystem();
    const era = currentSave.era || 'current';
    const weights = ERA_RATINGS_WEIGHTS[era] || ERA_RATINGS_WEIGHTS['current'];
    const brand = currentSave.brandHealth;

    // --- LAYER A: BASELINE (Brand Health) ---
    // The "Default" number of people who tune in regardless of the card.
    // Momentum drifts the baseline up or down slowly.
    let baseline = brand.baseline;
    
    // Apply Momentum Drift (If momentum > 50, baseline creeps up)
    const momentumEffect = (brand.momentum - 50) * 0.005; 
    baseline += momentumEffect;
    
    // Hard Caps for realism (2.0 to 6.0 scale)
    baseline = Math.max(2.0, Math.min(6.0, baseline));

    // --- PROCESS SEGMENTS ---
    let totalShowScore = 0;
    let segmentCount = 0;
    
    // Store calculated ratings IN the cardData so the AI can see them
    cardData.forEach((seg, index) => {
        let segmentScore = baseline;

       // 1. STAR POWER CALCULATION (Powered by Power Rankings)
        let totalPop = 0;
        let participantCount = 0;
        
        // Fetch the latest "Global" system rankings for reference
        const powerList = (currentSave.powerRankings && currentSave.powerRankings.global && currentSave.powerRankings.global.ai) 
                          ? currentSave.powerRankings.global.ai 
                          : [];

        if (seg.participants) {
            seg.participants.forEach(name => {
                const w = currentSave.roster.find(r => r.name === name);
                let starScore = 40; // Default jobber score

                if (w) {
                    // OPTION A: Use Power Ranking Score (Dynamic Heat)
                    const rankEntry = powerList.find(e => e.name === name);
                    if (rankEntry && rankEntry.score) {
                        starScore = rankEntry.score; 
                    } 
                    // OPTION B: Fallback to static popularity if unranked
                    else if (w.stats && w.stats.popularity) {
                        starScore = w.stats.popularity;
                    }

                    // Bonus for Champions (Belts draw)
                    if(w.status === 'champ') starScore += 10;
                    
                    // Bonus for Legends (Nostalgia draw)
                    if(w.isLegend) starScore += 10;
                }
                
                totalPop += starScore;
                participantCount++;
            });
        }
        
        // Calculate Segment Star Power (0.0 to 100.0 scale effectively)
        const avgPop = participantCount > 0 ? (totalPop / participantCount) : 40;
        
        // Convert to Rating Modifier (-0.5 to +0.5 approx)
        // 50 is "Average", so 80 (Main Eventer) gives (30/50)*weight = +0.6 boost
        const starPowerMod = ((avgPop - 50) / 50) * weights.star_power;

        // 2. MATCH QUALITY (Stars)
        // Convert 5-star scale to a multiplier. 3 stars = neutral.
        const starRating = parseFloat(seg.stars || 2.5);
        const qualityMod = ((starRating - 3) * 0.2) * weights.match_quality;

        // 3. LAYER C: STORY MOMENTUM (Lag Effect)
        // Check if this segment involves a "Hot Rivalry"
        let storyMod = 0;
        if (currentSave.rivalries) {
            const relatedRivalry = currentSave.rivalries.find(r => 
                seg.participants && r.sides.flat().some(p => seg.participants.includes(p))
            );
            if (relatedRivalry) {
                // Older rivalries burn out, newer ones generate heat
                // Simple logic: Is it a title match? +0.2. Is it a blowoff? +0.4
                if (seg.is_title_match) storyMod += 0.2;
                if (String(activeShow.id) === String(relatedRivalry.blowoff)) storyMod += 0.4;
            }
        }

        // 4. LAYER D: FAN REACTION (The "Swerve" Check)
        // If the Era hates DQ finishes (Territories) and you booked a DQ, penalty.
        // If the Era loves Shock (Attitude) and you booked a DQ, bonus.
        let reactionMod = 0;
        const finish = seg.actual_winner; // or booked_finish
        
        // Example: Attitude Era loves shenanigans, Territories hate them
        if (seg.notes && (seg.notes.toLowerCase().includes('dq') || seg.notes.toLowerCase().includes('count out'))) {
            if (era === 'attitude') reactionMod += 0.2;
            if (era === 'territories') reactionMod -= 0.3;
        }

        // --- FINAL CALCULATION ---
        segmentScore = baseline + starPowerMod + qualityMod + storyMod + reactionMod;
        
        // Random Variance (Nielsen Noise) +/- 0.1
        segmentScore += (Math.random() * 0.2) - 0.1;

        // Save to Segment
        seg.rating = segmentScore.toFixed(2);
        
        totalShowScore += segmentScore;
        segmentCount++;
    });

    // --- UPDATE BRAND HEALTH FOR NEXT WEEK ---
    const avgRating = totalShowScore / segmentCount;
    
    // Did we beat the baseline?
    const performance = avgRating - brand.baseline;
    
    // Update Trust & Momentum
    if (performance > 0) {
        brand.momentum += 2; // Up
        brand.trust += 1;
    } else {
        brand.momentum -= 2; // Down
        brand.trust -= 1;
    }
    
    // Clamp
    brand.momentum = Math.max(0, Math.min(100, brand.momentum));
    brand.trust = Math.max(0, Math.min(100, brand.trust));
    
    // Set Baseline for NEXT show (Weighted Moving Average)
    // 80% stickiness, 20% reaction to tonight
    brand.baseline = (brand.baseline * 0.8) + (avgRating * 0.2);
    brand.lastShowRating = avgRating.toFixed(2);

    saveGame();
    return avgRating.toFixed(2);
}

function initRatingsSystem() {
    // Safety check to ensure currentSave exists
    if (currentSave && !currentSave.brandHealth) {
        currentSave.brandHealth = {
            trust: 50,          // 0-100: How much fans trust creative
            momentum: 50,       // 0-100: Current "Hotness" of product
            baseline: 3.0,      // The starting Nielsen number (e.g. 3.0)
            lastShowRating: 3.0 // What the previous show did
        };
    }
}

function resumeRivalry(id) {
    if (!confirm("Start a new chapter for this rivalry?\n\nThis will preserve the old history as 'Chapter' and start a fresh timeline from today.")) return;

    // 1. Find in Archive
    const rIndex = currentSave.archivedRivalries.findIndex(x => x.id === id);
    if (rIndex === -1) return;

    const r = currentSave.archivedRivalries[rIndex];

    // 2. Initialize Chapter History if missing
    if (!r.chapters) r.chapters = [];

    // 3. Snapshot the OLD run as a "Chapter" if it wasn't already saved
    // We check if the last chapter matches current data to avoid duplicates
    const lastChap = r.chapters[r.chapters.length - 1];
    if (!lastChap || lastChap.end !== r.archivedDate) {
        r.chapters.push({
            start: r.start,
            end: r.archivedDate,
            blowoff: r.blowoff,
            name: r.name
        });
    }

    // 4. Reset for NEW Run (Chapter 2)
    r.status = 'active';
    
    // Set NEW start date to the NEXT available show (or today)
    // This creates the clean break you requested
    r.start = getNextShowDate(); 
    
    delete r.archivedDate;   // Open-ended
    delete r.conclusionShow; // Clear finale marker
    r.blowoff = "";          // Needs a new finale
    
    // 5. Move back to Active
    currentSave.rivalries.push(r);
    currentSave.archivedRivalries.splice(rIndex, 1);

    // 6. Refresh UI
    saveGame();
    renderRivalryList();
    loadRivalry(r.id);

    alert(`Rivalry Resumed!\n\nPrevious history saved as Chapter ${r.chapters.length}.\nNew timeline starts ${r.start}.`);
}

// --- NEW FACTION MANAGEMENT LOGIC ---

// 1. Remove Member
function removeTeamMember(wrestlerId, teamName) {
    const w = currentSave.roster.find(r => r.id === wrestlerId);
    if(w) {
        delete w.teamName;
        delete w.teamId;
        saveGame();
        // Refresh the modal to show the removal
        viewTeamMembers(teamName);
        // Refresh sidebar/roster in background
        renderRosterSidebar();
        renderRoster();
    }
}

// 2. Open "Add Member" Picker
// 2. Open "Add Member" Picker (Restricted by Show)
function openAddTeamMember(teamName) {
    // 1. Setup UI
    document.getElementById('team-add-target').value = teamName;
    const select = document.getElementById('team-add-select');
    select.innerHTML = '<option value="">Select Wrestler...</option>';
    
    // 2. Identify the Faction's Home Show
    // We look at the existing members to determine which show this faction belongs to.
    const currentMembers = currentSave.roster.filter(w => w.teamName === teamName);
    let targetShow = ""; 
    let showLabel = "Free Agents";

    if (currentMembers.length > 0) {
        // We use the show of the first member found as the "Home Brand"
        targetShow = currentMembers[0].shows; 
        showLabel = targetShow ? targetShow : "Free Agents";
    }

    document.getElementById('team-add-name').innerText = `${teamName} (${showLabel} Roster)`;

    // 3. Filter Candidates
    // Rule: Must be on the SAME SHOW and NOT already in the team
    const available = currentSave.roster
        .filter(w => {
            const isOnSameShow = (w.shows === targetShow);
            const isNotTeammate = (w.teamName !== teamName);
            return isOnSameShow && isNotTeammate;
        })
        .sort((a,b) => a.name.localeCompare(b.name));
        
    // 4. Render Options
    if (available.length === 0) {
        select.innerHTML = '<option value="">No eligible wrestlers on this show.</option>';
    } else {
        available.forEach(w => {
            let label = w.name;
            if (w.status === 'champ') label += ' 👑'; // Add crown for context
            select.innerHTML += `<option value="${w.id}">${label}</option>`;
        });
    }

    // 5. Swap Modals
    document.getElementById('team-modal').classList.add('hidden');
    document.getElementById('team-add-modal').classList.remove('hidden');
}
// 3. Confirm Add
function saveTeamMemberAdd() {
    const teamName = document.getElementById('team-add-target').value;
    const wrestlerId = document.getElementById('team-add-select').value;
    
    if(!wrestlerId) return;
    
    const w = currentSave.roster.find(r => r.id === wrestlerId);
    if(w) {
        w.teamName = teamName;
        w.teamId = teamName.toLowerCase().replace(/\s+/g, '_');
        
        saveGame();
        
        // Return to main team modal
        document.getElementById('team-add-modal').classList.add('hidden');
        viewTeamMembers(teamName);
        
        // Refresh background
        renderRosterSidebar();
        renderRoster();
    }
}

// 4. Cancel Add
function cancelTeamAdd() {
    const teamName = document.getElementById('team-add-target').value;
    document.getElementById('team-add-modal').classList.add('hidden');
    viewTeamMembers(teamName); // Go back to main list
}


function addManagerSlot() {
    const container = document.getElementById('manager-container');
    if (container.children.length >= 5) return alert("Max 5 managers allowed.");

    // 1. Build Manager Options (Active Roster)
    const roster = getAvailableRosterObjects();
    let mgrOpts = '<option value="">Select Manager</option>';
    roster.forEach(w => {
        let label = w.name;
        if(w.status === 'champ') label += ' 👑';
        // Note: We don't disable injured here as injured stars often serve as managers
        mgrOpts += `<option value="${w.name}">${label}</option>`;
    });

    // 2. Build Client Options (Current Participants)
    // We scrape the names currently typed/selected in the participant boxes
    const partInputs = document.querySelectorAll('#competitor-container select');
    let clientOpts = '';
    let foundParticipants = false;
    
    partInputs.forEach((input, idx) => {
        const val = input.value || `Participant ${idx+1}`;
        clientOpts += `<option value="${val}">${val}</option>`;
        foundParticipants = true;
    });
    
    if(!foundParticipants) clientOpts = '<option value="">No Participants Set</option>';

    // 3. Create the Row
    const div = document.createElement('div');
    div.className = "flex gap-2 items-center animate-fade-in";
    div.innerHTML = `
        <select class="manager-select w-1/2 bg-slate-800 border border-slate-600 text-white p-2 rounded text-xs">${mgrOpts}</select>
        <span class="text-slate-500 text-xs font-bold">w/</span>
        <select class="client-select w-1/2 bg-slate-800 border border-slate-600 text-white p-2 rounded text-xs">${clientOpts}</select>
        <button onclick="this.parentElement.remove()" class="text-slate-500 hover:text-red-500 px-2" title="Remove"><i class="fa-solid fa-xmark"></i></button>
    `;
    container.appendChild(div);
}

// --- NEW HELPER: Add Manager Slot for EDIT Modal ---
function addEditManagerSlot(prefillManager = "", prefillClient = "") {
    const container = document.getElementById('edit-manager-container');
    if (container.children.length >= 5) return alert("Max 5 managers allowed.");

    // 1. Get Roster Options
    const roster = getAvailableRosterObjects();
    let mgrOpts = '<option value="">Select Manager</option>';
    roster.forEach(w => {
        let label = w.name;
        if(w.status === 'champ') label += ' 👑';
        let selected = (w.name === prefillManager) ? 'selected' : '';
        mgrOpts += `<option value="${w.name}" ${selected}>${label}</option>`;
    });

    // 2. Get Participants (Client Options) from the EDIT inputs
    const partInputs = document.querySelectorAll('#edit-competitor-container select');
    let clientOpts = '';
    let foundParticipants = false;
    
    partInputs.forEach((input, idx) => {
        const val = input.value || `Participant ${idx+1}`;
        let selected = (val === prefillClient) ? 'selected' : '';
        clientOpts += `<option value="${val}" ${selected}>${val}</option>`;
        foundParticipants = true;
    });
    
    if(!foundParticipants) clientOpts = '<option value="">No Participants Set</option>';

    // 3. Create Row
    const div = document.createElement('div');
    div.className = "flex gap-2 items-center animate-fade-in";
    div.innerHTML = `
        <select class="edit-manager-select w-1/2 bg-slate-800 border border-slate-600 text-white p-2 rounded text-xs">${mgrOpts}</select>
        <span class="text-slate-500 text-xs font-bold">w/</span>
        <select class="edit-client-select w-1/2 bg-slate-800 border border-slate-600 text-white p-2 rounded text-xs">${clientOpts}</select>
        <button onclick="this.parentElement.remove()" class="text-slate-500 hover:text-red-500 px-2" title="Remove"><i class="fa-solid fa-xmark"></i></button>
    `;
    container.appendChild(div);
}


// --- NEW: SIMULATION LOADING UI ---
function showLoadingOverlay(msg) {
    let overlay = document.getElementById('sim-overlay');
    if(!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'sim-overlay';
        overlay.className = 'fixed inset-0 bg-black/90 z-[60] flex flex-col items-center justify-center';
        overlay.innerHTML = `
            <i class="fa-solid fa-clock-rotate-left fa-spin text-5xl text-purple-500 mb-4"></i>
            <h2 class="text-2xl font-bold text-white mb-2">Simulating Timeline</h2>
            <div class="w-64 bg-slate-800 rounded-full h-2 mb-2">
                <div id="sim-bar" class="bg-purple-500 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
            <p id="sim-status" class="text-slate-400 text-xs font-mono animate-pulse">Initializing...</p>
        `;
        document.body.appendChild(overlay);
    }
    document.getElementById('sim-status').innerText = msg;
    overlay.classList.remove('hidden');
}

function updateLoadingProgress(percent, text) {
    const bar = document.getElementById('sim-bar');
    const status = document.getElementById('sim-status');
    if(bar) bar.style.width = `${percent}%`;
    if(status && text) status.innerText = text;
}

function hideLoadingOverlay() {
    const overlay = document.getElementById('sim-overlay');
    if(overlay) overlay.classList.add('hidden');
}


// ==========================================
// ALGORITHMIC SIMULATION ENGINE (No AI)
// ==========================================

const FINISH_TEMPLATES = [
    "{W} wins with a decisive finisher.",
    "{W} steals the win with a roll-up!",
    "{W} dominates and gets the pinfall.",
    "{W} wins after a hard-fought battle.",
    "{W} secures the victory via submission.",
    "{W} wins by disqualification after interference.",
    "{W} catches {L} with a surprise counter.",
    "{W} outlasts {L} in a grueling match."
];

function simulateMatchAlgorithm(seg) {
    // 1. Identify Participants
    const parts = seg.participants || [];
    if (parts.length === 0) return { winner: "Draw", stars: "2.0", summary: "No participants." };

    // 2. Determine Winner (Based on Power Score if available, else Random)
    // We try to find the "Strongest" wrestler to simulate realistic booking
    let winner = parts[0]; 
    if (currentSave.roster) {
        // Sort participants by Power Score (High to Low)
        const sorted = parts.sort((a, b) => {
            const statA = currentSave.roster.find(r => r.name === a)?.powerScore || 50;
            const statB = currentSave.roster.find(r => r.name === b)?.powerScore || 50;
            return statB - statA; 
        });
        
        // 70% chance the "Strongest" wins, 30% chance of upset
        const upsetChance = Math.random();
        winner = (upsetChance > 0.3) ? sorted[0] : sorted[sorted.length - 1];
    } else {
        // Pure random fallback
        winner = parts[Math.floor(Math.random() * parts.length)];
    }

    // 3. Determine Star Rating (Random Bell Curve around 2.5 - 3.5)
    // Math.random() + Math.random() creates a bell curve distribution
    let rawStars = (Math.random() * 2.5) + (Math.random() * 2.5); 
    let stars = (Math.round(rawStars * 2) / 2).toFixed(1); // Round to 0.5

    // 4. Generate Summary
    let loser = parts.find(p => p !== winner) || "opponent";
    let summary = FINISH_TEMPLATES[Math.floor(Math.random() * FINISH_TEMPLATES.length)];
    summary = summary.replace("{W}", winner).replace("{L}", loser);

    return { winner, stars, summary };
}

</script>

<div id="team-modal" class="hidden fixed inset-0 bg-black/60 flex items-center justify-center z-50" onclick="this.classList.add('hidden')">
    <div class="bg-slate-900 border border-slate-600 p-6 rounded-xl shadow-2xl max-w-sm w-full text-center transform scale-100 transition-all" onclick="event.stopPropagation()">
        <h3 id="team-modal-title" class="text-2xl font-black text-white mb-1 uppercase tracking-widest italic">TEAM NAME</h3>
        <div class="h-1 w-16 bg-purple-500 mx-auto mb-4 rounded"></div>
        <div id="team-modal-list" class="space-y-2 text-slate-300 font-bold text-lg"></div>
        <div class="mt-6 pt-4 border-t border-slate-700">
            <button onclick="document.getElementById('team-modal').classList.add('hidden')" class="text-xs text-slate-500 hover:text-white uppercase font-bold tracking-wider">Close</button>
        </div>
    </div>
</div>

<div id="team-add-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50">
    <div class="bg-slate-900 border border-slate-700 p-6 rounded-xl w-full max-w-sm shadow-2xl">
        <h3 class="text-white font-bold mb-1">Add to Faction</h3>
        <p id="team-add-name" class="text-xs text-purple-400 font-bold uppercase mb-4">Team Name</p>
        <input type="hidden" id="team-add-target">
        
        <label class="text-[10px] text-slate-500 font-bold uppercase">Select Wrestler</label>
        <select id="team-add-select" class="w-full bg-slate-800 border-slate-600 text-white p-3 rounded mb-4 mt-1 text-sm focus:border-purple-500 outline-none">
            </select>
        
        <div class="flex gap-2">
            <button onclick="cancelTeamAdd()" class="flex-1 bg-slate-700 text-white py-2 rounded text-xs font-bold">Cancel</button>
            <button onclick="saveTeamMemberAdd()" class="flex-1 bg-purple-600 text-white py-2 rounded text-xs font-bold hover:bg-purple-500">Add Member</button>
        </div>
    </div>
</div>

<div id="sync-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50">
    <div class="bg-slate-900 border border-slate-700 p-6 rounded-xl w-full max-w-sm text-center shadow-2xl">
        <h3 class="text-xl font-bold text-white mb-2">Sync Roster Data</h3>
        <p class="text-xs text-slate-400 mb-6">Choose which list is the "Master" version. The other list will be overwritten to match it.</p>
        
        <div class="space-y-3">
            <button onclick="runRosterSync('manual_to_system')" class="w-full bg-slate-800 hover:bg-blue-900 border border-blue-600 text-blue-100 py-3 px-4 rounded-lg flex flex-col items-center justify-center gap-1 transition group">
                <span class="text-sm font-bold uppercase tracking-wider">Push Manual <i class="fa-solid fa-arrow-right mx-1 text-slate-500"></i> System</span>
                <span class="text-[10px] text-blue-300/70 font-normal">Make System Tracker match my manual edits</span>
            </button>
            
            <button onclick="runRosterSync('system_to_manual')" class="w-full bg-slate-800 hover:bg-purple-900 border border-purple-600 text-purple-100 py-3 px-4 rounded-lg flex flex-col items-center justify-center gap-1 transition group">
                <span class="text-sm font-bold uppercase tracking-wider">Pull System <i class="fa-solid fa-arrow-right mx-1 text-slate-500"></i> Manual</span>
                <span class="text-[10px] text-purple-300/70 font-normal">Reset my manual view to match system math</span>
            </button>
        </div>

        <button onclick="document.getElementById('sync-modal').classList.add('hidden')" class="mt-6 text-slate-500 hover:text-white text-xs font-bold uppercase tracking-wider">Cancel</button>
    </div>
</div></body>
</html>